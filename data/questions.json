[
  {
    "id": "react-001",
    "topic": "react",
    "question": "Что такое виртуальный DOM и какие задачи он решает в React?",
    "answer": "Виртуальный DOM — это абстрактное представление реального DOM в виде JavaScript-объектов, которое React хранит в памяти для оптимизации обновлений интерфейса; при изменении state или props React создаёт новое виртуальное дерево компонентов, сравнивает его с предыдущей версией с помощью алгоритма diffing и вычисляет минимальный набор изменений, которые необходимо применить к реальному DOM, что позволяет сократить количество дорогих операций с DOM, повысить производительность и сделать обновления UI более предсказуемыми и управляемыми."
  },
  {
    "id": "react-002",
    "topic": "react",
    "question": "Как работает процесс reconciliation и почему он важен?",
    "answer": "Reconciliation — это процесс, в ходе которого React сравнивает новое виртуальное DOM-дерево с предыдущим состоянием интерфейса, анализируя типы элементов и их ключи, чтобы определить, какие компоненты можно переиспользовать, а какие необходимо пересоздать, после чего React применяет к реальному DOM только необходимые изменения, что позволяет избежать полной перерисовки страницы и значительно улучшить производительность, особенно в сложных интерфейсах с большим количеством компонентов."
  },
  {
    "id": "react-003",
    "topic": "react",
    "question": "Почему React рекомендует использовать функциональные компоненты вместо классовых?",
    "answer": "Функциональные компоненты стали рекомендуемым подходом в React после появления хуков, так как они позволяют использовать состояние, побочные эффекты и другую логику без классов, уменьшают количество шаблонного кода, упрощают композицию и переиспользование логики, делают поведение компонентов более предсказуемым и облегчают тестирование и сопровождение приложения по сравнению с классовыми компонентами."
  },
  {
    "id": "react-004",
    "topic": "react",
    "question": "Как React обрабатывает обновления state внутри функционального компонента?",
    "answer": "При обновлении state с помощью функции из useState React не изменяет состояние немедленно, а ставит обновление в очередь, может объединить несколько обновлений в один рендер для оптимизации, затем повторно вызывает функцию компонента, создаёт новое виртуальное DOM-дерево, запускает процесс reconciliation и применяет к реальному DOM только минимально необходимые изменения, обеспечивая эффективное и производительное обновление интерфейса."
  },
  {
    "id": "react-005",
    "topic": "react",
    "question": "В чём заключается проблема props drilling и как её обычно решают?",
    "answer": "Props drilling возникает, когда данные и колбэки передаются через несколько уровней компонентов, которые сами их не используют, что приводит к усложнению структуры кода и ухудшению читаемости и поддержки, а решается эта проблема с помощью React Context для глобально доступных данных, state-менеджеров, композиции компонентов или более грамотного подъёма состояния на уровень, где оно действительно необходимо."
  },
  {
    "id": "react-006",
    "topic": "react",
    "question": "Что такое React и зачем он нужен?",
    "answer": "React — это JavaScript-библиотека для построения пользовательских интерфейсов, основная задача которой заключается в создании декларативного, компонентного и предсказуемого UI; React позволяет разбивать интерфейс на независимые компоненты, эффективно обновлять отображение при изменении данных и управлять сложным состоянием приложения, что особенно полезно при разработке масштабируемых и динамических веб-приложений."
  },
  {
    "id": "react-007",
    "topic": "react",
    "question": "В чём разница между React и обычным JavaScript?",
    "answer": "Обычный JavaScript предполагает императивное управление DOM, где разработчик вручную описывает, какие элементы и как изменять, тогда как React использует декларативный подход, при котором разработчик описывает, как интерфейс должен выглядеть в зависимости от состояния, а React самостоятельно определяет и применяет необходимые изменения к DOM, снижая сложность кода и вероятность ошибок."
  },
  {
    "id": "react-008",
    "topic": "react",
    "question": "Что такое JSX?",
    "answer": "JSX — это синтаксическое расширение JavaScript, которое позволяет описывать структуру пользовательского интерфейса с помощью HTML-подобного синтаксиса прямо в коде, делая компоненты более читаемыми и декларативными, при этом на этапе сборки JSX компилируется в вызовы React.createElement и не используется браузером напрямую."
  },
  {
    "id": "react-009",
    "topic": "react",
    "question": "Можно ли писать React без JSX?",
    "answer": "Да, React можно писать без JSX, используя прямые вызовы React.createElement, однако такой код быстро становится громоздким и трудночитаемым, поэтому на практике JSX используется почти всегда, так как он значительно упрощает описание интерфейса и улучшает читаемость и поддержку кода."
  },
  {
    "id": "react-010",
    "topic": "react",
    "question": "Что такое компонент в React?",
    "answer": "Компонент в React — это независимая и переиспользуемая часть пользовательского интерфейса, которая принимает данные через props, может управлять собственным состоянием и возвращает описание UI в виде JSX или элементов React, что позволяет строить сложные интерфейсы из простых и логически изолированных блоков."
  },
  {
    "id": "react-011",
    "topic": "react",
    "question": "Чем отличаются функциональные и классовые компоненты?",
    "answer": "Классовые компоненты основаны на ES6-классах и используют методы жизненного цикла для управления логикой, тогда как функциональные компоненты представляют собой обычные функции и с появлением хуков получили доступ к состоянию, эффектам и контексту, что позволило упростить код, сократить количество шаблонных конструкций, улучшить переиспользование логики и сделать компоненты более предсказуемыми и удобными для тестирования."
  },
  {
    "id": "react-012",
    "topic": "react",
    "question": "Что такое props?",
    "answer": "Props — это входные данные компонента в React, которые передаются ему от родительского компонента и используются для конфигурации поведения и отображения UI, позволяя делать компоненты переиспользуемыми, декларативными и независимыми от конкретной реализации родителя."
  },
  {
    "id": "react-013",
    "topic": "react",
    "question": "Можно ли изменять props?",
    "answer": "Изменять props напрямую нельзя, так как они считаются неизменяемыми и принадлежат родительскому компоненту, а попытка их изменения нарушает однонаправленный поток данных; если компоненту нужно изменить данные, он должен вызвать колбэк, переданный через props, чтобы родитель обновил своё состояние и передал новые props вниз."
  },
  {
    "id": "react-014",
    "topic": "react",
    "question": "Что такое state?",
    "answer": "State — это внутреннее состояние компонента, предназначенное для хранения данных, которые могут изменяться со временем и напрямую влияют на отображение интерфейса, например значения форм, флаги загрузки или результаты запросов, при обновлении state React автоматически инициирует повторный рендер компонента."
  },
  {
    "id": "react-015",
    "topic": "react",
    "question": "Чем state отличается от props?",
    "answer": "Props используются для передачи данных от родительского компонента к дочернему и считаются неизменяемыми внутри компонента, тогда как state управляется самим компонентом и может изменяться со временем, при этом оба механизма участвуют в рендере, но выполняют разные роли в архитектуре и управлении данными приложения."
  },
  {
    "id": "react-016",
    "topic": "react",
    "question": "Что такое Virtual DOM?",
    "answer": "Virtual DOM — это абстрактное представление реального DOM в виде JavaScript-объектов, которое React использует для хранения текущего состояния интерфейса в памяти и для вычисления различий между предыдущим и новым состоянием UI, что позволяет оптимизировать обновления и минимизировать количество прямых операций с реальным DOM."
  },
  {
    "id": "react-017",
    "topic": "react",
    "question": "Как React понимает, что компонент нужно перерендерить?",
    "answer": "React принимает решение о перерендере компонента, когда изменяются его state или props, либо когда перерендеривается родительский компонент, после чего React повторно вызывает функцию компонента для вычисления нового виртуального DOM и определения необходимых обновлений интерфейса."
  },
  {
    "id": "react-018",
    "topic": "react",
    "question": "Что такое reconciliation?",
    "answer": "Reconciliation — это процесс сравнения нового виртуального DOM-дерева с предыдущей версией, в ходе которого React анализирует типы элементов и их ключи, чтобы определить, какие части дерева можно переиспользовать, а какие необходимо обновить или пересоздать, и затем применяет минимальный набор изменений к реальному DOM."
  },
  {
    "id": "react-019",
    "topic": "react",
    "question": "Что происходит при изменении state?",
    "answer": "При изменении state React ставит обновление в очередь, может объединить несколько обновлений для оптимизации, затем повторно вызывает компонент для создания нового виртуального DOM, запускает процесс reconciliation и после этого обновляет реальный DOM только в тех местах, где произошли изменения."
  },
  {
    "id": "react-020",
    "topic": "react",
    "question": "Чем отличается initial render от re-render?",
    "answer": "Initial render — это первый рендер компонента, при котором React создаёт DOM-узлы с нуля и монтирует их в документ, тогда как re-render происходит при изменении state или props и включает повторный вызов компонента, сравнение виртуального DOM и обновление только изменившихся частей интерфейса без полного пересоздания DOM."
  },
  {
    "id": "react-021",
    "topic": "react",
    "question": "Что такое хуки в React?",
    "answer": "Хуки в React — это специальные функции, которые позволяют использовать состояние, побочные эффекты и другую функциональность React внутри функциональных компонентов без использования классов, делая код более простым, декларативным и удобным для повторного использования логики между компонентами."
  },
  {
    "id": "react-022",
    "topic": "react",
    "question": "Зачем нужен useState?",
    "answer": "useState используется для добавления локального состояния в функциональный компонент и позволяет хранить и обновлять данные, которые влияют на рендер UI, при этом каждое обновление state инициирует повторный рендер компонента с актуальными значениями."
  },
  {
    "id": "react-023",
    "topic": "react",
    "question": "Зачем нужен useEffect?",
    "answer": "useEffect предназначен для выполнения побочных эффектов в функциональных компонентах, таких как загрузка данных, подписки на события, работа с таймерами или прямое взаимодействие с DOM, которые не должны выполняться непосредственно во время рендера компонента."
  },
  {
    "id": "react-024",
    "topic": "react",
    "question": "Когда вызывается useEffect?",
    "answer": "useEffect вызывается после того, как компонент был отрендерен и изменения были применены к DOM, а также может повторно вызываться после каждого последующего рендера в зависимости от указанных зависимостей, что позволяет синхронизировать внешний мир с состоянием компонента."
  },
  {
    "id": "react-025",
    "topic": "react",
    "question": "Что означает массив зависимостей в useEffect?",
    "answer": "Массив зависимостей в useEffect определяет, при изменении каких значений эффект должен быть выполнен повторно, при пустом массиве эффект выполнится только один раз после монтирования, а при его отсутствии эффект будет запускаться после каждого рендера компонента."
  },
  {
    "id": "react-026",
    "topic": "react",
    "question": "Что означает массив зависимостей в useEffect?",
    "answer": "Массив зависимостей в useEffect указывает React, при изменении каких значений эффект должен быть выполнен повторно, при этом React сравнивает значения зависимостей между рендерами по ссылке, и если хотя бы одно из них изменилось, эффект перезапускается, что позволяет точно контролировать момент выполнения побочных эффектов."
  },
  {
    "id": "react-027",
    "topic": "react",
    "question": "Что будет, если не передать зависимости в useEffect?",
    "answer": "Если не передать массив зависимостей в useEffect, эффект будет выполняться после каждого рендера компонента, что может привести к лишним вызовам побочных эффектов, ухудшению производительности и даже к бесконечным циклам обновления при изменении state внутри эффекта."
  },
  {
    "id": "react-028",
    "topic": "react",
    "question": "Можно ли использовать хуки в условиях или циклах?",
    "answer": "Использовать хуки внутри условий, циклов или вложенных функций нельзя, так как React полагается на строгий порядок вызова хуков между рендерами, и любое условное выполнение может привести к несоответствию этого порядка и некорректной работе состояния."
  },
  {
    "id": "react-029",
    "topic": "react",
    "question": "Почему существуют правила хуков?",
    "answer": "Правила хуков существуют для того, чтобы React мог корректно сопоставлять вызовы хуков с их внутренним состоянием между рендерами, так как React не использует имена хуков, а опирается исключительно на порядок их вызова внутри компонента."
  },
  {
    "id": "react-030",
    "topic": "react",
    "question": "Что такое кастомный хук?",
    "answer": "Кастомный хук — это обычная JavaScript-функция, имя которой начинается с use и которая внутри себя использует другие хуки React, позволяя инкапсулировать и переиспользовать логику состояния и эффектов между разными компонентами."
  },
  {
    "id": "react-031",
    "topic": "react",
    "question": "Когда стоит создавать кастомный хук?",
    "answer": "Кастомный хук стоит создавать, когда одна и та же логика работы со state, эффектами или подписками повторяется в нескольких компонентах, либо когда компонент становится перегруженным логикой и её нужно вынести для улучшения читаемости, переиспользования и тестируемости."
  },
  {
    "id": "react-032",
    "topic": "react",
    "question": "Как обрабатываются события в React?",
    "answer": "События в React обрабатываются с помощью обработчиков, которые передаются в JSX в виде функций, например onClick или onChange, при этом React использует декларативный подход, где логика обработки события описывается в компоненте, а сам React берёт на себя подписку и управление жизненным циклом этих событий."
  },
  {
    "id": "react-033",
    "topic": "react",
    "question": "Чем синтетические события отличаются от нативных?",
    "answer": "Синтетические события в React представляют собой обёртку над нативными событиями браузера и обеспечивают единый интерфейс работы с событиями во всех браузерах, при этом React использует механизм event delegation и нормализует поведение событий, чтобы разработчику не приходилось учитывать браузерные различия."
  },
  {
    "id": "react-034",
    "topic": "react",
    "question": "Как передать параметр в обработчик события?",
    "answer": "Параметр в обработчик события передаётся с помощью оборачивания вызова функции в стрелочную функцию или через bind, например onClick={() => handleClick(id)}, что позволяет передать дополнительные данные, не вызывая обработчик сразу при рендере компонента."
  },
  {
    "id": "react-035",
    "topic": "react",
    "question": "Что такое controlled component?",
    "answer": "Controlled component — это компонент формы, значение которого полностью контролируется состоянием React, где текущее значение хранится в state и обновляется через обработчики событий, что позволяет централизованно управлять данными формы, выполнять валидацию и синхронизировать UI с состоянием приложения."
  },
  {
    "id": "react-036",
    "topic": "react",
    "question": "Что такое uncontrolled component?",
    "answer": "Uncontrolled component — это компонент формы, в котором значение хранится непосредственно в DOM, а доступ к нему осуществляется через refs, такой подход используется реже и подходит для простых сценариев, где не требуется полный контроль состояния формы со стороны React."
  },
  {
    "id": "react-037",
    "topic": "react",
    "question": "Как работать с формами в React?",
    "answer": "Работа с формами в React обычно строится через обработчики событий и состояние компонента, где значения полей ввода связываются с state, обновляются через onChange и используются для управления отображением, отправкой данных и валидацией, что позволяет полностью контролировать поведение формы на уровне приложения."
  },
  {
    "id": "react-038",
    "topic": "react",
    "question": "Как хранить данные формы?",
    "answer": "Данные формы чаще всего хранятся в state компонента с помощью useState или useReducer, где каждое поле формы соответствует отдельному значению или свойству объекта, что позволяет централизованно управлять данными, отслеживать изменения и использовать их при валидации и отправке формы."
  },
  {
    "id": "react-039",
    "topic": "react",
    "question": "Чем controlled input отличается от uncontrolled?",
    "answer": "Controlled input управляется состоянием React, где значение поля задаётся через state и обновляется через onChange, тогда как uncontrolled input хранит значение внутри DOM и доступ к нему осуществляется через refs, что делает controlled-подход более предсказуемым и предпочтительным для сложных форм."
  },
  {
    "id": "react-040",
    "topic": "react",
    "question": "Как валидировать форму?",
    "answer": "Валидация формы в React обычно реализуется через проверку значений, хранящихся в state, либо во время ввода, либо при отправке формы, с использованием кастомной логики, регулярных выражений или сторонних библиотек, при этом результаты валидации используются для отображения ошибок и управления доступностью отправки формы."
  },
  {
    "id": "react-041",
    "topic": "react",
    "question": "Что такое React.memo?",
    "answer": "React.memo — это функция высшего порядка, которая позволяет мемоизировать функциональный компонент и предотвращает его повторный рендер, если его props не изменились, что помогает сократить количество лишних перерендеров и повысить производительность при работе с тяжёлыми или часто обновляемыми компонентами."
  },
  {
    "id": "react-042",
    "topic": "react",
    "question": "Зачем нужен useCallback?",
    "answer": "useCallback используется для мемоизации функции и возвращает одну и ту же ссылку на функцию между рендерами, пока не изменятся зависимости, что особенно полезно при передаче колбэков в дочерние компоненты, оптимизированные с помощью React.memo, чтобы избежать лишних перерендеров."
  },
  {
    "id": "react-043",
    "topic": "react",
    "question": "Зачем нужен useMemo?",
    "answer": "useMemo применяется для мемоизации вычисляемых значений и позволяет избежать повторного выполнения дорогостоящих вычислений при каждом рендере, пересчитывая значение только при изменении указанных зависимостей, что может существенно улучшить производительность в сложных сценариях."
  },
  {
    "id": "react-044",
    "topic": "react",
    "question": "В чём разница между useCallback и useMemo?",
    "answer": "useCallback мемоизирует функцию и возвращает стабильную ссылку на неё, тогда как useMemo мемоизирует результат вычисления и возвращает само значение, при этом useCallback по сути является частным случаем useMemo, оптимизированным для функций."
  },
  {
    "id": "react-045",
    "topic": "react",
    "question": "Когда оптимизация в React может навредить?",
    "answer": "Оптимизация в React может навредить, если использовать мемоизацию без реальной необходимости, так как она усложняет код, увеличивает когнитивную нагрузку и может даже ухудшить производительность из-за дополнительных сравнений зависимостей и хранения мемоизированных значений."
  },
  {
    "id": "react-046",
    "topic": "react",
    "question": "Что такое key и зачем он нужен?",
    "answer": "Key — это специальный атрибут, который используется React при рендере списков для уникальной идентификации элементов, позволяя корректно сопоставлять элементы между рендерами, сохранять их состояние и выполнять эффективные обновления без лишних пересозданий DOM-узлов."
  },
  {
    "id": "react-047",
    "topic": "react",
    "question": "Что такое lifting state up?",
    "answer": "Lifting state up — это архитектурный приём в React, при котором состояние поднимается из дочерних компонентов в ближайший общий родительский компонент, чтобы несколько компонентов могли использовать и синхронно обновлять одни и те же данные через props."
  },
  {
    "id": "react-048",
    "topic": "react",
    "question": "Что такое prop drilling?",
    "answer": "Prop drilling — это ситуация, когда данные и колбэки передаются через несколько уровней компонентов, которые сами эти данные не используют, что приводит к усложнению структуры компонентов и ухудшению читаемости и поддержки кода."
  },
  {
    "id": "react-049",
    "topic": "react",
    "question": "Как решить проблему prop drilling?",
    "answer": "Проблема prop drilling решается с помощью React Context для глобально доступных данных, использования state-менеджеров, композиции компонентов или более грамотного подъёма состояния на уровень, где оно действительно необходимо, чтобы сократить глубину передачи props."
  },
  {
    "id": "react-050",
    "topic": "react",
    "question": "Что такое Context API?",
    "answer": "Context API — это встроенный механизм React, который позволяет передавать данные через дерево компонентов без явной передачи props на каждом уровне, что удобно для хранения глобальных данных, таких как тема, язык интерфейса или данные авторизации."
  },
  {
    "id": "react-051",
    "topic": "react",
    "question": "Когда не стоит использовать Context?",
    "answer": "Context не стоит использовать для часто изменяющихся данных или локального состояния, так как каждое обновление контекста вызывает перерендер всех подписанных компонентов, что может негативно сказаться на производительности и усложнить архитектуру приложения."
  },
  {
    "id": "react-052",
    "topic": "react",
    "question": "Что такое composition в React?",
    "answer": "Composition в React — это подход к построению интерфейса, при котором сложные компоненты создаются путём комбинирования простых компонентов через props и children, что позволяет гибко переиспользовать логику и UI без жёсткой иерархии наследования."
  },
  {
    "id": "react-053",
    "topic": "react",
    "question": "Как делать HTTP-запросы в React?",
    "answer": "HTTP-запросы в React обычно выполняют внутри useEffect или в обработчиках событий, используя fetch или библиотеки вроде axios, при этом важно не делать запросы прямо в теле рендера, чтобы избежать повторных запросов на каждом ререндере, а результаты запроса сохранять в state и на их основе отображать UI."
  },
  {
    "id": "react-054",
    "topic": "react",
    "question": "Где лучше делать запросы: в компоненте или отдельно?",
    "answer": "Запросы можно делать в компоненте для простых случаев, но чаще лучше выносить сетевую логику в отдельный слой (api-клиент, сервисы, hooks или data-fetching библиотеку), чтобы улучшить переиспользуемость, тестируемость и разделение ответственности, а компоненту оставить роль отображения и управления состояниями загрузки."
  },
  {
    "id": "react-055",
    "topic": "react",
    "question": "Как обрабатывать loading и error состояния?",
    "answer": "Loading и error обычно обрабатывают через отдельные поля состояния, например isLoading и error, где перед запросом включают loading, при успехе сохраняют данные и выключают loading, а при ошибке записывают объект ошибки и показывают пользователю сообщение, при этом важно также предусмотреть повтор запроса и корректные состояния для пустых данных."
  },
  {
    "id": "react-056",
    "topic": "react",
    "question": "Что делать при размонтировании компонента и незавершённом запросе?",
    "answer": "При размонтировании компонента важно предотвратить попытку обновить state после завершения запроса, для этого обычно используют AbortController для отмены fetch в cleanup-функции useEffect или флаг актуальности запроса, а при использовании библиотек вроде React Query отмена и управление жизненным циклом запросов часто решаются автоматически."
  },
  {
    "id": "react-057",
    "topic": "react",
    "question": "Какие этапы жизненного цикла компонента ты знаешь?",
    "answer": "Жизненный цикл компонента в React включает этапы монтирования, обновления и размонтирования, где на этапе монтирования компонент создаётся и вставляется в DOM, на этапе обновления происходит повторный рендер при изменении state или props, а на этапе размонтирования компонент удаляется из DOM и должна выполняться очистка ресурсов."
  },
  {
    "id": "react-058",
    "topic": "react",
    "question": "Какие аналоги lifecycle методов есть в хуках?",
    "answer": "В функциональных компонентах аналоги lifecycle методов реализуются с помощью useEffect и useLayoutEffect, где useEffect с пустым массивом зависимостей соответствует componentDidMount, cleanup-функция useEffect соответствует componentWillUnmount, а useEffect с зависимостями используется для обработки обновлений, аналогично componentDidUpdate."
  },
  {
    "id": "react-059",
    "topic": "react",
    "question": "Когда компонент монтируется?",
    "answer": "Компонент считается смонтированным в момент, когда React впервые вызывает функцию компонента, создаёт соответствующие DOM-узлы на основе виртуального DOM и вставляет их в реальный DOM, после чего можно выполнять побочные эффекты, связанные с доступом к DOM или внешними ресурсами."
  },
  {
    "id": "react-060",
    "topic": "react",
    "question": "Когда компонент размонтируется?",
    "answer": "Компонент размонтируется, когда React удаляет его из дерева компонентов и из реального DOM, например при изменении условий рендера или переходе на другую страницу, и в этот момент необходимо освобождать ресурсы, отменять подписки и запросы, чтобы избежать утечек памяти."
  },
  {
    "id": "react-061",
    "topic": "react",
    "question": "Что такое SPA?",
    "answer": "SPA (Single Page Application) — это веб-приложение, в котором загрузка HTML-документа происходит один раз, а дальнейшая навигация и обновление контента выполняются на клиенте с помощью JavaScript без полной перезагрузки страницы, что обеспечивает более быстрый и плавный пользовательский опыт."
  },
  {
    "id": "react-062",
    "topic": "react",
    "question": "Как работает роутинг в React?",
    "answer": "Роутинг в React обычно реализуется на стороне клиента с помощью библиотек вроде React Router, которые отслеживают изменения URL через History API браузера и в зависимости от текущего маршрута отображают соответствующие компоненты без перезагрузки страницы."
  },
  {
    "id": "react-063",
    "topic": "react",
    "question": "Чем отличается client-side routing от server-side routing?",
    "answer": "Client-side routing выполняется в браузере и изменяет отображаемый контент без перезагрузки страницы, тогда как server-side routing обрабатывается сервером, где каждый URL приводит к загрузке нового HTML-документа, что влияет на производительность и пользовательский опыт."
  },
  {
    "id": "react-064",
    "topic": "react",
    "question": "Что такое SSR?",
    "answer": "SSR (Server-Side Rendering) — это подход, при котором HTML-страница генерируется на сервере для каждого запроса и отправляется в браузер уже с готовым контентом, что улучшает время первого отображения и SEO по сравнению с чистым клиентским рендерингом."
  },
  {
    "id": "react-065",
    "topic": "react",
    "question": "В чём разница между CSR и SSR?",
    "answer": "При CSR (Client-Side Rendering) HTML создаётся в браузере с помощью JavaScript после загрузки приложения, тогда как при SSR HTML формируется на сервере и сразу отправляется пользователю, что ускоряет первый рендер, но усложняет архитектуру и нагрузку на сервер."
  },
  {
    "id": "react-066",
    "topic": "react",
    "question": "Зачем нужен Next.js?",
    "answer": "Next.js — это фреймворк поверх React, который упрощает создание приложений с SSR, SSG и гибридным рендерингом, предоставляет встроенный роутинг, оптимизацию производительности и удобные инструменты для работы с SEO, что делает его подходящим для продакшен-приложений."
  },
  {
    "id": "react-067",
    "topic": "react",
    "question": "Почему компонент может ререндериться слишком часто?",
    "answer": "Компонент может ререндериться слишком часто из-за частых обновлений state или props, перерендеров родительского компонента, создания новых ссылок на функции или объекты при каждом рендере, отсутствия мемоизации и неправильного использования хуков, что в совокупности приводит к лишним вычислениям и снижению производительности."
  },
  {
    "id": "react-068",
    "topic": "react",
    "question": "Как предотвратить лишние ререндеры?",
    "answer": "Лишние ререндеры предотвращают с помощью React.memo, useCallback и useMemo, корректного использования key, подъёма состояния только при необходимости, разделения компонентов на более мелкие и избегания создания новых объектов и функций при каждом рендере без необходимости."
  },
  {
    "id": "react-069",
    "topic": "react",
    "question": "Почему нельзя использовать index как key?",
    "answer": "Index нельзя использовать как key, потому что при изменении порядка элементов, добавлении или удалении React может неправильно сопоставить элементы между рендерами, что приводит к багам, потере состояния компонентов и некорректному обновлению интерфейса."
  },
  {
    "id": "react-070",
    "topic": "react",
    "question": "Что будет, если напрямую изменить state?",
    "answer": "При прямом изменении state React не узнаёт об изменении данных и не запускает повторный рендер, что приводит к несинхронизированному UI, трудноуловимым багам и нарушению принципов предсказуемости работы компонентов."
  },
  {
    "id": "react-071",
    "topic": "react",
    "question": "Как передать данные от дочернего компонента к родительскому?",
    "answer": "Данные от дочернего компонента к родительскому передаются через колбэк-функцию, переданную в props, которую дочерний компонент вызывает с нужными данными, после чего родитель обновляет свой state и передаёт новые props вниз."
  },
  {
    "id": "react-072",
    "topic": "react",
    "question": "Как организовать глобальное состояние?",
    "answer": "Глобальное состояние в React можно организовать с помощью Context API для простых сценариев, специализированных state-менеджеров вроде Redux, Zustand или MobX для более сложных случаев, либо библиотек для работы с серверным состоянием, таких как React Query."
  },
  {
    "id": "react-073",
    "topic": "react",
    "question": "Что ты выберешь: Context или Redux и почему?",
    "answer": "Выбор между Context и Redux зависит от задачи: Context подходит для простых и редко изменяющихся глобальных данных, таких как тема или язык, тогда как Redux лучше использовать для сложного состояния с частыми обновлениями, строгой архитектурой и необходимостью дебага и масштабирования."
  },
  {
    "id": "react-074",
    "topic": "react",
    "question": "Как бы ты структурировал большой React-проект?",
    "answer": "Большой React-проект обычно структурируют по фичам или доменам, разделяя код на модули с компонентами, хуками, сервисами и состоянием, вынося общие части в shared-слой и соблюдая принципы разделения ответственности и масштабируемости."
  },
  {
    "id": "react-075",
    "topic": "react",
    "question": "Какие ошибки чаще всего допускают React-разработчики?",
    "answer": "React-разработчики часто допускают ошибки, такие как неправильное использование хуков и зависимостей useEffect, чрезмерная оптимизация, прямое изменение state, использование index как key, отсутствие разделения логики и UI, а также неправильная работа с асинхронными эффектами."
  },
  {
    "id": "react-076",
    "topic": "react",
    "question": "Что происходит, если в useEffect изменить state без зависимостей?",
    "answer": "Если в useEffect изменить state без указания массива зависимостей, эффект будет выполняться после каждого рендера, что приведёт к бесконечному циклу рендеров и обновлений состояния, потенциально полностью блокируя приложение."
  },
  {
    "id": "js-001",
    "topic": "javascript",
    "question": "Что такое JavaScript?",
    "answer": "JavaScript — это высокоуровневый интерпретируемый язык программирования, который используется для создания интерактивного поведения в веб-приложениях, поддерживает событийную модель, асинхронность и может выполняться как в браузере, так и на сервере."
  },
  {
    "id": "js-002",
    "topic": "javascript",
    "question": "Где и как выполняется JavaScript?",
    "answer": "JavaScript выполняется в среде выполнения, такой как браузер или Node.js, где код интерпретируется JavaScript-движком, например V8, который читает, компилирует и выполняет код, обеспечивая доступ к Web API или серверным возможностям."
  },
  {
    "id": "js-003",
    "topic": "javascript",
    "question": "Чем var отличается от let и const?",
    "answer": "var имеет функциональную область видимости и подвержен hoisting с инициализацией undefined, тогда как let и const имеют блочную область видимости, не доступны до объявления, при этом const запрещает переназначение переменной, но не изменение содержимого объектов."
  },
  {
    "id": "js-004",
    "topic": "javascript",
    "question": "Что такое типы данных в JavaScript?",
    "answer": "Типы данных в JavaScript определяют, какие значения может принимать переменная и какие операции с ними возможны, при этом язык поддерживает как примитивные типы, так и объекты для хранения более сложных структур данных."
  },
  {
    "id": "js-005",
    "topic": "javascript",
    "question": "Какие типы данных являются примитивами?",
    "answer": "К примитивным типам данных в JavaScript относятся string, number, boolean, null, undefined, symbol и bigint, которые являются неизменяемыми и передаются по значению, а не по ссылке."
  },
  {
    "id": "js-006",
    "topic": "javascript",
    "question": "Чем null отличается от undefined?",
    "answer": "undefined означает, что переменная была объявлена, но ей не присвоено значение, тогда как null является явным значением, которое используется разработчиком для обозначения отсутствия значения."
  },
  {
    "id": "js-007",
    "topic": "javascript",
    "question": "Что такое NaN?",
    "answer": "NaN означает Not-a-Number и представляет собой специальное числовое значение, которое возникает в результате некорректных математических операций, например при попытке преобразовать нечисловую строку в число."
  },
  {
    "id": "js-008",
    "topic": "javascript",
    "question": "Как проверить тип значения?",
    "answer": "Тип значения в JavaScript можно проверить с помощью оператора typeof, метода Array.isArray для массивов, оператора instanceof или сравнения с null, так как typeof null возвращает object."
  },
  {
    "id": "js-009",
    "topic": "javascript",
    "question": "Что такое динамическая типизация?",
    "answer": "Динамическая типизация означает, что тип переменной в JavaScript определяется во время выполнения программы и может изменяться в процессе работы, так как переменная не привязана к одному типу данных."
  },
  {
    "id": "js-010",
    "topic": "javascript",
    "question": "Что такое строгий режим (\"use strict\")?",
    "answer": "Строгий режим в JavaScript включает более жёсткие правила выполнения кода, предотвращает использование потенциально опасных конструкций, запрещает неявное создание глобальных переменных и помогает находить ошибки на раннем этапе."
  },
  {
    "id": "js-011",
    "topic": "javascript",
    "question": "Чем == отличается от ===?",
    "answer": "Оператор == выполняет неявное приведение типов перед сравнением значений, что может приводить к неожиданным результатам, тогда как === сравнивает значения строго без приведения типов, проверяя и тип, и значение, поэтому === считается более безопасным и предпочтительным."
  },
  {
    "id": "js-012",
    "topic": "javascript",
    "question": "Что такое неявное приведение типов?",
    "answer": "Неявное приведение типов — это автоматическое преобразование одного типа данных в другой, которое JavaScript выполняет при операциях сравнения, арифметики или логических выражениях, что может упрощать код, но часто становится источником ошибок."
  },
  {
    "id": "js-013",
    "topic": "javascript",
    "question": "Какие значения приводятся к false?",
    "answer": "К false при приведении к boolean приводятся следующие значения: false, 0, -0, 0n, пустая строка, null, undefined и NaN, все остальные значения считаются truthy."
  },
  {
    "id": "js-014",
    "topic": "javascript",
    "question": "Что вернёт Boolean([]) и почему?",
    "answer": "Boolean([]) вернёт true, потому что массив является объектом, а все объекты в JavaScript при приведении к boolean считаются truthy независимо от их содержимого."
  },
  {
    "id": "js-015",
    "topic": "javascript",
    "question": "Что произойдёт при сложении строки и числа?",
    "answer": "При сложении строки и числа JavaScript приведёт число к строке и выполнит конкатенацию, так как оператор + при наличии строки работает как оператор объединения строк."
  },
  {
    "id": "js-016",
    "topic": "javascript",
    "question": "Как работает оператор +?",
    "answer": "Оператор + в JavaScript выполняет либо арифметическое сложение, либо конкатенацию строк, и если хотя бы один из операндов является строкой, происходит приведение второго операнда к строке и выполняется объединение."
  },
  {
    "id": "js-017",
    "topic": "javascript",
    "question": "Чем отличается Object.is от ===?",
    "answer": "Object.is работает почти так же, как ===, но корректно различает NaN и NaN как равные и считает +0 и -0 разными значениями, тогда как === считает NaN неравным самому себе и +0 и -0 равными."
  },
  {
    "id": "js-018",
    "topic": "javascript",
    "question": "Что такое scope?",
    "answer": "Scope — это область видимости переменных и функций в JavaScript, которая определяет, где в коде можно получить доступ к объявленным идентификаторам и какие значения будут использованы при обращении к ним."
  },
  {
    "id": "js-019",
    "topic": "javascript",
    "question": "Какие виды scope существуют?",
    "answer": "В JavaScript существуют глобальный scope, функциональный scope и блочный scope, где глобальный доступен везде, функциональный ограничен телом функции, а блочный применяется к конструкциям вроде if, for и доступен для let и const."
  },
  {
    "id": "js-020",
    "topic": "javascript",
    "question": "Что такое lexical scope?",
    "answer": "Lexical scope — это правило, согласно которому область видимости переменных определяется местом их объявления в исходном коде, а не местом вызова функции, поэтому вложенные функции имеют доступ к переменным внешних областей."
  },
  {
    "id": "js-021",
    "topic": "javascript",
    "question": "Что такое hoisting?",
    "answer": "Hoisting — это механизм JavaScript, при котором объявления переменных и функций обрабатываются до выполнения кода, из-за чего функции и переменные, объявленные через var, доступны до строки их объявления в коде."
  },
  {
    "id": "js-022",
    "topic": "javascript",
    "question": "Что поднимается при hoisting?",
    "answer": "При hoisting поднимаются объявления функций целиком и объявления переменных, при этом переменные, объявленные через var, инициализируются значением undefined, а let и const поднимаются, но остаются недоступными до фактического объявления из-за temporal dead zone."
  },
  {
    "id": "js-023",
    "topic": "javascript",
    "question": "Что такое замыкание?",
    "answer": "Замыкание — это механизм, при котором функция запоминает и имеет доступ к переменным из своей внешней лексической области видимости даже после того, как внешняя функция завершила выполнение."
  },
  {
    "id": "js-024",
    "topic": "javascript",
    "question": "Где на практике используются замыкания?",
    "answer": "Замыкания на практике используются для инкапсуляции данных, создания приватных переменных, реализации фабричных функций, мемоизации, обработки событий и сохранения состояния между вызовами функций."
  },
  {
    "id": "js-025",
    "topic": "javascript",
    "question": "Какие проблемы могут быть с замыканиями?",
    "answer": "Проблемы с замыканиями могут возникать из-за удержания ссылок на переменные и объекты, что приводит к утечкам памяти, а также из-за непонимания области видимости, что может вызывать логические ошибки и неожиданные значения."
  },
  {
    "id": "js-026",
    "topic": "javascript",
    "question": "Какие способы объявления функций ты знаешь?",
    "answer": "В JavaScript функции можно объявлять с помощью function declaration, function expression, arrow function, а также создавать методы объектов и классов, при этом каждый способ имеет особенности области видимости, hoisting и контекста this."
  },
  {
    "id": "js-027",
    "topic": "javascript",
    "question": "Чем function declaration отличается от function expression?",
    "answer": "Function declaration поднимается целиком при hoisting и может быть вызвана до места объявления в коде, тогда как function expression создаётся во время выполнения и доступна только после присваивания переменной."
  },
  {
    "id": "js-028",
    "topic": "javascript",
    "question": "Что такое arrow function?",
    "answer": "Arrow function — это сокращённый синтаксис объявления функции, введённый в ES6, который упрощает запись функций и не создаёт собственного контекста this, arguments, super и new.target."
  },
  {
    "id": "js-029",
    "topic": "javascript",
    "question": "Чем arrow function отличается от обычной функции?",
    "answer": "Arrow function отличается тем, что не имеет собственного this и берёт его из внешнего лексического окружения, не поддерживает вызов через new и не имеет собственного arguments, тогда как обычная функция формирует собственный контекст выполнения."
  },
  {
    "id": "js-030",
    "topic": "javascript",
    "question": "Что такое параметры по умолчанию?",
    "answer": "Параметры по умолчанию позволяют задавать значения аргументов функции прямо в сигнатуре, которые будут использоваться в случае, если соответствующий аргумент не был передан или равен undefined."
  },
  {
    "id": "js-031",
    "topic": "javascript",
    "question": "Что такое rest-параметры?",
    "answer": "Rest-параметры позволяют собрать произвольное количество аргументов функции в массив с помощью оператора ..., что делает работу с переменным числом аргументов более удобной и предсказуемой."
  },
  {
    "id": "js-032",
    "topic": "javascript",
    "question": "Что такое arguments?",
    "answer": "arguments — это псевдомассив, доступный внутри обычных функций, который содержит все переданные аргументы, но не поддерживается в arrow function и считается устаревшим по сравнению с rest-параметрами."
  },
  {
    "id": "js-033",
    "topic": "javascript",
    "question": "Что такое чистая функция?",
    "answer": "Чистая функция — это функция, которая при одинаковых входных данных всегда возвращает одинаковый результат и не имеет побочных эффектов, то есть не изменяет внешнее состояние и не зависит от него."
  },
  {
    "id": "js-034",
    "topic": "javascript",
    "question": "Что такое this?",
    "answer": "this — это специальное ключевое слово в JavaScript, которое указывает на объект, в контексте которого была вызвана функция, и используется для доступа к данным и методам этого объекта во время выполнения кода."
  },
  {
    "id": "js-035",
    "topic": "javascript",
    "question": "От чего зависит значение this?",
    "answer": "Значение this зависит от способа вызова функции: при вызове как метода объекта this указывает на объект, при обычном вызове функции — на глобальный объект или undefined в строгом режиме, при использовании new — на создаваемый экземпляр, а при call, apply и bind — на явно переданный объект."
  },
  {
    "id": "js-036",
    "topic": "javascript",
    "question": "Как работает this в arrow function?",
    "answer": "В arrow function this не создаётся собственный и берётся из внешнего лексического окружения, то есть равен значению this в месте объявления функции, а не в месте её вызова."
  },
  {
    "id": "js-037",
    "topic": "javascript",
    "question": "Что делают call, apply и bind?",
    "answer": "Методы call, apply и bind позволяют явно задать значение this для функции, где call и apply сразу вызывают функцию с указанным контекстом, а bind возвращает новую функцию с навсегда привязанным this."
  },
  {
    "id": "js-038",
    "topic": "javascript",
    "question": "В чём разница между call и apply?",
    "answer": "Разница между call и apply заключается в способе передачи аргументов, так как call принимает аргументы по отдельности, а apply принимает массив аргументов, при этом оба метода сразу вызывают функцию с заданным this."
  },
  {
    "id": "js-039",
    "topic": "javascript",
    "question": "Можно ли изменить this у arrow function?",
    "answer": "Изменить this у arrow function нельзя, так как она не имеет собственного контекста и всегда использует this из внешней области видимости, поэтому методы call, apply и bind на неё не влияют."
  },
  {
    "id": "js-040",
    "topic": "javascript",
    "question": "Как создать объект в JavaScript?",
    "answer": "Объект в JavaScript можно создать с помощью литерала объекта {}, конструктора Object, функции-конструктора с оператором new, метода Object.create для явного указания прототипа или с использованием синтаксиса class, который под капотом также работает через прототипы."
  },
  {
    "id": "js-041",
    "topic": "javascript",
    "question": "Что такое прототип?",
    "answer": "Прототип — это объект, из которого другие объекты могут наследовать свойства и методы, и он используется JavaScript для реализации наследования и повторного использования функциональности."
  },
  {
    "id": "js-042",
    "topic": "javascript",
    "question": "Что такое prototype chain?",
    "answer": "Prototype chain — это цепочка прототипов, по которой JavaScript ищет свойство или метод, начиная с самого объекта и поднимаясь по его прототипам до Object.prototype или null."
  },
  {
    "id": "js-043",
    "topic": "javascript",
    "question": "Как работает наследование в JavaScript?",
    "answer": "Наследование в JavaScript реализуется через прототипы, где один объект ссылается на другой как на свой прототип, благодаря чему он получает доступ к его свойствам и методам без их копирования."
  },
  {
    "id": "js-044",
    "topic": "javascript",
    "question": "Что такое __proto__?",
    "answer": "__proto__ — это внутреннее свойство объекта, которое указывает на его прототип и используется движком JavaScript для поиска свойств в prototype chain, при этом напрямую работать с ним не рекомендуется."
  },
  {
    "id": "js-045",
    "topic": "javascript",
    "question": "Чем класс отличается от функции-конструктора?",
    "answer": "Класс является синтаксическим сахаром над функцией-конструктором и прототипами, предоставляя более читаемый и структурированный синтаксис, при этом под капотом JavaScript продолжает использовать прототипное наследование."
  },
  {
    "id": "js-046",
    "topic": "javascript",
    "question": "Что такое class и что он делает под капотом?",
    "answer": "Class в JavaScript — это синтаксический сахар, который упрощает создание функций-конструкторов и работу с прототипами, автоматически добавляя методы в prototype и настраивая наследование через prototype chain без изменения базовой модели языка."
  },
  {
    "id": "js-047",
    "topic": "javascript",
    "question": "Как скопировать массив?",
    "answer": "Массив можно скопировать с помощью spread-оператора [...arr], метода slice(), Array.from() или map, при этом такие способы создают поверхностную копию, где вложенные объекты продолжают передаваться по ссылке."
  },
  {
    "id": "js-048",
    "topic": "javascript",
    "question": "Чем map отличается от forEach?",
    "answer": "Метод map возвращает новый массив с результатами выполнения функции для каждого элемента и используется для преобразования данных, тогда как forEach просто выполняет функцию для каждого элемента и ничего не возвращает, поэтому чаще применяется для побочных эффектов."
  },
  {
    "id": "js-049",
    "topic": "javascript",
    "question": "Чем filter отличается от find?",
    "answer": "filter возвращает новый массив со всеми элементами, удовлетворяющими условию, тогда как find возвращает только первый найденный элемент или undefined, поэтому filter используют для выборки, а find — для поиска одного значения."
  },
  {
    "id": "js-050",
    "topic": "javascript",
    "question": "Что делает reduce?",
    "answer": "Метод reduce последовательно обрабатывает элементы массива и сводит их к одному значению, которое может быть числом, объектом, массивом или любым другим типом, благодаря чему reduce используется для агрегации данных и сложных преобразований."
  },
  {
    "id": "js-051",
    "topic": "javascript",
    "question": "Мутируют ли массив методы push, splice, sort?",
    "answer": "Методы push, splice и sort мутируют исходный массив, так как изменяют его содержимое напрямую, поэтому при работе с иммутабельными данными их следует использовать осторожно или заменять немутирующими альтернативами."
  },
  {
    "id": "js-052",
    "topic": "javascript",
    "question": "Как проверить, что значение — массив?",
    "answer": "Проверить, что значение является массивом, надёжнее всего с помощью метода Array.isArray, так как typeof возвращает object и не позволяет отличить массив от обычного объекта."
  },
  {
    "id": "js-053",
    "topic": "javascript",
    "question": "Чем массив отличается от объекта?",
    "answer": "Массив является упорядоченной коллекцией значений с числовыми индексами и встроенными методами для работы с последовательностями, тогда как объект представляет собой неупорядоченный набор пар ключ-значение и используется для описания сущностей и структур данных."
  },
  {
    "id": "js-054",
    "topic": "javascript",
    "question": "Что такое асинхронность в JavaScript?",
    "answer": "Асинхронность в JavaScript — это способность выполнять долгие операции, такие как запросы к серверу или таймеры, без блокировки основного потока выполнения, позволяя приложению оставаться отзывчивым и обрабатывать другие задачи параллельно."
  },
  {
    "id": "js-055",
    "topic": "javascript",
    "question": "Что такое callback?",
    "answer": "Callback — это функция, которая передаётся как аргумент другой функции и вызывается позже, обычно после завершения асинхронной операции, для обработки её результата."
  },
  {
    "id": "js-056",
    "topic": "javascript",
    "question": "Какие проблемы есть у callback?",
    "answer": "Основные проблемы callback — это callback hell из-за глубокой вложенности, сложность обработки ошибок, плохая читаемость кода и трудности с масштабированием асинхронной логики."
  },
  {
    "id": "js-057",
    "topic": "javascript",
    "question": "Что такое Promise?",
    "answer": "Promise — это объект, представляющий результат асинхронной операции, который позволяет описывать последовательность асинхронных действий и обрабатывать их результаты или ошибки более читаемым и управляемым способом."
  },
  {
    "id": "js-058",
    "topic": "javascript",
    "question": "Какие состояния есть у Promise?",
    "answer": "Promise может находиться в трёх состояниях: pending — ожидание результата, fulfilled — успешное выполнение с результатом и rejected — завершение с ошибкой."
  },
  {
    "id": "js-059",
    "topic": "javascript",
    "question": "Что такое async / await?",
    "answer": "async / await — это синтаксический сахар над Promise, который позволяет писать асинхронный код в стиле синхронного, делая его более читаемым и упрощая работу с последовательными асинхронными операциями."
  },
  {
    "id": "js-060",
    "topic": "javascript",
    "question": "Чем async / await лучше Promise chaining?",
    "answer": "async / await улучшает читаемость кода, снижает уровень вложенности, упрощает обработку ошибок через try/catch и делает асинхронную логику более похожей на обычный синхронный код по сравнению с цепочками then."
  },
  {
    "id": "js-061",
    "topic": "javascript",
    "question": "Как обрабатывать ошибки в асинхронном коде?",
    "answer": "Ошибки в асинхронном коде обрабатываются с помощью catch у Promise или конструкции try/catch при использовании async / await, при этом важно учитывать как синхронные, так и асинхронные исключения."
  },
  {
    "id": "js-062",
    "topic": "javascript",
    "question": "Что такое event loop?",
    "answer": "Event loop — это механизм JavaScript, который управляет выполнением кода, очередями задач и асинхронных операций, обеспечивая выполнение синхронного кода, microtask и macrotask в определённом порядке."
  },
  {
    "id": "js-063",
    "topic": "javascript",
    "question": "Что такое microtask и macrotask?",
    "answer": "Microtask — это задачи с более высоким приоритетом, такие как обработчики Promise, тогда как macrotask включают setTimeout, setInterval и события браузера, и event loop сначала выполняет все microtask, а затем одну macrotask."
  },
  {
    "id": "js-064",
    "topic": "javascript",
    "question": "В каком порядке выполняются setTimeout, Promise и sync-код?",
    "answer": "Сначала выполняется весь синхронный код, затем выполняются все microtask из Promise, и только после этого event loop переходит к выполнению macrotask, таких как callbacks из setTimeout."
  },
  {
    "id": "js-065",
    "topic": "javascript",
    "question": "Что такое сборщик мусора?",
    "answer": "Сборщик мусора — это механизм JavaScript-движка, который автоматически освобождает память, удаляя объекты, на которые больше нет ссылок и которые недостижимы из корневых объектов, тем самым предотвращая бесконтрольный рост использования памяти."
  },
  {
    "id": "js-066",
    "topic": "javascript",
    "question": "Какие типы утечек памяти ты знаешь?",
    "answer": "К основным типам утечек памяти относятся забытые таймеры и подписки, глобальные переменные, неочищенные обработчики событий, удерживаемые DOM-узлы и замыкания, которые продолжают ссылаться на ненужные объекты."
  },
  {
    "id": "js-067",
    "topic": "javascript",
    "question": "Как замыкания могут приводить к утечкам?",
    "answer": "Замыкания могут приводить к утечкам памяти, когда функция сохраняет ссылки на переменные или объекты из внешней области видимости и продолжает удерживать их в памяти даже после того, как они логически больше не нужны."
  },
  {
    "id": "js-068",
    "topic": "javascript",
    "question": "Что такое модуль в JavaScript?",
    "answer": "Модуль в JavaScript — это изолированный файл с собственным scope, который позволяет структурировать код, явно экспортировать публичный API и импортировать зависимости, улучшая читаемость, переиспользуемость и поддержку приложения."
  },
  {
    "id": "js-069",
    "topic": "javascript",
    "question": "Чем import отличается от require?",
    "answer": "import является частью стандарта ES Modules и работает статически на этапе загрузки модуля, тогда как require относится к CommonJS, выполняется динамически во время выполнения кода и чаще используется в Node.js, при этом import поддерживает tree-shaking и более строгую структуру модулей."
  },
  {
    "id": "js-070",
    "topic": "javascript",
    "question": "Что такое named и default export?",
    "answer": "Named export позволяет экспортировать несколько сущностей из модуля по именам и импортировать их с теми же именами, тогда как default export предназначен для экспорта одного основного значения и может быть импортирован под любым именем."
  },
  {
    "id": "js-071",
    "topic": "javascript",
    "question": "Когда код выполняется при импорте модуля?",
    "answer": "Код модуля выполняется один раз в момент его первого импорта, после чего результат выполнения кэшируется, и при последующих импортах используется уже инициализированный экземпляр модуля."
  },
  {
    "id": "js-072",
    "topic": "javascript",
    "question": "Какие типы ошибок существуют в JavaScript?",
    "answer": "В JavaScript существуют синтаксические ошибки, которые возникают при разборе кода, runtime-ошибки, возникающие во время выполнения, а также логические ошибки, когда код выполняется без сбоев, но даёт неверный результат; кроме того, есть встроенные типы ошибок, такие как ReferenceError, TypeError, SyntaxError, RangeError и Error."
  },
  {
    "id": "js-073",
    "topic": "javascript",
    "question": "Чем throw отличается от return?",
    "answer": "return завершает выполнение функции и возвращает значение вызывающему коду, тогда как throw прерывает нормальный поток выполнения и генерирует исключение, которое должно быть перехвачено с помощью try / catch или приведёт к ошибке выполнения."
  },
  {
    "id": "js-074",
    "topic": "javascript",
    "question": "Как работает try / catch?",
    "answer": "try / catch оборачивает потенциально опасный код, где try содержит выполнение, которое может выбросить ошибку, а catch перехватывает это исключение и позволяет обработать его без остановки программы, при этом блок finally выполняется всегда независимо от результата."
  },
  {
    "id": "js-075",
    "topic": "javascript",
    "question": "Можно ли ловить async-ошибки через try / catch?",
    "answer": "Да, ошибки в асинхронном коде можно ловить через try / catch при использовании async / await, так как отклонённый Promise автоматически преобразуется в исключение, тогда как при работе с then необходимо использовать метод catch."
  },
  {
    "id": "js-076",
    "topic": "javascript",
    "question": "Почему 0.1 + 0.2 !== 0.3?",
    "answer": "0.1 + 0.2 !== 0.3 из-за особенностей представления чисел с плавающей точкой в формате IEEE 754, где десятичные дроби не могут быть точно представлены в бинарной системе, что приводит к накоплению погрешности при вычислениях."
  },
  {
    "id": "js-077",
    "topic": "javascript",
    "question": "Почему typeof null === \"object\"?",
    "answer": "typeof null возвращает \"object\" из-за исторической ошибки в ранней реализации JavaScript, где null был представлен как нулевой указатель, и это поведение сохранено для обратной совместимости."
  },
  {
    "id": "js-078",
    "topic": "javascript",
    "question": "Что вернёт [] == []?",
    "answer": "Выражение [] == [] вернёт false, потому что массивы являются объектами и при сравнении по ссылке сравниваются разные участки памяти, даже если их содержимое одинаково."
  },
  {
    "id": "js-079",
    "topic": "javascript",
    "question": "Что вернёт {} + {}?",
    "answer": "Выражение {} + {} в глобальном контексте обычно интерпретируется как пустой блок кода плюс пустой объект и возвращает строку \"[object Object]\", однако результат зависит от контекста выполнения и может отличаться."
  },
  {
    "id": "js-080",
    "topic": "javascript",
    "question": "Почему функции — объекты?",
    "answer": "Функции в JavaScript являются объектами, потому что они могут иметь свойства, методы и прототип, а также передаваться как значения, что позволяет использовать их как данные и реализовывать функциональные паттерны."
  },
  {
    "id": "js-081",
    "topic": "javascript",
    "question": "Что произойдёт при изменении объекта через ссылку?",
    "answer": "При изменении объекта через ссылку изменения отразятся во всех переменных, которые ссылаются на этот объект, так как объекты в JavaScript передаются и хранятся по ссылке, а не копируются."
  },
  {
    "id": "js-082",
    "topic": "javascript",
    "question": "Как сделать глубокую копию объекта?",
    "answer": "Глубокую копию объекта можно сделать с помощью structuredClone, рекурсивного копирования, библиотек вроде lodash cloneDeep или через JSON.parse(JSON.stringify()), при этом последний способ имеет ограничения и не поддерживает функции, даты и undefined."
  },
  {
    "id": "js-083",
    "topic": "javascript",
    "question": "Чем shallow copy отличается от deep copy?",
    "answer": "Shallow copy копирует только верхний уровень объекта и сохраняет ссылки на вложенные объекты, тогда как deep copy полностью копирует всю структуру данных, создавая новые экземпляры для всех вложенных объектов."
  },
  {
    "id": "js-084",
    "topic": "javascript",
    "question": "Как проверить, есть ли свойство у объекта?",
    "answer": "Наличие свойства у объекта можно проверить с помощью оператора in, метода hasOwnProperty или Object.hasOwn, при этом важно учитывать разницу между собственными и унаследованными свойствами."
  },
  {
    "id": "js-085",
    "topic": "javascript",
    "question": "Почему важно не мутировать данные?",
    "answer": "Не мутировать данные важно для предсказуемости поведения программы, упрощения отладки, корректной работы механизмов сравнения и оптимизации, а также для правильной работы библиотек и фреймворков, таких как React, которые полагаются на иммутабельность."
  },
  {
    "id": "js-086",
    "topic": "javascript",
    "question": "Что такое DOM?",
    "answer": "DOM (Document Object Model) — это объектное представление HTML-документа в виде дерева узлов, которое браузер создаёт для того, чтобы JavaScript мог читать, изменять структуру, содержимое и стили страницы динамически."
  },
  {
    "id": "js-087",
    "topic": "javascript",
    "question": "Чем DOMContentLoaded отличается от load?",
    "answer": "DOMContentLoaded срабатывает, когда HTML-документ полностью загружен и разобран, но внешние ресурсы вроде изображений и стилей могут ещё загружаться, тогда как событие load происходит только после полной загрузки всех ресурсов страницы."
  },
  {
    "id": "js-088",
    "topic": "javascript",
    "question": "Что такое bubbling и capturing?",
    "answer": "Bubbling и capturing — это фазы распространения события в DOM, где capturing идёт сверху вниз от window к целевому элементу, а bubbling — снизу вверх от целевого элемента к корню документа."
  },
  {
    "id": "js-089",
    "topic": "javascript",
    "question": "Как работает делегирование событий?",
    "answer": "Делегирование событий основано на фазе всплытия и заключается в том, что обработчик вешается на общий родительский элемент, который перехватывает события от дочерних элементов и определяет источник события через event.target."
  },
  {
    "id": "js-090",
    "topic": "javascript",
    "question": "Что такое localStorage, sessionStorage и cookies?",
    "answer": "localStorage и sessionStorage — это Web Storage API для хранения данных в браузере в виде строк, где localStorage сохраняется бессрочно, а sessionStorage очищается при закрытии вкладки, тогда как cookies — это небольшие данные, которые отправляются с каждым HTTP-запросом на сервер."
  },
  {
    "id": "js-091",
    "topic": "javascript",
    "question": "Чем localStorage отличается от cookies?",
    "answer": "localStorage хранит больше данных, не отправляется автоматически на сервер и используется только на клиенте, тогда как cookies имеют меньший размер, автоматически передаются с HTTP-запросами и часто применяются для аутентификации и серверных сценариев."
  },
  {
    "id": "html-001",
    "topic": "html",
    "question": "Что такое HTML?",
    "answer": "HTML (HyperText Markup Language) — это язык разметки, который используется для описания структуры и содержания веб-страниц, определяя элементы интерфейса, такие как заголовки, абзацы, списки, изображения и ссылки."
  },
  {
    "id": "html-002",
    "topic": "html",
    "question": "Какую роль HTML играет в веб-разработке?",
    "answer": "HTML отвечает за структуру и семантику веб-страницы, служит основой для CSS и JavaScript и позволяет браузеру понять, какие элементы присутствуют на странице и какое смысловое значение они имеют."
  },
  {
    "id": "html-003",
    "topic": "html",
    "question": "Что такое тег в HTML?",
    "answer": "HTML-тег — это специальная конструкция в угловых скобках, которая сообщает браузеру, как интерпретировать и отображать содержимое, например <p>, <div> или <img>."
  },
  {
    "id": "html-004",
    "topic": "html",
    "question": "Чем отличается тег от элемента?",
    "answer": "Тег — это синтаксическая часть HTML-разметки, а элемент включает в себя открывающий тег, содержимое и закрывающий тег, либо только один тег в случае самозакрывающихся элементов."
  },
  {
    "id": "html-005",
    "topic": "html",
    "question": "Что такое атрибуты HTML?",
    "answer": "Атрибуты HTML — это дополнительные параметры элементов, которые задают их поведение или свойства, такие как id, class, src или href, и указываются внутри открывающего тега."
  },
  {
    "id": "html-006",
    "topic": "html",
    "question": "Какие теги являются самозакрывающимися?",
    "answer": "Самозакрывающимися являются теги, которые не содержат вложенного контента, такие как img, input, br, hr, meta и link, и они не требуют закрывающего тега."
  },
  {
    "id": "html-007",
    "topic": "html",
    "question": "Что такое HTML5?",
    "answer": "HTML5 — это современная версия HTML, которая добавила новые семантические теги, встроенную поддержку мультимедиа, улучшенные формы и API для работы с графикой, хранилищами и офлайн-режимом."
  },
  {
    "id": "html-008",
    "topic": "html",
    "question": "Какие основные отличия HTML5 от HTML4?",
    "answer": "HTML5 отличается от HTML4 появлением семантических тегов, таких как header, footer и section, встроенной поддержкой audio и video, отказом от устаревших элементов и улучшенной интеграцией с JavaScript API."
  },
  {
    "id": "html-009",
    "topic": "html",
    "question": "Обязательны ли теги <html>, <head>, <body>?",
    "answer": "Формально браузер может корректно отобразить страницу и без явного указания тегов html, head и body, так как он автоматически добавит их, однако их использование считается обязательным по стандарту и хорошей практике."
  },
  {
    "id": "html-010",
    "topic": "html",
    "question": "Что такое DOCTYPE и зачем он нужен?",
    "answer": "DOCTYPE — это инструкция браузеру, которая указывает, по какому стандарту следует интерпретировать HTML-документ, и используется для включения стандартного режима отображения и предотвращения работы в режиме совместимости."
  },
  {
    "id": "html-011",
    "topic": "html",
    "question": "Что можно размещать внутри <head>?",
    "answer": "Внутри тега head размещается служебная информация о документе, такая как meta-теги, title, link для подключения стилей и иконок, script для подключения JavaScript, а также base и другие элементы, которые не отображаются напрямую на странице."
  },
  {
    "id": "html-012",
    "topic": "html",
    "question": "Для чего нужен тег <meta>?",
    "answer": "Тег meta используется для передачи браузеру и поисковым системам метаданных о странице, таких как кодировка, описание, ключевые слова, настройки viewport, автор и другие параметры, влияющие на отображение и SEO."
  },
  {
    "id": "html-013",
    "topic": "html",
    "question": "Что делает <title>?",
    "answer": "Тег title задаёт заголовок документа, который отображается во вкладке браузера, используется в истории и закладках, а также играет важную роль в поисковой оптимизации страницы."
  },
  {
    "id": "html-014",
    "topic": "html",
    "question": "В чём разница между <div> и <span>?",
    "answer": "div является блочным элементом и используется для группировки крупных блоков контента, тогда как span является строчным элементом и применяется для оборачивания небольших фрагментов текста без нарушения потока документа."
  },
  {
    "id": "html-015",
    "topic": "html",
    "question": "Чем <section> отличается от <div>?",
    "answer": "section используется для логически самостоятельных смысловых разделов страницы и имеет семантическое значение, тогда как div является нейтральным контейнером без семантики и применяется в основном для стилизации и разметки."
  },
  {
    "id": "html-016",
    "topic": "html",
    "question": "Когда использовать <article>?",
    "answer": "Тег article используется для самостоятельного, независимого контента, такого как статья, новость, пост или карточка, который может быть переиспользован или распространён отдельно от остальной страницы."
  },
  {
    "id": "html-017",
    "topic": "html",
    "question": "Для чего нужен <nav>?",
    "answer": "Тег nav предназначен для группировки основных навигационных ссылок страницы или сайта и помогает браузерам, поисковым системам и вспомогательным технологиям понимать структуру навигации."
  },
  {
    "id": "html-018",
    "topic": "html",
    "question": "Чем <header> отличается от <footer>?",
    "answer": "header используется для размещения вводного контента, заголовков и навигации раздела или страницы, тогда как footer содержит завершающую информацию, такую как авторство, копирайт, дополнительные ссылки и метаданные."
  },
  {
    "id": "html-019",
    "topic": "html",
    "question": "Что такое семантическая вёрстка?",
    "answer": "Семантическая вёрстка — это подход к созданию HTML-разметки, при котором используются теги с осмысленным значением, отражающим роль и структуру контента, а не только его внешний вид."
  },
  {
    "id": "html-020",
    "topic": "html",
    "question": "Зачем нужна семантика в HTML?",
    "answer": "Семантика в HTML улучшает доступность для скринридеров, облегчает индексацию страниц поисковыми системами, повышает читаемость кода и упрощает поддержку и развитие проекта."
  },
  {
    "id": "html-021",
    "topic": "html",
    "question": "Какие семантические теги ты знаешь?",
    "answer": "К семантическим тегам относятся header, footer, main, section, article, nav, aside, figure, figcaption, time, address и другие элементы, которые описывают смысловое назначение контента."
  },
  {
    "id": "html-022",
    "topic": "html",
    "question": "Почему <b> и <strong> — не одно и то же?",
    "answer": "Тег b используется только для визуального выделения текста без смысловой нагрузки, тогда как strong обозначает логическое или смысловое усиление важности контента, что учитывается поисковыми системами и вспомогательными технологиями."
  },
  {
    "id": "html-023",
    "topic": "html",
    "question": "Чем <i> отличается от <em>?",
    "answer": "Тег i применяется для визуального выделения текста, например терминов или иностранных слов, тогда как em обозначает смысловое ударение и влияет на восприятие текста скринридерами и поисковыми системами."
  },
  {
    "id": "html-024",
    "topic": "html",
    "question": "Что такое форма в HTML?",
    "answer": "Форма в HTML — это элемент интерфейса, предназначенный для сбора данных от пользователя и их отправки на сервер или в обработчик с помощью элементов ввода, таких как input, textarea, select и кнопки."
  },
  {
    "id": "html-025",
    "topic": "html",
    "question": "Какие основные атрибуты есть у тега <form>?",
    "answer": "Основные атрибуты тега form включают action для указания адреса отправки данных, method для выбора способа отправки (GET или POST), enctype для формата данных и target для определения контекста открытия результата."
  },
  {
    "id": "html-026",
    "topic": "html",
    "question": "В чём разница между GET и POST?",
    "answer": "GET передаёт данные через URL и используется для получения данных без изменения состояния сервера, тогда как POST отправляет данные в теле запроса, подходит для передачи чувствительной информации и не имеет ограничений по длине данных."
  },
  {
    "id": "html-027",
    "topic": "html",
    "question": "Что такое name у input и зачем он нужен?",
    "answer": "Атрибут name у input определяет имя поля формы, по которому его значение идентифицируется при отправке данных на сервер, и без него значение поля не будет включено в отправляемый запрос."
  },
  {
    "id": "html-028",
    "topic": "html",
    "question": "Какие типы input ты знаешь?",
    "answer": "Среди распространённых типов input есть text, password, email, number, checkbox, radio, file, date, range, color, hidden, submit и button, каждый из которых предназначен для ввода определённого типа данных."
  },
  {
    "id": "html-029",
    "topic": "html",
    "question": "Что такое label и зачем он нужен?",
    "answer": "Тег label связывает текстовое описание с элементом формы и улучшает доступность, позволяя фокусировать input по клику на текст и обеспечивая корректную работу со скринридерами."
  },
  {
    "id": "html-030",
    "topic": "html",
    "question": "Чем disabled отличается от readonly?",
    "answer": "disabled полностью отключает элемент формы, делает его недоступным для фокуса и исключает из отправки данных, тогда как readonly запрещает изменение значения, но позволяет фокусироваться и отправлять значение формы."
  },
  {
    "id": "html-031",
    "topic": "html",
    "question": "Как подключить изображение в HTML?",
    "answer": "Изображение в HTML подключается с помощью тега img и атрибута src, в котором указывается путь к файлу изображения, при этом также рекомендуется указывать alt для доступности и корректного отображения при ошибке загрузки."
  },
  {
    "id": "html-032",
    "topic": "html",
    "question": "В чём разница между <img> и <picture>?",
    "answer": "img используется для отображения одного изображения, тогда как picture позволяет задавать несколько источников изображений с разными условиями через source, что применяется для адаптивных изображений под разные экраны и форматы."
  },
  {
    "id": "html-033",
    "topic": "html",
    "question": "Для чего нужен атрибут alt?",
    "answer": "Атрибут alt содержит альтернативный текст для изображения, который используется скринридерами, отображается при ошибке загрузки изображения и играет важную роль в доступности и SEO."
  },
  {
    "id": "html-034",
    "topic": "html",
    "question": "Как работает тег <video>?",
    "answer": "Тег video используется для встраивания видео на страницу и поддерживает атрибуты управления воспроизведением, такие как controls, autoplay, loop и muted, а также позволяет указывать несколько источников видео через вложенные теги source."
  },
  {
    "id": "html-035",
    "topic": "html",
    "question": "Что такое iframe и когда его используют?",
    "answer": "iframe — это элемент HTML, который позволяет встраивать другой HTML-документ внутри текущей страницы и используется для интеграции внешнего контента, такого как карты, видео, виджеты или сторонние приложения."
  },
  {
    "id": "html-036",
    "topic": "html",
    "question": "Почему важно использовать заголовки <h1>–<h6> правильно?",
    "answer": "Правильное использование заголовков <h1>–<h6> важно для логической структуры документа, так как они формируют иерархию контента, улучшают восприятие страницы пользователями, помогают скринридерам корректно навигировать по странице и положительно влияют на SEO."
  },
  {
    "id": "html-037",
    "topic": "html",
    "question": "Сколько <h1> может быть на странице?",
    "answer": "Современные стандарты HTML5 допускают использование нескольких <h1> на странице внутри разных семантических секций, однако на практике чаще рекомендуется использовать один основной <h1> для главного заголовка страницы в целях SEO и понятности структуры."
  },
  {
    "id": "html-038",
    "topic": "html",
    "question": "Что такое accessibility (a11y)?",
    "answer": "Accessibility или a11y — это практика создания веб-интерфейсов, доступных для людей с ограниченными возможностями, включая пользователей скринридеров, клавиатурной навигации и вспомогательных технологий."
  },
  {
    "id": "html-039",
    "topic": "html",
    "question": "Как HTML влияет на SEO?",
    "answer": "HTML влияет на SEO через семантическую разметку, правильное использование заголовков, атрибутов alt, meta-тегов, структуры документа и доступности контента, что помогает поисковым системам лучше понимать и индексировать страницу."
  },
  {
    "id": "html-040",
    "topic": "html",
    "question": "Какие HTML-атрибуты улучшают доступность?",
    "answer": "Доступность улучшают атрибуты alt для изображений, label и for для форм, aria-* для описания ролей и состояний, role для определения назначения элементов, tabindex для управления фокусом и lang для указания языка документа."
  },
  {
    "id": "css-001",
    "topic": "css",
    "question": "Что такое CSS?",
    "answer": "CSS (Cascading Style Sheets) — это язык стилей, который используется для описания внешнего вида HTML-документов, включая цвета, шрифты, размеры, позиционирование и адаптивность, отделяя представление интерфейса от структуры и логики."
  },
  {
    "id": "css-002",
    "topic": "css",
    "question": "Какие способы подключения CSS ты знаешь?",
    "answer": "CSS можно подключить инлайново через атрибут style, встроенно с помощью тега style в head документа или внешним файлом через тег link, при этом внешний способ считается наиболее правильным и масштабируемым."
  },
  {
    "id": "css-003",
    "topic": "css",
    "question": "В чём разница между class и id?",
    "answer": "class предназначен для многократного использования и может применяться к нескольким элементам, тогда как id должен быть уникальным на странице и используется для идентификации одного конкретного элемента."
  },
  {
    "id": "css-004",
    "topic": "css",
    "question": "Что такое каскад в CSS?",
    "answer": "Каскад в CSS — это механизм, по которому браузер определяет, какие стили применять к элементу при наличии нескольких правил, учитывая источник стилей, специфичность селекторов и порядок их объявления."
  },
  {
    "id": "css-005",
    "topic": "css",
    "question": "Что такое специфичность (specificity)?",
    "answer": "Специфичность — это система приоритетов CSS-селекторов, которая определяет, какое правило будет применено к элементу, если несколько селекторов нацелены на один и тот же элемент."
  },
  {
    "id": "css-006",
    "topic": "css",
    "question": "Как рассчитывается специфичность селекторов?",
    "answer": "Специфичность рассчитывается по четырёхуровневой системе, где учитываются inline-стили, количество id-селекторов, class и атрибутов, а также селекторов по тегу, при этом более высокий уровень имеет больший приоритет."
  },
  {
    "id": "css-007",
    "topic": "css",
    "question": "Что такое !important и когда его можно использовать?",
    "answer": "Ключевое слово !important принудительно повышает приоритет CSS-правила над другими, независимо от специфичности, и его следует использовать только в крайних случаях, например при переопределении сторонних стилей."
  },
  {
    "id": "css-008",
    "topic": "css",
    "question": "В каком порядке применяются CSS-стили?",
    "answer": "CSS-стили применяются в следующем порядке: сначала стили браузера по умолчанию, затем внешние и встроенные стили, после них inline-стили, а при конфликте учитываются !important, специфичность селектора и порядок объявления в коде."
  },
  {
    "id": "css-009",
    "topic": "css",
    "question": "Какие типы селекторов ты знаешь?",
    "answer": "В CSS существуют селекторы по тегу, классу, id, атрибутам, псевдоклассы, псевдоэлементы, универсальный селектор, групповые селекторы и комбинированные селекторы для более точного выбора элементов."
  },
  {
    "id": "css-010",
    "topic": "css",
    "question": "Чем отличается div p от div > p?",
    "answer": "Селектор div p выбирает все элементы p, вложенные в div на любом уровне, тогда как div > p выбирает только те p, которые являются непосредственными дочерними элементами div."
  },
  {
    "id": "css-011",
    "topic": "css",
    "question": "Что делают селекторы + и ~?",
    "answer": "Селектор + выбирает соседний элемент, который идёт сразу после указанного элемента, а селектор ~ выбирает все последующие соседние элементы на одном уровне вложенности."
  },
  {
    "id": "css-012",
    "topic": "css",
    "question": "Что такое атрибутные селекторы?",
    "answer": "Атрибутные селекторы позволяют выбирать элементы на основе наличия атрибута или его значения, например input[type=\"text\"] или a[href^=\"https\"]."
  },
  {
    "id": "css-013",
    "topic": "css",
    "question": "Что такое псевдоклассы?",
    "answer": "Псевдоклассы описывают особое состояние элемента, например при наведении, фокусе или выборе, и используются для стилизации элементов в зависимости от их состояния, а не структуры документа."
  },
  {
    "id": "css-014",
    "topic": "css",
    "question": "Что такое псевдоэлементы?",
    "answer": "Псевдоэлементы позволяют стилизовать определённые части элемента или создавать виртуальные элементы, такие как первая строка, первая буква или контент до и после элемента."
  },
  {
    "id": "css-015",
    "topic": "css",
    "question": "В чём разница между :hover и ::before?",
    "answer": "hover является псевдоклассом и применяется к элементу в момент наведения курсора, тогда как ::before является псевдоэлементом и используется для добавления декоративного контента перед содержимым элемента."
  },
  {
    "id": "css-016",
    "topic": "css",
    "question": "Что такое box model?",
    "answer": "Box model — это модель расчёта размеров элемента в CSS, которая описывает, как формируются его ширина и высота из содержимого, внутренних отступов, рамки и внешних отступов."
  },
  {
    "id": "css-017",
    "topic": "css",
    "question": "Какие свойства входят в box model?",
    "answer": "В box model входят content (содержимое), padding (внутренние отступы), border (рамка) и margin (внешние отступы), которые вместе определяют занимаемое элементом пространство."
  },
  {
    "id": "css-018",
    "topic": "css",
    "question": "Чем отличается box-sizing: content-box от border-box?",
    "answer": "При box-sizing: content-box ширина и высота задаются только для содержимого и не включают padding и border, тогда как при border-box в заданные размеры входят и padding, и border, что упрощает контроль размеров элементов."
  },
  {
    "id": "css-019",
    "topic": "css",
    "question": "Как работает margin-collapse?",
    "answer": "Margin-collapse — это поведение CSS, при котором вертикальные внешние отступы соседних блочных элементов схлопываются в один, равный наибольшему значению margin, вместо суммирования."
  },
  {
    "id": "css-020",
    "topic": "css",
    "question": "Чем margin отличается от padding?",
    "answer": "Margin создаёт внешнее пространство вокруг элемента и влияет на расстояние между соседними элементами, тогда как padding создаёт внутренний отступ между содержимым элемента и его рамкой и влияет на кликабельную область."
  },{
  "id": "css-016",
  "topic": "css",
  "question": "Что такое box model?",
  "answer": "Box model — это модель расчёта размеров элемента в CSS, которая описывает, как формируются его ширина и высота из содержимого, внутренних отступов, рамки и внешних отступов."
},
  {
    "id": "css-017",
    "topic": "css",
    "question": "Какие свойства входят в box model?",
    "answer": "В box model входят content (содержимое), padding (внутренние отступы), border (рамка) и margin (внешние отступы), которые вместе определяют занимаемое элементом пространство."
  },
  {
    "id": "css-018",
    "topic": "css",
    "question": "Чем отличается box-sizing: content-box от border-box?",
    "answer": "При box-sizing: content-box ширина и высота задаются только для содержимого и не включают padding и border, тогда как при border-box в заданные размеры входят и padding, и border, что упрощает контроль размеров элементов."
  },
  {
    "id": "css-019",
    "topic": "css",
    "question": "Как работает margin-collapse?",
    "answer": "Margin-collapse — это поведение CSS, при котором вертикальные внешние отступы соседних блочных элементов схлопываются в один, равный наибольшему значению margin, вместо суммирования."
  },
  {
    "id": "css-020",
    "topic": "css",
    "question": "Чем margin отличается от padding?",
    "answer": "Margin создаёт внешнее пространство вокруг элемента и влияет на расстояние между соседними элементами, тогда как padding создаёт внутренний отступ между содержимым элемента и его рамкой и влияет на кликабельную область."
  },
  {
    "id": "css-021",
    "topic": "css",
    "question": "Какие способы вёрстки ты знаешь?",
    "answer": "Основные способы вёрстки в CSS включают блочную и строчную вёрстку, позиционирование через position, табличную вёрстку, float-вёрстку, а также современные подходы с использованием Flexbox и Grid для построения адаптивных макетов."
  },
  {
    "id": "css-022",
    "topic": "css",
    "question": "Что такое display?",
    "answer": "Свойство display определяет тип отображения элемента и то, как он участвует в потоке документа, влияя на его размеры, поведение и взаимодействие с другими элементами на странице."
  },
  {
    "id": "css-023",
    "topic": "css",
    "question": "В чём разница между block, inline, inline-block?",
    "answer": "block-элементы занимают всю доступную ширину и начинаются с новой строки, inline-элементы не принимают размеры и располагаются в строке, а inline-block сочетают поведение строчных элементов с возможностью задавать ширину и высоту."
  },
  {
    "id": "css-024",
    "topic": "css",
    "question": "Как работает position?",
    "answer": "Свойство position определяет способ позиционирования элемента в документе и может принимать значения static, relative, absolute, fixed и sticky, влияя на его положение относительно потока, родителя или окна браузера."
  },
  {
    "id": "css-025",
    "topic": "css",
    "question": "Чем absolute отличается от relative?",
    "answer": "relative позиционирует элемент относительно его исходного положения в потоке документа, тогда как absolute вырывает элемент из потока и позиционирует его относительно ближайшего позиционированного родителя или окна браузера."
  },
  {
    "id": "css-026",
    "topic": "css",
    "question": "Что такое z-index и когда он работает?",
    "answer": "z-index определяет порядок наложения элементов по оси Z и работает только для позиционированных элементов или элементов, создающих stacking context, таких как элементы с position и заданным z-index."
  },
  {
    "id": "css-027",
    "topic": "css",
    "question": "В чём разница между Flexbox и Grid?",
    "answer": "Flexbox предназначен для одномерных макетов и работает либо по строке, либо по колонке, тогда как Grid используется для двумерных макетов и позволяет управлять как строками, так и колонками одновременно."
  },
  {
    "id": "css-028",
    "topic": "css",
    "question": "Когда лучше использовать Flexbox, а когда Grid?",
    "answer": "Flexbox лучше использовать для выравнивания элементов и построения простых одномерных интерфейсов, таких как панели и списки, тогда как Grid подходит для сложных макетов страниц и сеток с управлением строками и колонками."
  },
  {
    "id": "css-029",
    "topic": "css",
    "question": "Что такое float и используется ли он сейчас?",
    "answer": "float — это устаревший способ обтекания элементов, который раньше активно применялся для вёрстки макетов, но сейчас используется в основном для обтекания текста вокруг изображений и заменён Flexbox и Grid."
  },
  {
    "id": "css-030",
    "topic": "css",
    "question": "Что такое flex-контейнер?",
    "answer": "Flex-контейнер — это элемент, у которого задано display: flex или inline-flex, и который управляет расположением своих дочерних элементов по основной и поперечной осям с помощью модели Flexbox."
  },
  {
    "id": "css-031",
    "topic": "css",
    "question": "Какие основные свойства Flexbox ты знаешь?",
    "answer": "К основным свойствам Flexbox относятся display, flex-direction, justify-content, align-items, align-content, flex-wrap, gap для контейнера и flex-grow, flex-shrink, flex-basis, align-self для flex-элементов."
  },
  {
    "id": "css-032",
    "topic": "css",
    "question": "Чем justify-content отличается от align-items?",
    "answer": "justify-content управляет выравниванием элементов вдоль основной оси flex-контейнера, тогда как align-items отвечает за выравнивание элементов вдоль поперечной оси."
  },
  {
    "id": "css-033",
    "topic": "css",
    "question": "Что такое flex-grow, flex-shrink, flex-basis?",
    "answer": "flex-grow определяет, может ли элемент расти и занимать свободное пространство, flex-shrink — может ли он сжиматься при нехватке места, а flex-basis задаёт базовый размер элемента до распределения пространства."
  },
  {
    "id": "css-034",
    "topic": "css",
    "question": "Что такое responsive design?",
    "answer": "Responsive design — это подход к вёрстке, при котором интерфейс автоматически адаптируется под разные размеры экранов и устройства с помощью гибких сеток, медиа-запросов и относительных единиц измерения."
  },
  {
    "id": "css-035",
    "topic": "css",
    "question": "Что такое media queries?",
    "answer": "Media queries — это механизм CSS, позволяющий применять стили в зависимости от характеристик устройства или окна браузера, таких как ширина экрана, ориентация, плотность пикселей и тип носителя."
  },
  {
    "id": "css-036",
    "topic": "css",
    "question": "Mobile First — что это?",
    "answer": "Mobile First — это стратегия разработки, при которой стили сначала пишутся для мобильных устройств, а затем расширяются для планшетов и десктопов с помощью media queries, что улучшает производительность и удобство использования."
  },
  {
    "id": "css-037",
    "topic": "css",
    "question": "В чём разница между px, %, em, rem, vh, vw?",
    "answer": "px — абсолютная единица измерения, % зависит от родительского элемента, em зависит от размера шрифта текущего элемента, rem — от размера шрифта корня документа, а vh и vw зависят от размеров области просмотра."
  },
  {
    "id": "css-038",
    "topic": "css",
    "question": "Что такое резиновая и адаптивная вёрстка?",
    "answer": "Резиновая вёрстка использует относительные единицы и растягивается вместе с окном браузера, тогда как адаптивная вёрстка применяет фиксированные точки перелома и разные стили под конкретные размеры экранов."
  },
  {
    "id": "css-039",
    "topic": "css",
    "question": "Что влияет на производительность CSS?",
    "answer": "На производительность CSS влияют сложные и вложенные селекторы, частые перерасчёты layout и repaint, использование тяжёлых анимаций, отсутствие оптимизации стилей и чрезмерное применение !important."
  },
  {
    "id": "css-040",
    "topic": "css",
    "question": "Какие ошибки чаще всего допускают в CSS?",
    "answer": "Частые ошибки в CSS включают избыточную специфичность селекторов, злоупотребление !important, отсутствие единой архитектуры стилей, неправильное использование единиц измерения и игнорирование адаптивности и доступности."
  },
  {
    "id": "git-001",
    "topic": "git",
    "question": "Что такое Git?",
    "answer": "Git — это распределённая система контроля версий, которая позволяет отслеживать изменения в коде, работать с историей проекта, создавать ветки и эффективно взаимодействовать нескольким разработчикам."
  },
  {
    "id": "git-002",
    "topic": "git",
    "question": "Чем Git отличается от GitHub?",
    "answer": "Git — это инструмент для управления версиями кода, который работает локально, а GitHub — это облачная платформа для хранения Git-репозиториев и совместной работы, предоставляющая дополнительные функции вроде pull request и code review."
  },
  {
    "id": "git-003",
    "topic": "git",
    "question": "Что такое репозиторий?",
    "answer": "Репозиторий — это хранилище проекта, содержащее файлы, историю изменений и метаданные Git, которое может находиться как локально на компьютере разработчика, так и удалённо на сервере."
  },
  {
    "id": "git-004",
    "topic": "git",
    "question": "Что такое commit?",
    "answer": "Commit — это зафиксированное состояние проекта в Git, которое сохраняет изменения файлов, сообщение коммита и информацию об авторе, позволяя возвращаться к этому состоянию в будущем."
  },
  {
    "id": "git-005",
    "topic": "git",
    "question": "Что такое hash коммита?",
    "answer": "Hash коммита — это уникальный идентификатор, вычисляемый Git на основе содержимого коммита, который используется для однозначного определения конкретной версии изменений в истории проекта."
  },
  {
    "id": "git-006",
    "topic": "git",
    "question": "Что такое рабочая директория, staging area и repository?",
    "answer": "Рабочая директория содержит текущие файлы проекта, staging area используется для подготовки изменений к коммиту, а repository хранит зафиксированную историю коммитов и состояний проекта."
  },
  {
    "id": "git-007",
    "topic": "git",
    "question": "Что делает команда git status?",
    "answer": "Команда git status показывает текущее состояние рабочей директории и staging area, отображая изменённые, добавленные, неотслеживаемые файлы и подсказки по дальнейшим действиям."
  },
  {
    "id": "git-008",
    "topic": "git",
    "question": "Что делает команда git add?",
    "answer": "Команда git add добавляет изменения файлов из рабочей директории в staging area, подготавливая их к последующему коммиту."
  },
  {
    "id": "git-009",
    "topic": "git",
    "question": "Что делает команда git commit?",
    "answer": "Команда git commit сохраняет изменения из staging area в репозиторий в виде нового коммита с сообщением, фиксируя текущее состояние проекта в истории."
  },
  {
    "id": "git-010",
    "topic": "git",
    "question": "В чём разница между git pull и git fetch?",
    "answer": "git fetch загружает изменения из удалённого репозитория без их применения к текущей ветке, тогда как git pull дополнительно выполняет слияние или ребейз, сразу обновляя локальную ветку."
  },
  {
    "id": "git-011",
    "topic": "git",
    "question": "Что такое ветка в Git?",
    "answer": "Ветка в Git — это указатель на определённый коммит в истории проекта, который позволяет изолированно разрабатывать новые фичи или исправления, не затрагивая основную ветку."
  },
  {
    "id": "git-012",
    "topic": "git",
    "question": "Зачем нужны ветки?",
    "answer": "Ветки нужны для параллельной разработки, изоляции экспериментов, удобной работы в команде и безопасного внесения изменений без риска сломать стабильную версию проекта."
  },
  {
    "id": "git-013",
    "topic": "git",
    "question": "Как создать новую ветку?",
    "answer": "Новую ветку можно создать с помощью команды git branch <name> или сразу создать и переключиться на неё с помощью git checkout -b <name> либо git switch -c <name>."
  },
  {
    "id": "git-014",
    "topic": "git",
    "question": "Как переключиться на ветку?",
    "answer": "Переключиться на существующую ветку можно с помощью команды git checkout <name> или более современного варианта git switch <name>, которые изменяют рабочее состояние проекта."
  },
  {
    "id": "git-015",
    "topic": "git",
    "question": "Что такое HEAD?",
    "answer": "HEAD — это специальный указатель в Git, который указывает на текущий коммит или ветку, с которой в данный момент работает разработчик."
  },
  {
    "id": "git-016",
    "topic": "git",
    "question": "Что такое merge?",
    "answer": "Merge — это операция объединения изменений из одной ветки в другую, при которой Git создаёт новый коммит слияния или выполняет fast-forward, если это возможно."
  },
  {
    "id": "git-017",
    "topic": "git",
    "question": "Чем merge отличается от rebase?",
    "answer": "merge сохраняет историю ветвления и создаёт коммит слияния, тогда как rebase переписывает историю, последовательно перенося коммиты одной ветки поверх другой, делая историю более линейной."
  },
  {
    "id": "git-018",
    "topic": "git",
    "question": "Что такое fast-forward merge?",
    "answer": "Fast-forward merge — это тип слияния, при котором Git просто перемещает указатель ветки вперёд без создания нового коммита, если целевая ветка не имеет собственных новых коммитов."
  },
  {
    "id": "git-019",
    "topic": "git",
    "question": "Что такое конфликт слияния?",
    "answer": "Конфликт слияния возникает, когда Git не может автоматически объединить изменения из разных веток, потому что одни и те же строки кода были изменены по-разному."
  },
  {
    "id": "git-020",
    "topic": "git",
    "question": "Как решать merge-конфликты?",
    "answer": "Для решения merge-конфликтов необходимо вручную отредактировать конфликтные файлы, выбрать или объединить нужные изменения, удалить конфликтные маркеры, после чего добавить файлы в staging area и завершить merge-коммит."
  },
  {
    "id": "git-021",
    "topic": "git",
    "question": "Как посмотреть историю коммитов?",
    "answer": "Историю коммитов можно посмотреть с помощью команды git log, которая показывает список коммитов с хешами, авторами и сообщениями, а для упрощённого или наглядного вида можно использовать флаги вроде --oneline, --graph и --decorate."
  },
  {
    "id": "git-022",
    "topic": "git",
    "question": "Чем git reset отличается от git revert?",
    "answer": "git reset изменяет историю коммитов и перемещает указатель ветки назад, что может быть опасно для общих веток, тогда как git revert создаёт новый коммит, который отменяет изменения предыдущего, сохраняя историю безопасной."
  },
  {
    "id": "git-023",
    "topic": "git",
    "question": "Какие режимы есть у git reset?",
    "answer": "git reset имеет режимы --soft, --mixed и --hard, где soft откатывает только HEAD, mixed откатывает HEAD и staging area, а hard полностью откатывает HEAD, staging area и рабочую директорию."
  },
  {
    "id": "git-024",
    "topic": "git",
    "question": "Что делает git checkout?",
    "answer": "git checkout используется для переключения между ветками, коммитами или для восстановления файлов из истории, изменяя состояние рабочей директории и указатель HEAD."
  },
  {
    "id": "git-025",
    "topic": "git",
    "question": "Что такое detached HEAD?",
    "answer": "Detached HEAD — это состояние, при котором HEAD указывает напрямую на коммит, а не на ветку, из-за чего новые коммиты не будут принадлежать ни одной ветке, если её не создать явно."
  },
  {
    "id": "git-026",
    "topic": "git",
    "question": "Как отменить последний коммит?",
    "answer": "Последний коммит можно отменить с помощью git reset --soft HEAD~1 для сохранения изменений в staging area, git reset --mixed HEAD~1 для возврата изменений в рабочую директорию или git revert HEAD для безопасной отмены через новый коммит."
  },
  {
    "id": "git-027",
    "topic": "git",
    "question": "Как откатить изменения в файле?",
    "answer": "Изменения в файле можно откатить с помощью git checkout -- <file> или git restore <file>, что вернёт файл к состоянию последнего коммита или staging area."
  },
  {
    "id": "git-028",
    "topic": "git",
    "question": "Что такое git stash?",
    "answer": "git stash — это команда, которая временно сохраняет незакоммиченные изменения в специальное хранилище и очищает рабочую директорию, позволяя переключаться между задачами без коммита."
  },
  {
    "id": "git-029",
    "topic": "git",
    "question": "Когда стоит использовать git stash?",
    "answer": "git stash стоит использовать, когда нужно временно отложить текущие изменения, например перед переключением ветки или обновлением кода, не создавая промежуточный коммит."
  },
  {
    "id": "git-030",
    "topic": "git",
    "question": "Что такое origin?",
    "answer": "origin — это стандартное имя удалённого репозитория по умолчанию в Git, которое указывает на основной удалённый источник, откуда был склонирован репозиторий или куда чаще всего отправляются изменения."
  },
  {
    "id": "git-031",
    "topic": "git",
    "question": "Как добавить удалённый репозиторий?",
    "answer": "Удалённый репозиторий добавляется с помощью команды git remote add <name> <url>, после чего Git сможет взаимодействовать с этим источником для получения и отправки изменений."
  },
  {
    "id": "git-032",
    "topic": "git",
    "question": "Что такое git clone?",
    "answer": "git clone — это команда, которая создаёт локальную копию удалённого репозитория вместе со всей историей коммитов, ветками и настройками, позволяя сразу начать работу с проектом."
  },
  {
    "id": "git-033",
    "topic": "git",
    "question": "Что такое git push?",
    "answer": "git push отправляет локальные коммиты в удалённый репозиторий и обновляет соответствующую ветку на сервере, делая изменения доступными другим участникам проекта."
  },
  {
    "id": "git-034",
    "topic": "git",
    "question": "Что такое pull request?",
    "answer": "Pull request — это запрос на слияние изменений из одной ветки или репозитория в другой, который используется для code review, обсуждения и проверки изменений перед их добавлением в основную ветку."
  },
  {
    "id": "git-035",
    "topic": "git",
    "question": "Чем pull request отличается от merge request?",
    "answer": "Pull request и merge request выполняют одну и ту же задачу — запрос на слияние изменений, но pull request используется в GitHub и Bitbucket, а merge request является термином GitLab."
  },
  {
    "id": "git-036",
    "topic": "git",
    "question": "Что такое fork?",
    "answer": "Fork — это копия чужого репозитория в вашем аккаунте, которая позволяет вносить изменения независимо от оригинального проекта и затем предлагать их обратно через pull request."
  },
  {
    "id": "git-037",
    "topic": "git",
    "question": "Что такое cherry-pick?",
    "answer": "cherry-pick — это операция Git, которая позволяет применить один или несколько конкретных коммитов из одной ветки в другую без полного слияния веток, что удобно для точечного переноса исправлений или фич."
  },
  {
    "id": "git-038",
    "topic": "git",
    "question": "Что такое squash?",
    "answer": "Squash — это процесс объединения нескольких коммитов в один, который часто используется перед merge для упрощения истории проекта и удаления промежуточных или технических коммитов."
  },
  {
    "id": "git-039",
    "topic": "git",
    "question": "Как переписать историю коммитов?",
    "answer": "Историю коммитов можно переписать с помощью интерактивного rebase (git rebase -i), reset или amend, при этом важно помнить, что изменение опубликованной истории может привести к проблемам у других участников команды."
  },
  {
    "id": "git-040",
    "topic": "git",
    "question": "Какие ошибки чаще всего допускают при работе с Git?",
    "answer": "Частые ошибки при работе с Git включают коммиты в main или master напрямую, переписывание опубликованной истории, редкие коммиты с большим количеством изменений, отсутствие осмысленных сообщений коммитов и игнорирование pull перед push."
  },
  {
    "id": "next-001",
    "topic": "nextjs",
    "question": "Что такое Next.js?",
    "answer": "Next.js — это React-фреймворк для production-приложений, который предоставляет готовую инфраструктуру для серверного рендеринга, статической генерации, маршрутизации, оптимизации и работы с бэкендом поверх React."
  },
  {
    "id": "next-002",
    "topic": "nextjs",
    "question": "Чем Next.js отличается от обычного React-приложения?",
    "answer": "В отличие от обычного React-приложения, которое рендерится только на клиенте, Next.js поддерживает SSR и SSG, имеет встроенный роутинг, оптимизацию производительности и возможность выполнять код на сервере."
  },
  {
    "id": "next-003",
    "topic": "nextjs",
    "question": "Какие основные возможности Next.js ты знаешь?",
    "answer": "Основные возможности Next.js включают серверный и статический рендеринг, file-based routing, API routes, оптимизацию изображений и шрифтов, code splitting, middleware и поддержку Edge Runtime."
  },
  {
    "id": "next-004",
    "topic": "nextjs",
    "question": "Зачем использовать Next.js вместо CRA / Vite?",
    "answer": "Next.js используют вместо CRA или Vite, когда требуется SEO, быстрый первый рендер, серверная логика, удобная маршрутизация и готовые production-инструменты без ручной настройки инфраструктуры."
  },
  {
    "id": "next-005",
    "topic": "nextjs",
    "question": "Что такое file-based routing?",
    "answer": "File-based routing — это механизм маршрутизации, при котором структура URL автоматически формируется на основе структуры файлов и папок в директории pages или app без необходимости ручного описания роутов."
  },
  {
    "id": "next-006",
    "topic": "nextjs",
    "question": "Как работает роутинг в Next.js?",
    "answer": "Роутинг в Next.js основан на файловой системе, где каждый файл или папка в директории pages или app автоматически становится маршрутом, а навигация между страницами выполняется без перезагрузки с помощью компонента Link и встроенного роутера."
  },
  {
    "id": "next-007",
    "topic": "nextjs",
    "question": "В чём разница между pages router и app router?",
    "answer": "Pages router использует директорию pages и классическую модель с getServerSideProps и getStaticProps, тогда как app router основан на директории app, поддерживает Server Components, layouts, streaming и более гибкую модель data fetching."
  },
  {
    "id": "next-008",
    "topic": "nextjs",
    "question": "Что такое dynamic routes?",
    "answer": "Dynamic routes — это динамические маршруты, которые создаются с помощью файлов с квадратными скобками, например [id].js или [slug], и позволяют обрабатывать URL с переменными параметрами."
  },
  {
    "id": "next-009",
    "topic": "nextjs",
    "question": "Как создать вложенные роуты?",
    "answer": "Вложенные роуты создаются путём вложенности папок в pages или app, где каждая папка формирует часть URL, а в app router дополнительно используются layout.tsx для общего интерфейса вложенных маршрутов."
  },
  {
    "id": "next-010",
    "topic": "nextjs",
    "question": "Как работает catch-all routing?",
    "answer": "Catch-all routing позволяет обрабатывать произвольное количество сегментов URL с помощью файлов вида [...slug] или [[...slug]], где параметры собираются в массив и используются для динамической логики маршрута."
  },
  {
    "id": "next-011",
    "topic": "nextjs",
    "question": "Какие типы рендеринга есть в Next.js?",
    "answer": "В Next.js существуют CSR (Client-Side Rendering), SSR (Server-Side Rendering), SSG (Static Site Generation) и ISR (Incremental Static Regeneration), которые позволяют выбирать оптимальный способ генерации страниц в зависимости от требований к производительности, SEO и актуальности данных."
  },
  {
    "id": "next-012",
    "topic": "nextjs",
    "question": "Что такое SSR?",
    "answer": "SSR — это серверный рендеринг, при котором HTML страницы генерируется на сервере при каждом запросе пользователя, что улучшает SEO и время первого отображения, но увеличивает нагрузку на сервер."
  },
  {
    "id": "next-013",
    "topic": "nextjs",
    "question": "Что такое SSG?",
    "answer": "SSG — это статическая генерация страниц во время сборки проекта, при которой HTML создаётся заранее и отдаётся пользователю как статический файл, обеспечивая высокую скорость загрузки и низкую нагрузку на сервер."
  },
  {
    "id": "next-014",
    "topic": "nextjs",
    "question": "Что такое ISR?",
    "answer": "ISR — это гибридный подход, позволяющий пересобирать статические страницы на сервере через заданный интервал времени без полной пересборки проекта, сочетая преимущества SSG и актуальность данных."
  },
  {
    "id": "next-015",
    "topic": "nextjs",
    "question": "В чём разница между CSR, SSR и SSG?",
    "answer": "CSR рендерит страницу полностью в браузере после загрузки JavaScript, SSR генерирует HTML на сервере при каждом запросе, а SSG создаёт HTML заранее на этапе сборки, что влияет на производительность, SEO и нагрузку на сервер."
  },
  {
    "id": "next-016",
    "topic": "nextjs",
    "question": "Когда и что лучше использовать?",
    "answer": "CSR подходит для динамичных интерфейсов без жёстких требований к SEO, SSR — для страниц с часто меняющимися данными и важным SEO, SSG — для контентных и редко обновляемых страниц, а ISR — когда нужна высокая скорость и периодическое обновление данных."
  },
  {
    "id": "next-017",
    "topic": "nextjs",
    "question": "Что такое app directory?",
    "answer": "app directory — это новая структура роутинга в Next.js, основанная на React Server Components, которая позволяет использовать layouts, streaming, вложенные маршруты и более гибкую модель data fetching по сравнению с pages directory."
  },
  {
    "id": "next-018",
    "topic": "nextjs",
    "question": "Что такое Server Components?",
    "answer": "Server Components — это React-компоненты, которые выполняются только на сервере, не попадают в клиентский JavaScript-бандл и могут напрямую обращаться к базе данных, файловой системе и серверным API."
  },
  {
    "id": "next-019",
    "topic": "nextjs",
    "question": "Чем Server Components отличаются от Client Components?",
    "answer": "Server Components рендерятся на сервере и не поддерживают интерактивность и хуки состояния, тогда как Client Components рендерятся на клиенте, поддерживают хуки, события и интерактивное поведение пользователя."
  },
  {
    "id": "next-020",
    "topic": "nextjs",
    "question": "Зачем нужен \"use client\"?",
    "answer": "Директива \"use client\" явно указывает Next.js, что компонент должен быть Client Component, позволяя использовать хуки, обработчики событий и браузерные API внутри этого компонента."
  },
  {
    "id": "next-021",
    "topic": "nextjs",
    "question": "Можно ли использовать хуки в Server Components?",
    "answer": "В Server Components нельзя использовать хуки состояния и эффекты, такие как useState или useEffect, но можно использовать серверные хуки и асинхронные операции для получения данных."
  },
  {
    "id": "next-022",
    "topic": "nextjs",
    "question": "Как данные передаются между Server и Client Components?",
    "answer": "Данные из Server Components передаются в Client Components через props, при этом они сериализуются и передаются только в одну сторону — с сервера на клиент."
  },
  {
    "id": "next-023",
    "topic": "nextjs",
    "question": "Как делать data fetching в Next.js?",
    "answer": "Data fetching в Next.js выполняется либо на сервере в Server Components через async/await и fetch, либо через Route Handlers и Server Actions, а на клиенте в Client Components через useEffect или библиотеки типа React Query, при этом выбор зависит от требований к SEO, интерактивности и актуальности данных."
  },
  {
    "id": "next-024",
    "topic": "nextjs",
    "question": "В чём разница между fetch в Next.js и обычным fetch?",
    "answer": "В Next.js fetch расширен возможностями встроенного кеширования и управления повторной валидацией через параметры cache и next.revalidate, а также может быть автоматически дедуплицирован на сервере, тогда как обычный fetch в браузере не имеет таких фреймворк-уровневых механизмов."
  },
  {
    "id": "next-025",
    "topic": "nextjs",
    "question": "Что такое caching и revalidation?",
    "answer": "Caching — это сохранение результата запроса или страницы для повторного использования без нового обращения к источнику данных, а revalidation — механизм обновления закешированного контента по времени или событию, чтобы данные оставались актуальными."
  },
  {
    "id": "next-026",
    "topic": "nextjs",
    "question": "Как работает revalidate?",
    "answer": "revalidate задаёт интервал в секундах, после которого Next.js может пересоздать закешированный результат запроса или страницы на сервере, позволяя пользователям получать быстрый статический ответ, но с периодическим обновлением данных без полной пересборки приложения."
  },
  {
    "id": "next-027",
    "topic": "nextjs",
    "question": "Что такое generateStaticParams?",
    "answer": "generateStaticParams — это функция в App Router, которая возвращает список параметров для динамических маршрутов и используется для генерации статических страниц на этапе сборки или для предварительного построения популярных маршрутов."
  },
  {
    "id": "next-028",
    "topic": "nextjs",
    "question": "Что такое layout.tsx?",
    "answer": "layout.tsx — это специальный файл в App Router Next.js, который определяет общий интерфейс и обёртку для страниц и вложенных маршрутов, сохраняя своё состояние между переходами."
  },
  {
    "id": "next-029",
    "topic": "nextjs",
    "question": "Чем layout отличается от page?",
    "answer": "page.tsx отвечает за рендер конкретного маршрута и пересоздаётся при навигации, тогда как layout.tsx используется как постоянная обёртка для группы маршрутов и не размонтируется при переходах между ними."
  },
  {
    "id": "next-030",
    "topic": "nextjs",
    "question": "Что такое template.tsx?",
    "answer": "template.tsx похож на layout.tsx, но в отличие от него пересоздаётся при каждой навигации, что делает его полезным для сброса состояния или анимаций при смене маршрута."
  },
  {
    "id": "next-031",
    "topic": "nextjs",
    "question": "Как работают nested layouts?",
    "answer": "Nested layouts работают за счёт вложенности папок, где каждый уровень может иметь свой layout.tsx, и при рендеринге страницы все соответствующие layout-файлы оборачивают page в иерархическом порядке."
  },
  {
    "id": "next-032",
    "topic": "nextjs",
    "question": "Чем Link из Next.js отличается от обычного <a>?",
    "answer": "Link из Next.js выполняет клиентскую навигацию без полной перезагрузки страницы, предварительно подгружает код и данные для маршрута и сохраняет состояние приложения, тогда как обычный тег <a> приводит к полной перезагрузке страницы."
  },
  {
    "id": "next-033",
    "topic": "nextjs",
    "question": "Что такое useRouter?",
    "answer": "useRouter — это хук Next.js, который предоставляет программный доступ к навигации и информации о маршруте, позволяя выполнять переходы, читать параметры URL и управлять историей переходов на клиенте."
  },
  {
    "id": "next-034",
    "topic": "nextjs",
    "question": "Что такое usePathname?",
    "answer": "usePathname — это хук App Router, который возвращает текущий путь URL без query-параметров и используется для определения активных маршрутов или условного рендеринга на клиенте."
  },
  {
    "id": "next-035",
    "topic": "nextjs",
    "question": "Как работает client-side navigation?",
    "answer": "Client-side navigation в Next.js работает за счёт перехвата переходов, динамической загрузки нужных компонентов и данных, обновления URL через History API и частичного обновления интерфейса без перезагрузки страницы."
  },
  {
    "id": "next-036",
    "topic": "nextjs",
    "question": "Что такое API Routes?",
    "answer": "API Routes — это встроенный механизм Next.js, позволяющий создавать серверные эндпоинты внутри проекта для обработки HTTP-запросов, выполнения бизнес-логики и взаимодействия с базами данных без отдельного backend-приложения."
  },
  {
    "id": "next-037",
    "topic": "nextjs",
    "question": "Где и когда выполняются API Routes?",
    "answer": "API Routes выполняются на сервере при каждом HTTP-запросе, либо в Node.js runtime, либо в Edge runtime, в зависимости от конфигурации, и никогда не попадают в клиентский JavaScript-бандл."
  },
  {
    "id": "next-038",
    "topic": "nextjs",
    "question": "Чем API Routes отличаются от backend-сервиса?",
    "answer": "API Routes тесно интегрированы с Next.js-приложением и деплоятся вместе с фронтендом, тогда как полноценный backend-сервис является отдельным приложением, масштабируется независимо и обычно используется для более сложной или нагруженной серверной логики."
  },
  {
    "id": "next-039",
    "topic": "nextjs",
    "question": "Что такое Route Handlers (route.ts)?",
    "answer": "Route Handlers — это современная альтернатива API Routes в App Router, реализуемая через файл route.ts, которая использует Web Fetch API и позволяет обрабатывать HTTP-методы с поддержкой middleware, streaming и Edge runtime."
  },
  {
    "id": "next-040",
    "topic": "nextjs",
    "question": "Зачем нужен компонент Image?",
    "answer": "Компонент Image в Next.js используется для автоматической оптимизации изображений, включая адаптивные размеры, lazy loading, сжатие, использование современных форматов и предотвращение layout shift для улучшения производительности."
  },
  {
    "id": "next-041",
    "topic": "nextjs",
    "question": "Что делает компонент Script?",
    "answer": "Компонент Script управляет загрузкой сторонних и пользовательских скриптов, позволяя контролировать стратегию их выполнения, такую как beforeInteractive, afterInteractive или lazyOnload, для оптимизации производительности."
  },
  {
    "id": "next-042",
    "topic": "nextjs",
    "question": "Как работает code splitting в Next.js?",
    "answer": "Code splitting в Next.js работает автоматически на уровне маршрутов и компонентов, загружая только необходимый JavaScript для текущей страницы и динамически подгружая остальной код при навигации или по требованию."
  },
  {
    "id": "next-043",
    "topic": "nextjs",
    "question": "Что такое prefetch?",
    "answer": "Prefetch — это механизм предварительной загрузки ресурсов следующего маршрута в фоне, который Next.js использует для ускорения навигации, подгружая код и данные до фактического перехода пользователя."
  },
  {
    "id": "next-044",
    "topic": "nextjs",
    "question": "Какие способы стилизации поддерживает Next.js?",
    "answer": "Next.js поддерживает глобальные CSS-файлы, CSS Modules, SCSS и Sass Modules, CSS-in-JS библиотеки, такие как styled-components и emotion, а также Tailwind CSS и inline-стили."
  },
  {
    "id": "next-045",
    "topic": "nextjs",
    "question": "Как работают CSS Modules в Next.js?",
    "answer": "CSS Modules в Next.js изолируют стили на уровне компонента, автоматически генерируя уникальные имена классов, что предотвращает конфликты стилей и позволяет безопасно использовать одинаковые имена классов в разных файлах."
  },
  {
    "id": "next-046",
    "topic": "nextjs",
    "question": "Можно ли использовать SCSS?",
    "answer": "Да, Next.js поддерживает SCSS и Sass из коробки, включая глобальные SCSS-файлы и SCSS Modules, без дополнительной настройки сборщика."
  },
  {
    "id": "next-047",
    "topic": "nextjs",
    "question": "Как стили работают в Server Components?",
    "answer": "В Server Components стили применяются во время серверного рендера и передаются в HTML, при этом поддерживаются CSS Modules и глобальные стили, а сами стили не увеличивают клиентский JavaScript-бандл."
  },
  {
    "id": "next-048",
    "topic": "nextjs",
    "question": "Что такое Middleware в Next.js?",
    "answer": "Middleware в Next.js — это функция, которая выполняется до обработки запроса страницей или API и позволяет перехватывать запросы, изменять ответы или выполнять логику до рендера."
  },
  {
    "id": "next-049",
    "topic": "nextjs",
    "question": "Где выполняется Middleware?",
    "answer": "Middleware выполняется на сервере в Edge Runtime максимально близко к пользователю, что позволяет быстро обрабатывать запросы без полного Node.js окружения."
  },
  {
    "id": "next-050",
    "topic": "nextjs",
    "question": "Какие задачи решает Middleware?",
    "answer": "Middleware используется для аутентификации и авторизации, редиректов, A/B тестирования, локализации, логирования, защиты маршрутов и модификации заголовков запросов и ответов."
  },
  {
    "id": "next-051",
    "topic": "nextjs",
    "question": "Как защитить страницу от неавторизованного доступа?",
    "answer": "Страницу в Next.js можно защитить с помощью проверки авторизации на сервере через Middleware, Server Components или Route Handlers, выполняя редирект или возвращая ошибку до рендера контента."
  },
  {
    "id": "next-052",
    "topic": "nextjs",
    "question": "Как реализовать авторизацию в Next.js?",
    "answer": "Авторизация в Next.js обычно реализуется с помощью cookies или токенов, проверяемых на сервере, часто с использованием библиотек вроде NextAuth, Middleware для защиты маршрутов и Server Components для получения данных пользователя."
  },
  {
    "id": "next-053",
    "topic": "nextjs",
    "question": "Как обрабатывать ошибки?",
    "answer": "Ошибки в Next.js обрабатываются с помощью error.tsx для runtime-ошибок, try/catch в Server Components и Route Handlers, а также через глобальные обработчики ошибок и fallback UI."
  },
  {
    "id": "next-054",
    "topic": "nextjs",
    "question": "Что такое error.tsx?",
    "answer": "error.tsx — это специальный файл в App Router, который используется как Error Boundary и отображается при возникновении ошибки во время рендера или загрузки данных в соответствующем сегменте маршрута."
  },
  {
    "id": "next-055",
    "topic": "nextjs",
    "question": "Что такое not-found.tsx?",
    "answer": "not-found.tsx — это файл, который определяет интерфейс страницы 404 и отображается, когда маршрут или данные не найдены, либо когда явно вызывается функция notFound()."
  },
  {
    "id": "next-056",
    "topic": "nextjs",
    "question": "Как работает loading.tsx?",
    "answer": "loading.tsx отображается автоматически во время загрузки данных или ленивой инициализации сегмента маршрута и используется для реализации skeleton UI и улучшения пользовательского опыта."
  },
  {
    "id": "next-057",
    "topic": "nextjs",
    "question": "Как деплоится Next.js-приложение?",
    "answer": "Next.js-приложение деплоится либо на Vercel с автоматической поддержкой SSR, Edge и ISR, либо на любой сервер или платформу, поддерживающую Node.js, с помощью сборки и запуска production-сервера."
  },
  {
    "id": "next-058",
    "topic": "nextjs",
    "question": "Какие проблемы могут быть при использовании SSR?",
    "answer": "При использовании SSR возможны повышенная нагрузка на сервер, более медленные ответы при большом трафике, сложности с кешированием и ошибки, связанные с использованием браузерных API на сервере."
  },
  {
    "id": "next-059",
    "topic": "nextjs",
    "question": "Какие частые ошибки допускают в Next.js?",
    "answer": "Частые ошибки в Next.js включают чрезмерное использование Client Components, отсутствие кеширования, неправильное использование SSR вместо SSG, обращение к window на сервере и игнорирование оптимизаций изображений."
  },
  {
    "id": "next-060",
    "topic": "nextjs",
    "question": "Когда Next.js использовать не стоит?",
    "answer": "Next.js не стоит использовать для простых SPA без требований к SEO и серверному рендерингу, небольших виджетов или приложений, где избыточная инфраструктура усложнит разработку без явных преимуществ."
  },
  {
    "id": "fundamentals-001",
    "topic": "fundamentals",
    "question": "Как браузер рендерит страницу?",
    "answer": "Браузер загружает HTML, парсит его в DOM, параллельно загружает и парсит CSS в CSSOM, объединяет DOM и CSSOM в render tree, рассчитывает стили и геометрию элементов (layout), а затем отрисовывает пиксели на экране (paint), после чего может выполнять JavaScript и повторять части процесса при изменениях."
  },
  {
    "id": "fundamentals-002",
    "topic": "fundamentals",
    "question": "Что такое Critical Rendering Path?",
    "answer": "Critical Rendering Path — это последовательность шагов от загрузки HTML, CSS и JavaScript до первого отображения контента на экране, включающая построение DOM, CSSOM, render tree, layout и paint, оптимизация которой напрямую влияет на скорость загрузки страницы."
  },
  {
    "id": "fundamentals-003",
    "topic": "fundamentals",
    "question": "В каком порядке загружаются HTML, CSS и JS?",
    "answer": "HTML загружается и парсится последовательно, CSS загружается параллельно и блокирует рендер до построения CSSOM, а JavaScript по умолчанию блокирует парсинг HTML до выполнения, если не используется async или defer."
  },
  {
    "id": "fundamentals-004",
    "topic": "fundamentals",
    "question": "Почему CSS может блокировать рендер?",
    "answer": "CSS блокирует рендер, потому что браузеру необходимо полностью построить CSSOM до создания render tree, иначе он не сможет корректно рассчитать стили и размеры элементов."
  },
  {
    "id": "fundamentals-005",
    "topic": "fundamentals",
    "question": "Почему JS может блокировать рендер?",
    "answer": "JavaScript блокирует рендер, потому что браузер должен приостановить парсинг HTML и выполнение других задач до выполнения скрипта, так как JS может изменить DOM и CSSOM."
  },
  {
    "id": "fundamentals-006",
    "topic": "fundamentals",
    "question": "Что такое reflow и repaint?",
    "answer": "Reflow — это перерасчёт размеров и положения элементов в layout, а repaint — это перерисовка визуального представления элементов без изменения их геометрии."
  },
  {
    "id": "fundamentals-007",
    "topic": "fundamentals",
    "question": "В чём разница между reflow и repaint?",
    "answer": "Reflow является более дорогой операцией, так как влияет на layout и может затронуть множество элементов, тогда как repaint обновляет только визуальные стили, такие как цвет или фон, без пересчёта размеров."
  },
  {
    "id": "fundamentals-008",
    "topic": "fundamentals",
    "question": "Что такое event loop?",
    "answer": "Event loop — это механизм JavaScript-движка, который управляет выполнением кода, обрабатывая call stack, очереди microtask и macrotask и обеспечивая асинхронное, неблокирующее выполнение в однопоточном окружении."
  },
  {
    "id": "fundamentals-009",
    "topic": "fundamentals",
    "question": "Что такое call stack?",
    "answer": "Call stack — это структура данных, в которой хранятся контексты выполнения функций, где функции добавляются при вызове и удаляются после завершения выполнения."
  },
  {
    "id": "fundamentals-010",
    "topic": "fundamentals",
    "question": "Чем microtask отличается от macrotask?",
    "answer": "Microtask имеет более высокий приоритет и выполняется сразу после завершения текущего синхронного кода, тогда как macrotask выполняется позже и включает такие операции, как setTimeout и обработчики событий."
  },
  {
    "id": "fundamentals-011",
    "topic": "fundamentals",
    "question": "В каком порядке выполняются sync-код, Promise и setTimeout?",
    "answer": "Сначала выполняется весь синхронный код, затем выполняются все microtask из Promise, и только после этого event loop переходит к выполнению macrotask, таких как callbacks из setTimeout."
  },
  {
    "id": "fundamentals-012",
    "topic": "fundamentals",
    "question": "Что происходит при клике по кнопке в браузере?",
    "answer": "При клике браузер фиксирует событие, помещает его в очередь macrotask, после чего event loop обрабатывает его, выполняет обработчики событий с учётом фаз capturing и bubbling, может запустить синхронный код, microtask и вызвать перерисовку интерфейса."
  },
  {
    "id": "fundamentals-013",
    "topic": "fundamentals",
    "question": "Что такое HTTP?",
    "answer": "HTTP (HyperText Transfer Protocol) — это прикладной протокол передачи данных, который определяет правила обмена запросами и ответами между клиентом и сервером в модели клиент–сервер и является stateless, то есть не хранит состояние между запросами."
  },
  {
    "id": "fundamentals-014",
    "topic": "fundamentals",
    "question": "Чем HTTP отличается от HTTPS?",
    "answer": "HTTPS отличается от HTTP тем, что использует шифрование TLS, обеспечивая конфиденциальность, целостность и подлинность данных, тогда как HTTP передаёт данные в открытом виде и уязвим для перехвата и подмены."
  },
  {
    "id": "fundamentals-015",
    "topic": "fundamentals",
    "question": "Какие HTTP-методы ты знаешь?",
    "answer": "Основные HTTP-методы включают GET для получения данных, POST для создания ресурсов, PUT и PATCH для обновления, DELETE для удаления, а также HEAD, OPTIONS и TRACE для служебных и диагностических операций."
  },
  {
    "id": "fundamentals-016",
    "topic": "fundamentals",
    "question": "В чём разница между PUT и PATCH?",
    "answer": "PUT предназначен для полного обновления ресурса и заменяет его целиком, тогда как PATCH используется для частичного обновления и изменяет только переданные поля, не затрагивая остальные данные."
  },
  {
    "id": "fundamentals-017",
    "topic": "fundamentals",
    "question": "Какие группы HTTP-статусов существуют?",
    "answer": "HTTP-статусы делятся на группы: 1xx — информационные, 2xx — успешные ответы, 3xx — редиректы, 4xx — ошибки клиента и 5xx — ошибки сервера."
  },
  {
    "id": "fundamentals-018",
    "topic": "fundamentals",
    "question": "Чем отличаются 401 и 403?",
    "answer": "401 означает, что пользователь не аутентифицирован или аутентификация не выполнена, тогда как 403 означает, что пользователь аутентифицирован, но не имеет прав доступа к ресурсу."
  },
  {
    "id": "fundamentals-019",
    "topic": "fundamentals",
    "question": "Что такое headers?",
    "answer": "Headers — это метаданные HTTP-запроса или ответа в формате ключ–значение, которые передают информацию о типе контента, авторизации, кешировании, cookies и других параметрах взаимодействия."
  },
  {
    "id": "fundamentals-020",
    "topic": "fundamentals",
    "question": "Что такое cookies?",
    "answer": "Cookies — это небольшие фрагменты данных, которые сервер сохраняет в браузере клиента и которые автоматически отправляются с каждым запросом к соответствующему домену для хранения состояния, сессий и авторизации."
  },
  {
    "id": "fundamentals-021",
    "topic": "fundamentals",
    "question": "Что такое CORS?",
    "answer": "CORS (Cross-Origin Resource Sharing) — это механизм безопасности браузера, который определяет, разрешено ли веб-странице запрашивать ресурсы с другого домена, основываясь на специальных HTTP-заголовках."
  },
  {
    "id": "fundamentals-022",
    "topic": "fundamentals",
    "question": "Почему возникает CORS-ошибка?",
    "answer": "CORS-ошибка возникает, когда браузер блокирует запрос из-за отсутствия или некорректных CORS-заголовков в ответе сервера, даже если сам сервер корректно обработал запрос."
  },
  {
    "id": "fundamentals-023",
    "topic": "fundamentals",
    "question": "Что такое preflight-запрос?",
    "answer": "Preflight-запрос — это предварительный OPTIONS-запрос, который браузер отправляет перед небезопасными кросс-доменными запросами, чтобы проверить, разрешает ли сервер такие методы, заголовки и источники."
  },
  {
    "id": "fundamentals-024",
    "topic": "fundamentals",
    "question": "Чем REST отличается от GraphQL?",
    "answer": "REST использует несколько эндпоинтов и фиксированную структуру ответов, тогда как GraphQL предоставляет единый эндпоинт и позволяет клиенту точно указывать, какие данные ему нужны, уменьшая overfetching и underfetching."
  },
  {
    "id": "fundamentals-025",
    "topic": "fundamentals",
    "question": "Что такое idempotent-запрос?",
    "answer": "Idempotent-запрос — это запрос, повторное выполнение которого приводит к одному и тому же результату на сервере, например GET, PUT и DELETE, в отличие от POST, который обычно не является идемпотентным."
  },
  {
    "id": "fundamentals-026",
    "topic": "fundamentals",
    "question": "Что такое CRUD?",
    "answer": "CRUD — это базовый набор операций для работы с данными, включающий Create (создание), Read (чтение), Update (обновление) и Delete (удаление), который лежит в основе большинства клиент-серверных приложений и API."
  },
  {
    "id": "fundamentals-027",
    "topic": "fundamentals",
    "question": "Как организовать загрузку данных на клиенте?",
    "answer": "Загрузка данных на клиенте обычно организуется через асинхронные HTTP-запросы с использованием fetch или библиотек вроде Axios, с разделением состояний на loading, success и error и возможным кешированием данных."
  },
  {
    "id": "fundamentals-028",
    "topic": "fundamentals",
    "question": "Что делать с loading-состоянием?",
    "answer": "Loading-состояние следует явно обрабатывать в интерфейсе, показывая пользователю индикаторы загрузки или skeleton UI, чтобы улучшить UX и избежать ощущения зависшего приложения."
  },
  {
    "id": "fundamentals-029",
    "topic": "fundamentals",
    "question": "Как обрабатывать ошибки API?",
    "answer": "Ошибки API обрабатываются через проверку HTTP-статусов и try/catch, отображение понятных сообщений пользователю, логирование ошибок и реализацию fallback-сценариев или повторных запросов."
  },
  {
    "id": "fundamentals-030",
    "topic": "fundamentals",
    "question": "Что такое debounce?",
    "answer": "Debounce — это техника ограничения частоты вызова функции, при которой она выполняется только после паузы в событиях, что часто используется для оптимизации ввода, поиска и resize-событий."
  },
  {
    "id": "fundamentals-031",
    "topic": "fundamentals",
    "question": "Чем debounce отличается от throttle?",
    "answer": "Debounce откладывает выполнение функции до окончания серии событий, тогда как throttle гарантирует выполнение функции не чаще заданного интервала времени независимо от количества событий."
  },
  {
    "id": "fundamentals-032",
    "topic": "fundamentals",
    "question": "Что такое pagination?",
    "answer": "Pagination — это способ постраничной загрузки данных, при котором элементы разбиваются на страницы, что снижает нагрузку на сервер и клиент и упрощает навигацию по большим спискам."
  },
  {
    "id": "fundamentals-033",
    "topic": "fundamentals",
    "question": "Что такое infinite scroll?",
    "answer": "Infinite scroll — это подход к загрузке данных, при котором новые элементы подгружаются автоматически при прокрутке страницы, создавая ощущение бесконечного списка и улучшая вовлечённость пользователя."
  },
  {
    "id": "fundamentals-034",
    "topic": "fundamentals",
    "question": "Как отменить HTTP-запрос?",
    "answer": "HTTP-запрос можно отменить с помощью AbortController, передав его signal в fetch или поддерживающую библиотеку, что позволяет прерывать запросы при размонтировании компонента или смене условий."
  },
  {
    "id": "fundamentals-035",
    "topic": "fundamentals",
    "question": "Что такое AbortController?",
    "answer": "AbortController — это Web API, позволяющее управлять отменой асинхронных операций, таких как fetch-запросы, путём отправки сигнала abort для остановки выполнения."
  },
  {
    "id": "fundamentals-036",
    "topic": "fundamentals",
    "question": "Что делать при нестабильном API?",
    "answer": "При нестабильном API следует реализовывать повторные запросы с backoff, таймауты, кеширование успешных ответов, graceful degradation интерфейса и информирование пользователя о проблемах."
  },
  {
    "id": "fundamentals-037",
    "topic": "fundamentals",
    "question": "Как работать с авторизацией на фронтенде?",
    "answer": "Авторизация на фронтенде обычно реализуется через хранение токенов или сессионных cookies, проверку прав доступа, защиту маршрутов, обновление токенов и корректную обработку состояний входа и выхода пользователя."
  },
  {
    "id": "fundamentals-038",
    "topic": "fundamentals",
    "question": "Что такое frontend-архитектура?",
    "answer": "Frontend-архитектура — это набор принципов, правил и структур организации кода, которые определяют, как разделяются ответственность, данные, UI и бизнес-логика в приложении для обеспечения масштабируемости, поддержки и развития проекта."
  },
  {
    "id": "fundamentals-039",
    "topic": "fundamentals",
    "question": "Зачем разделять код по слоям?",
    "answer": "Разделение кода по слоям позволяет изолировать ответственность, снизить связанность между частями приложения, упростить тестирование, поддержку и развитие функциональности без каскадных изменений."
  },
  {
    "id": "fundamentals-040",
    "topic": "fundamentals",
    "question": "Что такое separation of concerns?",
    "answer": "Separation of concerns — это принцип разработки, при котором каждая часть системы отвечает только за одну зону ответственности, например UI, бизнес-логику или работу с данными, что делает код более понятным и управляемым."
  },
  {
    "id": "fundamentals-041",
    "topic": "fundamentals",
    "question": "Как структурировать большой frontend-проект?",
    "answer": "Большой frontend-проект следует структурировать по доменам и ответственности, группируя код по фичам или слоям, отделяя UI, бизнес-логику, состояние и инфраструктуру, а также используя общие правила именования и навигации по проекту."
  },
  {
    "id": "fundamentals-042",
    "topic": "fundamentals",
    "question": "Где должна находиться бизнес-логика?",
    "answer": "Бизнес-логика должна находиться вне UI-компонентов, в отдельных слоях или модулях, чтобы быть переиспользуемой, тестируемой и независимой от конкретного фреймворка или представления."
  },
  {
    "id": "fundamentals-043",
    "topic": "fundamentals",
    "question": "Что такое Feature-Sliced Design?",
    "answer": "Feature-Sliced Design — это архитектурная методология для фронтенда, которая предлагает структурировать проект по слоям и фичам, разделяя код на app, processes, pages, widgets, features, entities и shared."
  },
  {
    "id": "fundamentals-044",
    "topic": "fundamentals",
    "question": "Чем feature отличается от widget?",
    "answer": "Feature представляет собой законченную пользовательскую возможность с бизнес-логикой, тогда как widget — это композиция UI-элементов, объединяющая несколько features или entities для отображения части интерфейса."
  },
  {
    "id": "fundamentals-045",
    "topic": "fundamentals",
    "question": "Какие проблемы решает архитектура?",
    "answer": "Архитектура решает проблемы масштабируемости, сложности поддержки, роста связности, дублирования логики, хаотичной структуры кода и снижает риски при добавлении новых фич и работе команды."
  },
  {
    "id": "fundamentals-046",
    "topic": "fundamentals",
    "question": "Как избежать \"спагетти-кода\"?",
    "answer": "Чтобы избежать спагетти-кода, необходимо соблюдать принципы архитектуры, разделять ответственность, избегать жёстких зависимостей, ограничивать размер компонентов и регулярно проводить рефакторинг."
  },
  {
    "id": "fundamentals-047",
    "topic": "fundamentals",
    "question": "Как понять, что архитектура плохая?",
    "answer": "Плохая архитектура проявляется через сложность внесения изменений, частые баги при правках, сильную связанность модулей, дублирование логики, неочевидную структуру проекта и страх разработчиков что-либо менять."
  },
  {
    "id": "fundamentals-048",
    "topic": "fundamentals",
    "question": "Что такое state?",
    "answer": "State — это данные приложения, которые могут изменяться со временем и напрямую влияют на то, как интерфейс выглядит и ведёт себя в текущий момент."
  },
  {
    "id": "fundamentals-049",
    "topic": "fundamentals",
    "question": "Чем локальный state отличается от глобального?",
    "answer": "Локальный state принадлежит конкретному компоненту и используется только внутри него, тогда как глобальный state доступен нескольким частям приложения и используется для хранения общих данных."
  },
  {
    "id": "fundamentals-050",
    "topic": "fundamentals",
    "question": "Когда локального state недостаточно?",
    "answer": "Локального state недостаточно, когда данные должны использоваться несколькими удалёнными компонентами, синхронизироваться между экранами или сохраняться при навигации по приложению."
  },
  {
    "id": "fundamentals-051",
    "topic": "fundamentals",
    "question": "Что такое server state?",
    "answer": "Server state — это состояние, источником которого является сервер, например данные API, и которое может изменяться независимо от клиента, требуя синхронизации, кеширования и повторной загрузки."
  },
  {
    "id": "fundamentals-052",
    "topic": "fundamentals",
    "question": "Чем server state отличается от client state?",
    "answer": "Server state управляется сервером и требует загрузки, обновления и кеширования, тогда как client state полностью контролируется клиентом и используется для UI-состояний, таких как открытые модалки или выбранные элементы."
  },
  {
    "id": "fundamentals-053",
    "topic": "fundamentals",
    "question": "Когда Context — плохой выбор?",
    "answer": "Context является плохим выбором, когда состояние часто меняется и приводит к массовым перерендерам, либо когда он используется как полноценная замена state-менеджеру без чётких границ ответственности."
  },
  {
    "id": "fundamentals-054",
    "topic": "fundamentals",
    "question": "В каких случаях нужен Redux?",
    "answer": "Redux нужен в больших приложениях с сложным глобальным состоянием, множеством источников изменений, требованиями к предсказуемости, дебагу и строгому контролю потока данных."
  },
  {
    "id": "fundamentals-055",
    "topic": "fundamentals",
    "question": "Зачем нужен Redux Toolkit?",
    "answer": "Redux Toolkit упрощает работу с Redux, уменьшая шаблонный код, предоставляя безопасные паттерны обновления состояния, встроенную работу с асинхронностью и лучшую поддержку масштабирования."
  },
  {
    "id": "fundamentals-056",
    "topic": "fundamentals",
    "question": "Что решает React Query?",
    "answer": "React Query решает проблемы server state, автоматически управляя загрузкой данных, кешированием, повторной валидацией, синхронизацией и обработкой ошибок без необходимости хранить данные API в Redux."
  },
  {
    "id": "fundamentals-057",
    "topic": "fundamentals",
    "question": "Где лучше хранить состояние формы?",
    "answer": "Состояние формы лучше хранить локально в компоненте или в специализированных библиотеках для форм, так как оно тесно связано с UI и редко требуется глобально."
  },
  {
    "id": "fundamentals-058",
    "topic": "fundamentals",
    "question": "Где нельзя хранить state?",
    "answer": "State не следует хранить в глобальных переменных, напрямую в DOM, в props или в местах, где он теряет контроль обновлений и приводит к непредсказуемому поведению приложения."
  },
  {
    "id": "fundamentals-059",
    "topic": "fundamentals",
    "question": "Что такое производительность во frontend?",
    "answer": "Производительность во frontend — это совокупность характеристик, определяющих скорость загрузки, отзывчивость и плавность интерфейса, включая время первого рендера, скорость реакции на действия пользователя и стабильность визуального отображения."
  },
  {
    "id": "fundamentals-060",
    "topic": "fundamentals",
    "question": "Почему приложение может тормозить?",
    "answer": "Frontend-приложение может тормозить из-за тяжёлого JavaScript, частых и лишних перерендеров, неэффективных вычислений, блокирующих операций, больших бандлов, неоптимальных изображений и чрезмерных reflow и repaint."
  },
  {
    "id": "fundamentals-061",
    "topic": "fundamentals",
    "question": "Что такое unnecessary re-renders?",
    "answer": "Unnecessary re-renders — это лишние перерисовки компонентов, которые происходят без реального изменения отображаемых данных и приводят к ухудшению производительности интерфейса."
  },
  {
    "id": "fundamentals-062",
    "topic": "fundamentals",
    "question": "Как определить проблему производительности?",
    "answer": "Проблемы производительности определяются с помощью инструментов браузера, таких как Chrome DevTools, Performance и Lighthouse, React DevTools Profiler, анализа Web Vitals и наблюдения за поведением интерфейса."
  },
  {
    "id": "fundamentals-063",
    "topic": "fundamentals",
    "question": "Что такое code splitting?",
    "answer": "Code splitting — это техника разделения JavaScript-кода на независимые чанки, которые загружаются по мере необходимости, что уменьшает размер начального бандла и ускоряет первый рендер страницы."
  },
  {
    "id": "fundamentals-064",
    "topic": "fundamentals",
    "question": "Что такое lazy loading?",
    "answer": "Lazy loading — это подход, при котором ресурсы, компоненты или данные загружаются только в момент, когда они действительно нужны пользователю, например при прокрутке или навигации."
  },
  {
    "id": "fundamentals-065",
    "topic": "fundamentals",
    "question": "Что такое memoization?",
    "answer": "Memoization — это техника оптимизации, при которой результат вычислений сохраняется и переиспользуется при повторных вызовах с теми же входными данными, снижая количество дорогостоящих операций."
  },
  {
    "id": "fundamentals-066",
    "topic": "fundamentals",
    "question": "Когда useMemo и useCallback бесполезны?",
    "answer": "useMemo и useCallback бесполезны или вредны, когда вычисления дешёвые, компоненты редко перерисовываются или мемоизация добавляет больше накладных расходов, чем экономии производительности."
  },
  {
    "id": "fundamentals-067",
    "topic": "fundamentals",
    "question": "Что такое Web Vitals?",
    "answer": "Web Vitals — это набор метрик от Google, предназначенных для измерения ключевых аспектов пользовательского опыта, включая скорость загрузки, интерактивность и визуальную стабильность страницы."
  },
  {
    "id": "fundamentals-068",
    "topic": "fundamentals",
    "question": "Что такое LCP?",
    "answer": "LCP (Largest Contentful Paint) — это метрика Web Vitals, которая измеряет время отображения самого крупного видимого элемента контента на странице и отражает скорость загрузки основного содержимого."
  },
  {
    "id": "fundamentals-069",
    "topic": "fundamentals",
    "question": "Что такое CLS?",
    "answer": "CLS (Cumulative Layout Shift) — это метрика, измеряющая суммарное смещение элементов страницы во время загрузки, которое негативно влияет на восприятие стабильности интерфейса."
  },
  {
    "id": "fundamentals-070",
    "topic": "fundamentals",
    "question": "Что такое FID?",
    "answer": "FID (First Input Delay) — это метрика, показывающая время между первым взаимодействием пользователя и фактическим выполнением обработчика события, отражающая отзывчивость страницы."
  },
  {
    "id": "fundamentals-071",
    "topic": "fundamentals",
    "question": "Как frontend влияет на SEO?",
    "answer": "Frontend влияет на SEO через скорость загрузки, корректный SSR или SSG, семантическую HTML-разметку, доступность контента для поисковых роботов, оптимизацию Web Vitals и правильную работу навигации."
  },
  {
    "id": "fundamentals-072",
    "topic": "fundamentals",
    "question": "Что такое accessibility?",
    "answer": "Accessibility или a11y — это практика проектирования и разработки интерфейсов таким образом, чтобы ими могли пользоваться люди с различными ограничениями, включая нарушения зрения, слуха, моторики и когнитивных способностей."
  },
  {
    "id": "fundamentals-073",
    "topic": "fundamentals",
    "question": "Почему доступность важна?",
    "answer": "Доступность важна потому, что делает продукт пригодным для более широкой аудитории, улучшает пользовательский опыт для всех, соответствует юридическим требованиям во многих странах и повышает качество и устойчивость интерфейсов."
  },
  {
    "id": "fundamentals-074",
    "topic": "fundamentals",
    "question": "Как семантический HTML улучшает a11y?",
    "answer": "Семантический HTML улучшает a11y, так как даёт скринридерам и вспомогательным технологиям точную информацию о роли и структуре элементов, позволяя пользователям корректно навигировать и понимать содержимое страницы."
  },
  {
    "id": "fundamentals-075",
    "topic": "fundamentals",
    "question": "Что такое screen reader?",
    "answer": "Screen reader — это вспомогательная технология, которая озвучивает содержимое интерфейса и структуру страницы, позволяя пользователям с нарушениями зрения взаимодействовать с веб-приложениями."
  },
  {
    "id": "fundamentals-076",
    "topic": "fundamentals",
    "question": "Зачем нужен alt?",
    "answer": "Атрибут alt нужен для описания содержания изображения скринридерам, отображения альтернативного текста при ошибке загрузки и улучшения доступности и SEO."
  },
  {
    "id": "fundamentals-077",
    "topic": "fundamentals",
    "question": "Что такое aria-атрибуты?",
    "answer": "ARIA-атрибуты — это специальные атрибуты, которые добавляют или уточняют роль, состояние и свойства элементов интерфейса для вспомогательных технологий, когда семантического HTML недостаточно."
  },
  {
    "id": "fundamentals-078",
    "topic": "fundamentals",
    "question": "Когда нельзя использовать div?",
    "answer": "div не следует использовать, когда существует подходящий семантический тег, например button, nav, header или main, так как это ухудшает доступность и требует дополнительной настройки ролей и клавиатурного управления."
  },
  {
    "id": "fundamentals-079",
    "topic": "fundamentals",
    "question": "Как проверить доступность сайта?",
    "answer": "Доступность сайта проверяется с помощью автоматических инструментов, таких как Lighthouse и axe, ручного тестирования с клавиатуры, проверки контраста, а также тестирования со скринридерами."
  },
  {
    "id": "fundamentals-080",
    "topic": "fundamentals",
    "question": "Что такое XSS?",
    "answer": "XSS (Cross-Site Scripting) — это уязвимость безопасности, при которой злоумышленник внедряет вредоносный JavaScript-код в страницу, чтобы выполнить его в браузере пользователя и получить доступ к данным, cookies или сессии."
  },
  {
    "id": "fundamentals-081",
    "topic": "fundamentals",
    "question": "Что такое CSRF?",
    "answer": "CSRF (Cross-Site Request Forgery) — это атака, при которой злоумышленник заставляет браузер авторизованного пользователя отправить нежелательный запрос к серверу от его имени, используя автоматически прикрепляемые cookies."
  },
  {
    "id": "fundamentals-082",
    "topic": "fundamentals",
    "question": "Почему нельзя доверять данным с клиента?",
    "answer": "Данным с клиента нельзя доверять, потому что пользователь может изменить их вручную, отправить произвольный запрос или подменить параметры, поэтому все данные должны валидироваться и проверяться на сервере."
  },
  {
    "id": "fundamentals-083",
    "topic": "fundamentals",
    "question": "Где безопасно хранить токены?",
    "answer": "Наиболее безопасным способом хранения токенов является использование HttpOnly cookies с флагами Secure и SameSite, так как они недоступны JavaScript и защищены от XSS-атак."
  },
  {
    "id": "fundamentals-084",
    "topic": "fundamentals",
    "question": "Чем cookies отличаются от localStorage?",
    "answer": "Cookies автоматически отправляются с каждым HTTP-запросом и могут быть защищены флагами безопасности, тогда как localStorage доступен через JavaScript, не отправляется на сервер автоматически и более уязвим для XSS."
  },
  {
    "id": "fundamentals-085",
    "topic": "fundamentals",
    "question": "Почему опасно хранить JWT в localStorage?",
    "answer": "Хранить JWT в localStorage опасно, потому что при XSS-атаке злоумышленник может получить доступ к токену и полностью скомпрометировать аккаунт пользователя без возможности ограничения доступа."
  },
  {
    "id": "fundamentals-086",
    "topic": "fundamentals",
    "question": "Чем npm отличается от yarn?",
    "answer": "npm и yarn — это менеджеры пакетов для JavaScript, при этом yarn изначально делал упор на скорость и детерминированность установок через lock-файл, а npm со временем получил схожие возможности и теснее интегрирован с экосистемой Node.js."
  },
  {
    "id": "fundamentals-087",
    "topic": "fundamentals",
    "question": "Что такое package.json?",
    "answer": "package.json — это конфигурационный файл проекта, в котором описаны зависимости, скрипты, метаданные проекта, версии пакетов и настройки, необходимые для сборки и запуска приложения."
  },
  {
    "id": "fundamentals-088",
    "topic": "fundamentals",
    "question": "Что такое devDependencies?",
    "answer": "devDependencies — это зависимости, которые нужны только в процессе разработки и сборки проекта, такие как линтеры, форматтеры и инструменты тестирования, и не требуются для работы приложения в production."
  },
  {
    "id": "fundamentals-089",
    "topic": "fundamentals",
    "question": "Зачем нужен ESLint?",
    "answer": "ESLint используется для статического анализа кода, поиска потенциальных ошибок, соблюдения единых правил код-стайла и предотвращения проблем ещё до выполнения приложения."
  },
  {
    "id": "fundamentals-090",
    "topic": "fundamentals",
    "question": "Зачем нужен Prettier?",
    "answer": "Prettier автоматически форматирует код по заданным правилам, устраняя споры о стиле, улучшая читаемость и обеспечивая единообразие кода в команде."
  },
  {
    "id": "fundamentals-091",
    "topic": "fundamentals",
    "question": "Что такое environment variables?",
    "answer": "Environment variables — это переменные окружения, используемые для хранения конфигурации и чувствительных данных, таких как ключи API и адреса сервисов, без жёсткого встраивания их в код."
  },
  {
    "id": "fundamentals-092",
    "topic": "fundamentals",
    "question": "Чем Vite отличается от Webpack?",
    "answer": "Vite использует ES-модули и dev-сервер без предварительной сборки для мгновенного старта разработки, тогда как Webpack собирает бандл заранее и предоставляет более гибкую, но сложную систему конфигурации."
  },
  {
    "id": "fundamentals-093",
    "topic": "fundamentals",
    "question": "Что такое build?",
    "answer": "Build — это процесс преобразования исходного кода приложения в оптимизированные файлы для production, включающий сборку бандлов, минификацию, оптимизацию ресурсов и подготовку к деплою."
  },
  {
    "id": "fundamentals-094",
    "topic": "fundamentals",
    "question": "Чем dev-сборка отличается от prod?",
    "answer": "Dev-сборка ориентирована на удобство разработки и включает sourcemaps и подробные ошибки, тогда как prod-сборка оптимизирована для производительности, использует минификацию, tree shaking и исключает лишний код."
  }
]
