[
  {
    "id": "react-001",
    "topic": "react",
    "question": "Что такое виртуальный DOM и какие задачи он решает в React?",
    "answer": "Виртуальный DOM — это абстрактное представление реального DOM в виде JavaScript-объектов, которое React хранит в памяти для оптимизации обновлений интерфейса; при изменении state или props React создаёт новое виртуальное дерево компонентов, сравнивает его с предыдущей версией с помощью алгоритма diffing и вычисляет минимальный набор изменений, которые необходимо применить к реальному DOM, что позволяет сократить количество дорогих операций с DOM, повысить производительность и сделать обновления UI более предсказуемыми и управляемыми."
  },
  {
    "id": "react-002",
    "topic": "react",
    "question": "Как работает процесс reconciliation и почему он важен?",
    "answer": "Reconciliation — это процесс, в ходе которого React сравнивает новое виртуальное DOM-дерево с предыдущим состоянием интерфейса, анализируя типы элементов и их ключи, чтобы определить, какие компоненты можно переиспользовать, а какие необходимо пересоздать, после чего React применяет к реальному DOM только необходимые изменения, что позволяет избежать полной перерисовки страницы и значительно улучшить производительность, особенно в сложных интерфейсах с большим количеством компонентов."
  },
  {
    "id": "react-003",
    "topic": "react",
    "question": "Почему React рекомендует использовать функциональные компоненты вместо классовых?",
    "answer": "Функциональные компоненты стали рекомендуемым подходом в React после появления хуков, так как они позволяют использовать состояние, побочные эффекты и другую логику без классов, уменьшают количество шаблонного кода, упрощают композицию и переиспользование логики, делают поведение компонентов более предсказуемым и облегчают тестирование и сопровождение приложения по сравнению с классовыми компонентами."
  },
  {
    "id": "react-004",
    "topic": "react",
    "question": "Как React обрабатывает обновления state внутри функционального компонента?",
    "answer": "При обновлении state с помощью функции из useState React не изменяет состояние немедленно, а ставит обновление в очередь, может объединить несколько обновлений в один рендер для оптимизации, затем повторно вызывает функцию компонента, создаёт новое виртуальное DOM-дерево, запускает процесс reconciliation и применяет к реальному DOM только минимально необходимые изменения, обеспечивая эффективное и производительное обновление интерфейса."
  },
  {
    "id": "react-005",
    "topic": "react",
    "question": "В чём заключается проблема props drilling и как её обычно решают?",
    "answer": "Props drilling возникает, когда данные и колбэки передаются через несколько уровней компонентов, которые сами их не используют, что приводит к усложнению структуры кода и ухудшению читаемости и поддержки, а решается эта проблема с помощью React Context для глобально доступных данных, state-менеджеров, композиции компонентов или более грамотного подъёма состояния на уровень, где оно действительно необходимо."
  },
  {
    "id": "react-006",
    "topic": "react",
    "question": "Что такое React и зачем он нужен?",
    "answer": "React — это JavaScript-библиотека для построения пользовательских интерфейсов, основная задача которой заключается в создании декларативного, компонентного и предсказуемого UI; React позволяет разбивать интерфейс на независимые компоненты, эффективно обновлять отображение при изменении данных и управлять сложным состоянием приложения, что особенно полезно при разработке масштабируемых и динамических веб-приложений."
  },
  {
    "id": "react-007",
    "topic": "react",
    "question": "В чём разница между React и обычным JavaScript?",
    "answer": "Обычный JavaScript предполагает императивное управление DOM, где разработчик вручную описывает, какие элементы и как изменять, тогда как React использует декларативный подход, при котором разработчик описывает, как интерфейс должен выглядеть в зависимости от состояния, а React самостоятельно определяет и применяет необходимые изменения к DOM, снижая сложность кода и вероятность ошибок."
  },
  {
    "id": "react-008",
    "topic": "react",
    "question": "Что такое JSX?",
    "answer": "JSX — это синтаксическое расширение JavaScript, которое позволяет описывать структуру пользовательского интерфейса с помощью HTML-подобного синтаксиса прямо в коде, делая компоненты более читаемыми и декларативными, при этом на этапе сборки JSX компилируется в вызовы React.createElement и не используется браузером напрямую."
  },
  {
    "id": "react-009",
    "topic": "react",
    "question": "Можно ли писать React без JSX?",
    "answer": "Да, React можно писать без JSX, используя прямые вызовы React.createElement, однако такой код быстро становится громоздким и трудночитаемым, поэтому на практике JSX используется почти всегда, так как он значительно упрощает описание интерфейса и улучшает читаемость и поддержку кода."
  },
  {
    "id": "react-010",
    "topic": "react",
    "question": "Что такое компонент в React?",
    "answer": "Компонент в React — это независимая и переиспользуемая часть пользовательского интерфейса, которая принимает данные через props, может управлять собственным состоянием и возвращает описание UI в виде JSX или элементов React, что позволяет строить сложные интерфейсы из простых и логически изолированных блоков."
  },
  {
    "id": "react-011",
    "topic": "react",
    "question": "Чем отличаются функциональные и классовые компоненты?",
    "answer": "Классовые компоненты основаны на ES6-классах и используют методы жизненного цикла для управления логикой, тогда как функциональные компоненты представляют собой обычные функции и с появлением хуков получили доступ к состоянию, эффектам и контексту, что позволило упростить код, сократить количество шаблонных конструкций, улучшить переиспользование логики и сделать компоненты более предсказуемыми и удобными для тестирования."
  },
  {
    "id": "react-012",
    "topic": "react",
    "question": "Что такое props?",
    "answer": "Props — это входные данные компонента в React, которые передаются ему от родительского компонента и используются для конфигурации поведения и отображения UI, позволяя делать компоненты переиспользуемыми, декларативными и независимыми от конкретной реализации родителя."
  },
  {
    "id": "react-013",
    "topic": "react",
    "question": "Можно ли изменять props?",
    "answer": "Изменять props напрямую нельзя, так как они считаются неизменяемыми и принадлежат родительскому компоненту, а попытка их изменения нарушает однонаправленный поток данных; если компоненту нужно изменить данные, он должен вызвать колбэк, переданный через props, чтобы родитель обновил своё состояние и передал новые props вниз."
  },
  {
    "id": "react-014",
    "topic": "react",
    "question": "Что такое state?",
    "answer": "State — это внутреннее состояние компонента, предназначенное для хранения данных, которые могут изменяться со временем и напрямую влияют на отображение интерфейса, например значения форм, флаги загрузки или результаты запросов, при обновлении state React автоматически инициирует повторный рендер компонента."
  },
  {
    "id": "react-015",
    "topic": "react",
    "question": "Чем state отличается от props?",
    "answer": "Props используются для передачи данных от родительского компонента к дочернему и считаются неизменяемыми внутри компонента, тогда как state управляется самим компонентом и может изменяться со временем, при этом оба механизма участвуют в рендере, но выполняют разные роли в архитектуре и управлении данными приложения."
  },
  {
    "id": "react-016",
    "topic": "react",
    "question": "Что такое Virtual DOM?",
    "answer": "Virtual DOM — это абстрактное представление реального DOM в виде JavaScript-объектов, которое React использует для хранения текущего состояния интерфейса в памяти и для вычисления различий между предыдущим и новым состоянием UI, что позволяет оптимизировать обновления и минимизировать количество прямых операций с реальным DOM."
  },
  {
    "id": "react-017",
    "topic": "react",
    "question": "Как React понимает, что компонент нужно перерендерить?",
    "answer": "React принимает решение о перерендере компонента, когда изменяются его state или props, либо когда перерендеривается родительский компонент, после чего React повторно вызывает функцию компонента для вычисления нового виртуального DOM и определения необходимых обновлений интерфейса."
  },
  {
    "id": "react-018",
    "topic": "react",
    "question": "Что такое reconciliation?",
    "answer": "Reconciliation — это процесс сравнения нового виртуального DOM-дерева с предыдущей версией, в ходе которого React анализирует типы элементов и их ключи, чтобы определить, какие части дерева можно переиспользовать, а какие необходимо обновить или пересоздать, и затем применяет минимальный набор изменений к реальному DOM."
  },
  {
    "id": "react-019",
    "topic": "react",
    "question": "Что происходит при изменении state?",
    "answer": "При изменении state React ставит обновление в очередь, может объединить несколько обновлений для оптимизации, затем повторно вызывает компонент для создания нового виртуального DOM, запускает процесс reconciliation и после этого обновляет реальный DOM только в тех местах, где произошли изменения."
  },
  {
    "id": "react-020",
    "topic": "react",
    "question": "Чем отличается initial render от re-render?",
    "answer": "Initial render — это первый рендер компонента, при котором React создаёт DOM-узлы с нуля и монтирует их в документ, тогда как re-render происходит при изменении state или props и включает повторный вызов компонента, сравнение виртуального DOM и обновление только изменившихся частей интерфейса без полного пересоздания DOM."
  },
  {
    "id": "react-021",
    "topic": "react",
    "question": "Что такое хуки в React?",
    "answer": "Хуки в React — это специальные функции, которые позволяют использовать состояние, побочные эффекты и другую функциональность React внутри функциональных компонентов без использования классов, делая код более простым, декларативным и удобным для повторного использования логики между компонентами."
  },
  {
    "id": "react-022",
    "topic": "react",
    "question": "Зачем нужен useState?",
    "answer": "useState используется для добавления локального состояния в функциональный компонент и позволяет хранить и обновлять данные, которые влияют на рендер UI, при этом каждое обновление state инициирует повторный рендер компонента с актуальными значениями."
  },
  {
    "id": "react-023",
    "topic": "react",
    "question": "Зачем нужен useEffect?",
    "answer": "useEffect предназначен для выполнения побочных эффектов в функциональных компонентах, таких как загрузка данных, подписки на события, работа с таймерами или прямое взаимодействие с DOM, которые не должны выполняться непосредственно во время рендера компонента."
  },
  {
    "id": "react-024",
    "topic": "react",
    "question": "Когда вызывается useEffect?",
    "answer": "useEffect вызывается после того, как компонент был отрендерен и изменения были применены к DOM, а также может повторно вызываться после каждого последующего рендера в зависимости от указанных зависимостей, что позволяет синхронизировать внешний мир с состоянием компонента."
  },
  {
    "id": "react-025",
    "topic": "react",
    "question": "Что означает массив зависимостей в useEffect?",
    "answer": "Массив зависимостей в useEffect определяет, при изменении каких значений эффект должен быть выполнен повторно, при пустом массиве эффект выполнится только один раз после монтирования, а при его отсутствии эффект будет запускаться после каждого рендера компонента."
  },
  {
    "id": "react-026",
    "topic": "react",
    "question": "Что означает массив зависимостей в useEffect?",
    "answer": "Массив зависимостей в useEffect указывает React, при изменении каких значений эффект должен быть выполнен повторно, при этом React сравнивает значения зависимостей между рендерами по ссылке, и если хотя бы одно из них изменилось, эффект перезапускается, что позволяет точно контролировать момент выполнения побочных эффектов."
  },
  {
    "id": "react-027",
    "topic": "react",
    "question": "Что будет, если не передать зависимости в useEffect?",
    "answer": "Если не передать массив зависимостей в useEffect, эффект будет выполняться после каждого рендера компонента, что может привести к лишним вызовам побочных эффектов, ухудшению производительности и даже к бесконечным циклам обновления при изменении state внутри эффекта."
  },
  {
    "id": "react-028",
    "topic": "react",
    "question": "Можно ли использовать хуки в условиях или циклах?",
    "answer": "Использовать хуки внутри условий, циклов или вложенных функций нельзя, так как React полагается на строгий порядок вызова хуков между рендерами, и любое условное выполнение может привести к несоответствию этого порядка и некорректной работе состояния."
  },
  {
    "id": "react-029",
    "topic": "react",
    "question": "Почему существуют правила хуков?",
    "answer": "Правила хуков существуют для того, чтобы React мог корректно сопоставлять вызовы хуков с их внутренним состоянием между рендерами, так как React не использует имена хуков, а опирается исключительно на порядок их вызова внутри компонента."
  },
  {
    "id": "react-030",
    "topic": "react",
    "question": "Что такое кастомный хук?",
    "answer": "Кастомный хук — это обычная JavaScript-функция, имя которой начинается с use и которая внутри себя использует другие хуки React, позволяя инкапсулировать и переиспользовать логику состояния и эффектов между разными компонентами."
  },
  {
    "id": "react-031",
    "topic": "react",
    "question": "Когда стоит создавать кастомный хук?",
    "answer": "Кастомный хук стоит создавать, когда одна и та же логика работы со state, эффектами или подписками повторяется в нескольких компонентах, либо когда компонент становится перегруженным логикой и её нужно вынести для улучшения читаемости, переиспользования и тестируемости."
  },
  {
    "id": "react-032",
    "topic": "react",
    "question": "Как обрабатываются события в React?",
    "answer": "События в React обрабатываются с помощью обработчиков, которые передаются в JSX в виде функций, например onClick или onChange, при этом React использует декларативный подход, где логика обработки события описывается в компоненте, а сам React берёт на себя подписку и управление жизненным циклом этих событий."
  },
  {
    "id": "react-033",
    "topic": "react",
    "question": "Чем синтетические события отличаются от нативных?",
    "answer": "Синтетические события в React представляют собой обёртку над нативными событиями браузера и обеспечивают единый интерфейс работы с событиями во всех браузерах, при этом React использует механизм event delegation и нормализует поведение событий, чтобы разработчику не приходилось учитывать браузерные различия."
  },
  {
    "id": "react-034",
    "topic": "react",
    "question": "Как передать параметр в обработчик события?",
    "answer": "Параметр в обработчик события передаётся с помощью оборачивания вызова функции в стрелочную функцию или через bind, например onClick={() => handleClick(id)}, что позволяет передать дополнительные данные, не вызывая обработчик сразу при рендере компонента."
  },
  {
    "id": "react-035",
    "topic": "react",
    "question": "Что такое controlled component?",
    "answer": "Controlled component — это компонент формы, значение которого полностью контролируется состоянием React, где текущее значение хранится в state и обновляется через обработчики событий, что позволяет централизованно управлять данными формы, выполнять валидацию и синхронизировать UI с состоянием приложения."
  },
  {
    "id": "react-036",
    "topic": "react",
    "question": "Что такое uncontrolled component?",
    "answer": "Uncontrolled component — это компонент формы, в котором значение хранится непосредственно в DOM, а доступ к нему осуществляется через refs, такой подход используется реже и подходит для простых сценариев, где не требуется полный контроль состояния формы со стороны React."
  },
  {
    "id": "react-037",
    "topic": "react",
    "question": "Как работать с формами в React?",
    "answer": "Работа с формами в React обычно строится через обработчики событий и состояние компонента, где значения полей ввода связываются с state, обновляются через onChange и используются для управления отображением, отправкой данных и валидацией, что позволяет полностью контролировать поведение формы на уровне приложения."
  },
  {
    "id": "react-038",
    "topic": "react",
    "question": "Как хранить данные формы?",
    "answer": "Данные формы чаще всего хранятся в state компонента с помощью useState или useReducer, где каждое поле формы соответствует отдельному значению или свойству объекта, что позволяет централизованно управлять данными, отслеживать изменения и использовать их при валидации и отправке формы."
  },
  {
    "id": "react-039",
    "topic": "react",
    "question": "Чем controlled input отличается от uncontrolled?",
    "answer": "Controlled input управляется состоянием React, где значение поля задаётся через state и обновляется через onChange, тогда как uncontrolled input хранит значение внутри DOM и доступ к нему осуществляется через refs, что делает controlled-подход более предсказуемым и предпочтительным для сложных форм."
  },
  {
    "id": "react-040",
    "topic": "react",
    "question": "Как валидировать форму?",
    "answer": "Валидация формы в React обычно реализуется через проверку значений, хранящихся в state, либо во время ввода, либо при отправке формы, с использованием кастомной логики, регулярных выражений или сторонних библиотек, при этом результаты валидации используются для отображения ошибок и управления доступностью отправки формы."
  },
  {
    "id": "react-041",
    "topic": "react",
    "question": "Что такое React.memo?",
    "answer": "React.memo — это функция высшего порядка, которая позволяет мемоизировать функциональный компонент и предотвращает его повторный рендер, если его props не изменились, что помогает сократить количество лишних перерендеров и повысить производительность при работе с тяжёлыми или часто обновляемыми компонентами."
  },
  {
    "id": "react-042",
    "topic": "react",
    "question": "Зачем нужен useCallback?",
    "answer": "useCallback используется для мемоизации функции и возвращает одну и ту же ссылку на функцию между рендерами, пока не изменятся зависимости, что особенно полезно при передаче колбэков в дочерние компоненты, оптимизированные с помощью React.memo, чтобы избежать лишних перерендеров."
  },
  {
    "id": "react-043",
    "topic": "react",
    "question": "Зачем нужен useMemo?",
    "answer": "useMemo применяется для мемоизации вычисляемых значений и позволяет избежать повторного выполнения дорогостоящих вычислений при каждом рендере, пересчитывая значение только при изменении указанных зависимостей, что может существенно улучшить производительность в сложных сценариях."
  },
  {
    "id": "react-044",
    "topic": "react",
    "question": "В чём разница между useCallback и useMemo?",
    "answer": "useCallback мемоизирует функцию и возвращает стабильную ссылку на неё, тогда как useMemo мемоизирует результат вычисления и возвращает само значение, при этом useCallback по сути является частным случаем useMemo, оптимизированным для функций."
  },
  {
    "id": "react-045",
    "topic": "react",
    "question": "Когда оптимизация в React может навредить?",
    "answer": "Оптимизация в React может навредить, если использовать мемоизацию без реальной необходимости, так как она усложняет код, увеличивает когнитивную нагрузку и может даже ухудшить производительность из-за дополнительных сравнений зависимостей и хранения мемоизированных значений."
  },
  {
    "id": "react-046",
    "topic": "react",
    "question": "Что такое key и зачем он нужен?",
    "answer": "Key — это специальный атрибут, который используется React при рендере списков для уникальной идентификации элементов, позволяя корректно сопоставлять элементы между рендерами, сохранять их состояние и выполнять эффективные обновления без лишних пересозданий DOM-узлов."
  },
  {
    "id": "react-047",
    "topic": "react",
    "question": "Что такое lifting state up?",
    "answer": "Lifting state up — это архитектурный приём в React, при котором состояние поднимается из дочерних компонентов в ближайший общий родительский компонент, чтобы несколько компонентов могли использовать и синхронно обновлять одни и те же данные через props."
  },
  {
    "id": "react-048",
    "topic": "react",
    "question": "Что такое prop drilling?",
    "answer": "Prop drilling — это ситуация, когда данные и колбэки передаются через несколько уровней компонентов, которые сами эти данные не используют, что приводит к усложнению структуры компонентов и ухудшению читаемости и поддержки кода."
  },
  {
    "id": "react-049",
    "topic": "react",
    "question": "Как решить проблему prop drilling?",
    "answer": "Проблема prop drilling решается с помощью React Context для глобально доступных данных, использования state-менеджеров, композиции компонентов или более грамотного подъёма состояния на уровень, где оно действительно необходимо, чтобы сократить глубину передачи props."
  },
  {
    "id": "react-050",
    "topic": "react",
    "question": "Что такое Context API?",
    "answer": "Context API — это встроенный механизм React, который позволяет передавать данные через дерево компонентов без явной передачи props на каждом уровне, что удобно для хранения глобальных данных, таких как тема, язык интерфейса или данные авторизации."
  },
  {
    "id": "react-051",
    "topic": "react",
    "question": "Когда не стоит использовать Context?",
    "answer": "Context не стоит использовать для часто изменяющихся данных или локального состояния, так как каждое обновление контекста вызывает перерендер всех подписанных компонентов, что может негативно сказаться на производительности и усложнить архитектуру приложения."
  },
  {
    "id": "react-052",
    "topic": "react",
    "question": "Что такое composition в React?",
    "answer": "Composition в React — это подход к построению интерфейса, при котором сложные компоненты создаются путём комбинирования простых компонентов через props и children, что позволяет гибко переиспользовать логику и UI без жёсткой иерархии наследования."
  },
  {
    "id": "react-053",
    "topic": "react",
    "question": "Как делать HTTP-запросы в React?",
    "answer": "HTTP-запросы в React обычно выполняют внутри useEffect или в обработчиках событий, используя fetch или библиотеки вроде axios, при этом важно не делать запросы прямо в теле рендера, чтобы избежать повторных запросов на каждом ререндере, а результаты запроса сохранять в state и на их основе отображать UI."
  },
  {
    "id": "react-054",
    "topic": "react",
    "question": "Где лучше делать запросы: в компоненте или отдельно?",
    "answer": "Запросы можно делать в компоненте для простых случаев, но чаще лучше выносить сетевую логику в отдельный слой (api-клиент, сервисы, hooks или data-fetching библиотеку), чтобы улучшить переиспользуемость, тестируемость и разделение ответственности, а компоненту оставить роль отображения и управления состояниями загрузки."
  },
  {
    "id": "react-055",
    "topic": "react",
    "question": "Как обрабатывать loading и error состояния?",
    "answer": "Loading и error обычно обрабатывают через отдельные поля состояния, например isLoading и error, где перед запросом включают loading, при успехе сохраняют данные и выключают loading, а при ошибке записывают объект ошибки и показывают пользователю сообщение, при этом важно также предусмотреть повтор запроса и корректные состояния для пустых данных."
  },
  {
    "id": "react-056",
    "topic": "react",
    "question": "Что делать при размонтировании компонента и незавершённом запросе?",
    "answer": "При размонтировании компонента важно предотвратить попытку обновить state после завершения запроса, для этого обычно используют AbortController для отмены fetch в cleanup-функции useEffect или флаг актуальности запроса, а при использовании библиотек вроде React Query отмена и управление жизненным циклом запросов часто решаются автоматически."
  },
  {
    "id": "react-057",
    "topic": "react",
    "question": "Какие этапы жизненного цикла компонента ты знаешь?",
    "answer": "Жизненный цикл компонента в React включает этапы монтирования, обновления и размонтирования, где на этапе монтирования компонент создаётся и вставляется в DOM, на этапе обновления происходит повторный рендер при изменении state или props, а на этапе размонтирования компонент удаляется из DOM и должна выполняться очистка ресурсов."
  },
  {
    "id": "react-058",
    "topic": "react",
    "question": "Какие аналоги lifecycle методов есть в хуках?",
    "answer": "В функциональных компонентах аналоги lifecycle методов реализуются с помощью useEffect и useLayoutEffect, где useEffect с пустым массивом зависимостей соответствует componentDidMount, cleanup-функция useEffect соответствует componentWillUnmount, а useEffect с зависимостями используется для обработки обновлений, аналогично componentDidUpdate."
  },
  {
    "id": "react-059",
    "topic": "react",
    "question": "Когда компонент монтируется?",
    "answer": "Компонент считается смонтированным в момент, когда React впервые вызывает функцию компонента, создаёт соответствующие DOM-узлы на основе виртуального DOM и вставляет их в реальный DOM, после чего можно выполнять побочные эффекты, связанные с доступом к DOM или внешними ресурсами."
  },
  {
    "id": "react-060",
    "topic": "react",
    "question": "Когда компонент размонтируется?",
    "answer": "Компонент размонтируется, когда React удаляет его из дерева компонентов и из реального DOM, например при изменении условий рендера или переходе на другую страницу, и в этот момент необходимо освобождать ресурсы, отменять подписки и запросы, чтобы избежать утечек памяти."
  },
  {
    "id": "react-061",
    "topic": "react",
    "question": "Что такое SPA?",
    "answer": "SPA (Single Page Application) — это веб-приложение, в котором загрузка HTML-документа происходит один раз, а дальнейшая навигация и обновление контента выполняются на клиенте с помощью JavaScript без полной перезагрузки страницы, что обеспечивает более быстрый и плавный пользовательский опыт."
  },
  {
    "id": "react-062",
    "topic": "react",
    "question": "Как работает роутинг в React?",
    "answer": "Роутинг в React обычно реализуется на стороне клиента с помощью библиотек вроде React Router, которые отслеживают изменения URL через History API браузера и в зависимости от текущего маршрута отображают соответствующие компоненты без перезагрузки страницы."
  },
  {
    "id": "react-063",
    "topic": "react",
    "question": "Чем отличается client-side routing от server-side routing?",
    "answer": "Client-side routing выполняется в браузере и изменяет отображаемый контент без перезагрузки страницы, тогда как server-side routing обрабатывается сервером, где каждый URL приводит к загрузке нового HTML-документа, что влияет на производительность и пользовательский опыт."
  },
  {
    "id": "react-064",
    "topic": "react",
    "question": "Что такое SSR?",
    "answer": "SSR (Server-Side Rendering) — это подход, при котором HTML-страница генерируется на сервере для каждого запроса и отправляется в браузер уже с готовым контентом, что улучшает время первого отображения и SEO по сравнению с чистым клиентским рендерингом."
  },
  {
    "id": "react-065",
    "topic": "react",
    "question": "В чём разница между CSR и SSR?",
    "answer": "При CSR (Client-Side Rendering) HTML создаётся в браузере с помощью JavaScript после загрузки приложения, тогда как при SSR HTML формируется на сервере и сразу отправляется пользователю, что ускоряет первый рендер, но усложняет архитектуру и нагрузку на сервер."
  },
  {
    "id": "react-066",
    "topic": "react",
    "question": "Зачем нужен Next.js?",
    "answer": "Next.js — это фреймворк поверх React, который упрощает создание приложений с SSR, SSG и гибридным рендерингом, предоставляет встроенный роутинг, оптимизацию производительности и удобные инструменты для работы с SEO, что делает его подходящим для продакшен-приложений."
  },
  {
    "id": "react-067",
    "topic": "react",
    "question": "Почему компонент может ререндериться слишком часто?",
    "answer": "Компонент может ререндериться слишком часто из-за частых обновлений state или props, перерендеров родительского компонента, создания новых ссылок на функции или объекты при каждом рендере, отсутствия мемоизации и неправильного использования хуков, что в совокупности приводит к лишним вычислениям и снижению производительности."
  },
  {
    "id": "react-068",
    "topic": "react",
    "question": "Как предотвратить лишние ререндеры?",
    "answer": "Лишние ререндеры предотвращают с помощью React.memo, useCallback и useMemo, корректного использования key, подъёма состояния только при необходимости, разделения компонентов на более мелкие и избегания создания новых объектов и функций при каждом рендере без необходимости."
  },
  {
    "id": "react-069",
    "topic": "react",
    "question": "Почему нельзя использовать index как key?",
    "answer": "Index нельзя использовать как key, потому что при изменении порядка элементов, добавлении или удалении React может неправильно сопоставить элементы между рендерами, что приводит к багам, потере состояния компонентов и некорректному обновлению интерфейса."
  },
  {
    "id": "react-070",
    "topic": "react",
    "question": "Что будет, если напрямую изменить state?",
    "answer": "При прямом изменении state React не узнаёт об изменении данных и не запускает повторный рендер, что приводит к несинхронизированному UI, трудноуловимым багам и нарушению принципов предсказуемости работы компонентов."
  },
  {
    "id": "react-071",
    "topic": "react",
    "question": "Как передать данные от дочернего компонента к родительскому?",
    "answer": "Данные от дочернего компонента к родительскому передаются через колбэк-функцию, переданную в props, которую дочерний компонент вызывает с нужными данными, после чего родитель обновляет свой state и передаёт новые props вниз."
  },
  {
    "id": "react-072",
    "topic": "react",
    "question": "Как организовать глобальное состояние?",
    "answer": "Глобальное состояние в React можно организовать с помощью Context API для простых сценариев, специализированных state-менеджеров вроде Redux, Zustand или MobX для более сложных случаев, либо библиотек для работы с серверным состоянием, таких как React Query."
  },
  {
    "id": "react-073",
    "topic": "react",
    "question": "Что ты выберешь: Context или Redux и почему?",
    "answer": "Выбор между Context и Redux зависит от задачи: Context подходит для простых и редко изменяющихся глобальных данных, таких как тема или язык, тогда как Redux лучше использовать для сложного состояния с частыми обновлениями, строгой архитектурой и необходимостью дебага и масштабирования."
  },
  {
    "id": "react-074",
    "topic": "react",
    "question": "Как бы ты структурировал большой React-проект?",
    "answer": "Большой React-проект обычно структурируют по фичам или доменам, разделяя код на модули с компонентами, хуками, сервисами и состоянием, вынося общие части в shared-слой и соблюдая принципы разделения ответственности и масштабируемости."
  },
  {
    "id": "react-075",
    "topic": "react",
    "question": "Какие ошибки чаще всего допускают React-разработчики?",
    "answer": "React-разработчики часто допускают ошибки, такие как неправильное использование хуков и зависимостей useEffect, чрезмерная оптимизация, прямое изменение state, использование index как key, отсутствие разделения логики и UI, а также неправильная работа с асинхронными эффектами."
  },
  {
    "id": "react-076",
    "topic": "react",
    "question": "Что происходит, если в useEffect изменить state без зависимостей?",
    "answer": "Если в useEffect изменить state без указания массива зависимостей, эффект будет выполняться после каждого рендера, что приведёт к бесконечному циклу рендеров и обновлений состояния, потенциально полностью блокируя приложение."
  },
  {
    "id": "js-001",
    "topic": "javascript",
    "question": "Что такое JavaScript?",
    "answer": "JavaScript — это высокоуровневый интерпретируемый язык программирования, который используется для создания интерактивного поведения в веб-приложениях, поддерживает событийную модель, асинхронность и может выполняться как в браузере, так и на сервере."
  },
  {
    "id": "js-002",
    "topic": "javascript",
    "question": "Где и как выполняется JavaScript?",
    "answer": "JavaScript выполняется в среде выполнения, такой как браузер или Node.js, где код интерпретируется JavaScript-движком, например V8, который читает, компилирует и выполняет код, обеспечивая доступ к Web API или серверным возможностям."
  },
  {
    "id": "js-003",
    "topic": "javascript",
    "question": "Чем var отличается от let и const?",
    "answer": "var имеет функциональную область видимости и подвержен hoisting с инициализацией undefined, тогда как let и const имеют блочную область видимости, не доступны до объявления, при этом const запрещает переназначение переменной, но не изменение содержимого объектов."
  },
  {
    "id": "js-004",
    "topic": "javascript",
    "question": "Что такое типы данных в JavaScript?",
    "answer": "Типы данных в JavaScript определяют, какие значения может принимать переменная и какие операции с ними возможны, при этом язык поддерживает как примитивные типы, так и объекты для хранения более сложных структур данных."
  },
  {
    "id": "js-005",
    "topic": "javascript",
    "question": "Какие типы данных являются примитивами?",
    "answer": "К примитивным типам данных в JavaScript относятся string, number, boolean, null, undefined, symbol и bigint, которые являются неизменяемыми и передаются по значению, а не по ссылке."
  },
  {
    "id": "js-006",
    "topic": "javascript",
    "question": "Чем null отличается от undefined?",
    "answer": "undefined означает, что переменная была объявлена, но ей не присвоено значение, тогда как null является явным значением, которое используется разработчиком для обозначения отсутствия значения."
  },
  {
    "id": "js-007",
    "topic": "javascript",
    "question": "Что такое NaN?",
    "answer": "NaN означает Not-a-Number и представляет собой специальное числовое значение, которое возникает в результате некорректных математических операций, например при попытке преобразовать нечисловую строку в число."
  },
  {
    "id": "js-008",
    "topic": "javascript",
    "question": "Как проверить тип значения?",
    "answer": "Тип значения в JavaScript можно проверить с помощью оператора typeof, метода Array.isArray для массивов, оператора instanceof или сравнения с null, так как typeof null возвращает object."
  },
  {
    "id": "js-009",
    "topic": "javascript",
    "question": "Что такое динамическая типизация?",
    "answer": "Динамическая типизация означает, что тип переменной в JavaScript определяется во время выполнения программы и может изменяться в процессе работы, так как переменная не привязана к одному типу данных."
  },
  {
    "id": "js-010",
    "topic": "javascript",
    "question": "Что такое строгий режим (\"use strict\")?",
    "answer": "Строгий режим в JavaScript включает более жёсткие правила выполнения кода, предотвращает использование потенциально опасных конструкций, запрещает неявное создание глобальных переменных и помогает находить ошибки на раннем этапе."
  },
  {
    "id": "js-011",
    "topic": "javascript",
    "question": "Чем == отличается от ===?",
    "answer": "Оператор == выполняет неявное приведение типов перед сравнением значений, что может приводить к неожиданным результатам, тогда как === сравнивает значения строго без приведения типов, проверяя и тип, и значение, поэтому === считается более безопасным и предпочтительным."
  },
  {
    "id": "js-012",
    "topic": "javascript",
    "question": "Что такое неявное приведение типов?",
    "answer": "Неявное приведение типов — это автоматическое преобразование одного типа данных в другой, которое JavaScript выполняет при операциях сравнения, арифметики или логических выражениях, что может упрощать код, но часто становится источником ошибок."
  },
  {
    "id": "js-013",
    "topic": "javascript",
    "question": "Какие значения приводятся к false?",
    "answer": "К false при приведении к boolean приводятся следующие значения: false, 0, -0, 0n, пустая строка, null, undefined и NaN, все остальные значения считаются truthy."
  },
  {
    "id": "js-014",
    "topic": "javascript",
    "question": "Что вернёт Boolean([]) и почему?",
    "answer": "Boolean([]) вернёт true, потому что массив является объектом, а все объекты в JavaScript при приведении к boolean считаются truthy независимо от их содержимого."
  },
  {
    "id": "js-015",
    "topic": "javascript",
    "question": "Что произойдёт при сложении строки и числа?",
    "answer": "При сложении строки и числа JavaScript приведёт число к строке и выполнит конкатенацию, так как оператор + при наличии строки работает как оператор объединения строк."
  },
  {
    "id": "js-016",
    "topic": "javascript",
    "question": "Как работает оператор +?",
    "answer": "Оператор + в JavaScript выполняет либо арифметическое сложение, либо конкатенацию строк, и если хотя бы один из операндов является строкой, происходит приведение второго операнда к строке и выполняется объединение."
  },
  {
    "id": "js-017",
    "topic": "javascript",
    "question": "Чем отличается Object.is от ===?",
    "answer": "Object.is работает почти так же, как ===, но корректно различает NaN и NaN как равные и считает +0 и -0 разными значениями, тогда как === считает NaN неравным самому себе и +0 и -0 равными."
  },
  {
    "id": "js-018",
    "topic": "javascript",
    "question": "Что такое scope?",
    "answer": "Scope — это область видимости переменных и функций в JavaScript, которая определяет, где в коде можно получить доступ к объявленным идентификаторам и какие значения будут использованы при обращении к ним."
  },
  {
    "id": "js-019",
    "topic": "javascript",
    "question": "Какие виды scope существуют?",
    "answer": "В JavaScript существуют глобальный scope, функциональный scope и блочный scope, где глобальный доступен везде, функциональный ограничен телом функции, а блочный применяется к конструкциям вроде if, for и доступен для let и const."
  },
  {
    "id": "js-020",
    "topic": "javascript",
    "question": "Что такое lexical scope?",
    "answer": "Lexical scope — это правило, согласно которому область видимости переменных определяется местом их объявления в исходном коде, а не местом вызова функции, поэтому вложенные функции имеют доступ к переменным внешних областей."
  },
  {
    "id": "js-021",
    "topic": "javascript",
    "question": "Что такое hoisting?",
    "answer": "Hoisting — это механизм JavaScript, при котором объявления переменных и функций обрабатываются до выполнения кода, из-за чего функции и переменные, объявленные через var, доступны до строки их объявления в коде."
  },
  {
    "id": "js-022",
    "topic": "javascript",
    "question": "Что поднимается при hoisting?",
    "answer": "При hoisting поднимаются объявления функций целиком и объявления переменных, при этом переменные, объявленные через var, инициализируются значением undefined, а let и const поднимаются, но остаются недоступными до фактического объявления из-за temporal dead zone."
  },
  {
    "id": "js-023",
    "topic": "javascript",
    "question": "Что такое замыкание?",
    "answer": "Замыкание — это механизм, при котором функция запоминает и имеет доступ к переменным из своей внешней лексической области видимости даже после того, как внешняя функция завершила выполнение."
  },
  {
    "id": "js-024",
    "topic": "javascript",
    "question": "Где на практике используются замыкания?",
    "answer": "Замыкания на практике используются для инкапсуляции данных, создания приватных переменных, реализации фабричных функций, мемоизации, обработки событий и сохранения состояния между вызовами функций."
  },
  {
    "id": "js-025",
    "topic": "javascript",
    "question": "Какие проблемы могут быть с замыканиями?",
    "answer": "Проблемы с замыканиями могут возникать из-за удержания ссылок на переменные и объекты, что приводит к утечкам памяти, а также из-за непонимания области видимости, что может вызывать логические ошибки и неожиданные значения."
  },
  {
    "id": "js-026",
    "topic": "javascript",
    "question": "Какие способы объявления функций ты знаешь?",
    "answer": "В JavaScript функции можно объявлять с помощью function declaration, function expression, arrow function, а также создавать методы объектов и классов, при этом каждый способ имеет особенности области видимости, hoisting и контекста this."
  },
  {
    "id": "js-027",
    "topic": "javascript",
    "question": "Чем function declaration отличается от function expression?",
    "answer": "Function declaration поднимается целиком при hoisting и может быть вызвана до места объявления в коде, тогда как function expression создаётся во время выполнения и доступна только после присваивания переменной."
  },
  {
    "id": "js-028",
    "topic": "javascript",
    "question": "Что такое arrow function?",
    "answer": "Arrow function — это сокращённый синтаксис объявления функции, введённый в ES6, который упрощает запись функций и не создаёт собственного контекста this, arguments, super и new.target."
  },
  {
    "id": "js-029",
    "topic": "javascript",
    "question": "Чем arrow function отличается от обычной функции?",
    "answer": "Arrow function отличается тем, что не имеет собственного this и берёт его из внешнего лексического окружения, не поддерживает вызов через new и не имеет собственного arguments, тогда как обычная функция формирует собственный контекст выполнения."
  },
  {
    "id": "js-030",
    "topic": "javascript",
    "question": "Что такое параметры по умолчанию?",
    "answer": "Параметры по умолчанию позволяют задавать значения аргументов функции прямо в сигнатуре, которые будут использоваться в случае, если соответствующий аргумент не был передан или равен undefined."
  },
  {
    "id": "js-031",
    "topic": "javascript",
    "question": "Что такое rest-параметры?",
    "answer": "Rest-параметры позволяют собрать произвольное количество аргументов функции в массив с помощью оператора ..., что делает работу с переменным числом аргументов более удобной и предсказуемой."
  },
  {
    "id": "js-032",
    "topic": "javascript",
    "question": "Что такое arguments?",
    "answer": "arguments — это псевдомассив, доступный внутри обычных функций, который содержит все переданные аргументы, но не поддерживается в arrow function и считается устаревшим по сравнению с rest-параметрами."
  },
  {
    "id": "js-033",
    "topic": "javascript",
    "question": "Что такое чистая функция?",
    "answer": "Чистая функция — это функция, которая при одинаковых входных данных всегда возвращает одинаковый результат и не имеет побочных эффектов, то есть не изменяет внешнее состояние и не зависит от него."
  },
  {
    "id": "js-034",
    "topic": "javascript",
    "question": "Что такое this?",
    "answer": "this — это специальное ключевое слово в JavaScript, которое указывает на объект, в контексте которого была вызвана функция, и используется для доступа к данным и методам этого объекта во время выполнения кода."
  },
  {
    "id": "js-035",
    "topic": "javascript",
    "question": "От чего зависит значение this?",
    "answer": "Значение this зависит от способа вызова функции: при вызове как метода объекта this указывает на объект, при обычном вызове функции — на глобальный объект или undefined в строгом режиме, при использовании new — на создаваемый экземпляр, а при call, apply и bind — на явно переданный объект."
  },
  {
    "id": "js-036",
    "topic": "javascript",
    "question": "Как работает this в arrow function?",
    "answer": "В arrow function this не создаётся собственный и берётся из внешнего лексического окружения, то есть равен значению this в месте объявления функции, а не в месте её вызова."
  },
  {
    "id": "js-037",
    "topic": "javascript",
    "question": "Что делают call, apply и bind?",
    "answer": "Методы call, apply и bind позволяют явно задать значение this для функции, где call и apply сразу вызывают функцию с указанным контекстом, а bind возвращает новую функцию с навсегда привязанным this."
  },
  {
    "id": "js-038",
    "topic": "javascript",
    "question": "В чём разница между call и apply?",
    "answer": "Разница между call и apply заключается в способе передачи аргументов, так как call принимает аргументы по отдельности, а apply принимает массив аргументов, при этом оба метода сразу вызывают функцию с заданным this."
  },
  {
    "id": "js-039",
    "topic": "javascript",
    "question": "Можно ли изменить this у arrow function?",
    "answer": "Изменить this у arrow function нельзя, так как она не имеет собственного контекста и всегда использует this из внешней области видимости, поэтому методы call, apply и bind на неё не влияют."
  },
  {
    "id": "js-040",
    "topic": "javascript",
    "question": "Как создать объект в JavaScript?",
    "answer": "Объект в JavaScript можно создать с помощью литерала объекта {}, конструктора Object, функции-конструктора с оператором new, метода Object.create для явного указания прототипа или с использованием синтаксиса class, который под капотом также работает через прототипы."
  },
  {
    "id": "js-041",
    "topic": "javascript",
    "question": "Что такое прототип?",
    "answer": "Прототип — это объект, из которого другие объекты могут наследовать свойства и методы, и он используется JavaScript для реализации наследования и повторного использования функциональности."
  },
  {
    "id": "js-042",
    "topic": "javascript",
    "question": "Что такое prototype chain?",
    "answer": "Prototype chain — это цепочка прототипов, по которой JavaScript ищет свойство или метод, начиная с самого объекта и поднимаясь по его прототипам до Object.prototype или null."
  },
  {
    "id": "js-043",
    "topic": "javascript",
    "question": "Как работает наследование в JavaScript?",
    "answer": "Наследование в JavaScript реализуется через прототипы, где один объект ссылается на другой как на свой прототип, благодаря чему он получает доступ к его свойствам и методам без их копирования."
  },
  {
    "id": "js-044",
    "topic": "javascript",
    "question": "Что такое __proto__?",
    "answer": "__proto__ — это внутреннее свойство объекта, которое указывает на его прототип и используется движком JavaScript для поиска свойств в prototype chain, при этом напрямую работать с ним не рекомендуется."
  },
  {
    "id": "js-045",
    "topic": "javascript",
    "question": "Чем класс отличается от функции-конструктора?",
    "answer": "Класс является синтаксическим сахаром над функцией-конструктором и прототипами, предоставляя более читаемый и структурированный синтаксис, при этом под капотом JavaScript продолжает использовать прототипное наследование."
  },
  {
    "id": "js-046",
    "topic": "javascript",
    "question": "Что такое class и что он делает под капотом?",
    "answer": "Class в JavaScript — это синтаксический сахар, который упрощает создание функций-конструкторов и работу с прототипами, автоматически добавляя методы в prototype и настраивая наследование через prototype chain без изменения базовой модели языка."
  },
  {
    "id": "js-047",
    "topic": "javascript",
    "question": "Как скопировать массив?",
    "answer": "Массив можно скопировать с помощью spread-оператора [...arr], метода slice(), Array.from() или map, при этом такие способы создают поверхностную копию, где вложенные объекты продолжают передаваться по ссылке."
  },
  {
    "id": "js-048",
    "topic": "javascript",
    "question": "Чем map отличается от forEach?",
    "answer": "Метод map возвращает новый массив с результатами выполнения функции для каждого элемента и используется для преобразования данных, тогда как forEach просто выполняет функцию для каждого элемента и ничего не возвращает, поэтому чаще применяется для побочных эффектов."
  },
  {
    "id": "js-049",
    "topic": "javascript",
    "question": "Чем filter отличается от find?",
    "answer": "filter возвращает новый массив со всеми элементами, удовлетворяющими условию, тогда как find возвращает только первый найденный элемент или undefined, поэтому filter используют для выборки, а find — для поиска одного значения."
  },
  {
    "id": "js-050",
    "topic": "javascript",
    "question": "Что делает reduce?",
    "answer": "Метод reduce последовательно обрабатывает элементы массива и сводит их к одному значению, которое может быть числом, объектом, массивом или любым другим типом, благодаря чему reduce используется для агрегации данных и сложных преобразований."
  },
  {
    "id": "js-051",
    "topic": "javascript",
    "question": "Мутируют ли массив методы push, splice, sort?",
    "answer": "Методы push, splice и sort мутируют исходный массив, так как изменяют его содержимое напрямую, поэтому при работе с иммутабельными данными их следует использовать осторожно или заменять немутирующими альтернативами."
  },
  {
    "id": "js-052",
    "topic": "javascript",
    "question": "Как проверить, что значение — массив?",
    "answer": "Проверить, что значение является массивом, надёжнее всего с помощью метода Array.isArray, так как typeof возвращает object и не позволяет отличить массив от обычного объекта."
  },
  {
    "id": "js-053",
    "topic": "javascript",
    "question": "Чем массив отличается от объекта?",
    "answer": "Массив является упорядоченной коллекцией значений с числовыми индексами и встроенными методами для работы с последовательностями, тогда как объект представляет собой неупорядоченный набор пар ключ-значение и используется для описания сущностей и структур данных."
  },
  {
    "id": "js-054",
    "topic": "javascript",
    "question": "Что такое асинхронность в JavaScript?",
    "answer": "Асинхронность в JavaScript — это способность выполнять долгие операции, такие как запросы к серверу или таймеры, без блокировки основного потока выполнения, позволяя приложению оставаться отзывчивым и обрабатывать другие задачи параллельно."
  },
  {
    "id": "js-055",
    "topic": "javascript",
    "question": "Что такое callback?",
    "answer": "Callback — это функция, которая передаётся как аргумент другой функции и вызывается позже, обычно после завершения асинхронной операции, для обработки её результата."
  },
  {
    "id": "js-056",
    "topic": "javascript",
    "question": "Какие проблемы есть у callback?",
    "answer": "Основные проблемы callback — это callback hell из-за глубокой вложенности, сложность обработки ошибок, плохая читаемость кода и трудности с масштабированием асинхронной логики."
  },
  {
    "id": "js-057",
    "topic": "javascript",
    "question": "Что такое Promise?",
    "answer": "Promise — это объект, представляющий результат асинхронной операции, который позволяет описывать последовательность асинхронных действий и обрабатывать их результаты или ошибки более читаемым и управляемым способом."
  },
  {
    "id": "js-058",
    "topic": "javascript",
    "question": "Какие состояния есть у Promise?",
    "answer": "Promise может находиться в трёх состояниях: pending — ожидание результата, fulfilled — успешное выполнение с результатом и rejected — завершение с ошибкой."
  },
  {
    "id": "js-059",
    "topic": "javascript",
    "question": "Что такое async / await?",
    "answer": "async / await — это синтаксический сахар над Promise, который позволяет писать асинхронный код в стиле синхронного, делая его более читаемым и упрощая работу с последовательными асинхронными операциями."
  },
  {
    "id": "js-060",
    "topic": "javascript",
    "question": "Чем async / await лучше Promise chaining?",
    "answer": "async / await улучшает читаемость кода, снижает уровень вложенности, упрощает обработку ошибок через try/catch и делает асинхронную логику более похожей на обычный синхронный код по сравнению с цепочками then."
  },
  {
    "id": "js-061",
    "topic": "javascript",
    "question": "Как обрабатывать ошибки в асинхронном коде?",
    "answer": "Ошибки в асинхронном коде обрабатываются с помощью catch у Promise или конструкции try/catch при использовании async / await, при этом важно учитывать как синхронные, так и асинхронные исключения."
  },
  {
    "id": "js-062",
    "topic": "javascript",
    "question": "Что такое event loop?",
    "answer": "Event loop — это механизм JavaScript, который управляет выполнением кода, очередями задач и асинхронных операций, обеспечивая выполнение синхронного кода, microtask и macrotask в определённом порядке."
  },
  {
    "id": "js-063",
    "topic": "javascript",
    "question": "Что такое microtask и macrotask?",
    "answer": "Microtask — это задачи с более высоким приоритетом, такие как обработчики Promise, тогда как macrotask включают setTimeout, setInterval и события браузера, и event loop сначала выполняет все microtask, а затем одну macrotask."
  },
  {
    "id": "js-064",
    "topic": "javascript",
    "question": "В каком порядке выполняются setTimeout, Promise и sync-код?",
    "answer": "Сначала выполняется весь синхронный код, затем выполняются все microtask из Promise, и только после этого event loop переходит к выполнению macrotask, таких как callbacks из setTimeout."
  },
  {
    "id": "js-065",
    "topic": "javascript",
    "question": "Что такое сборщик мусора?",
    "answer": "Сборщик мусора — это механизм JavaScript-движка, который автоматически освобождает память, удаляя объекты, на которые больше нет ссылок и которые недостижимы из корневых объектов, тем самым предотвращая бесконтрольный рост использования памяти."
  },
  {
    "id": "js-066",
    "topic": "javascript",
    "question": "Какие типы утечек памяти ты знаешь?",
    "answer": "К основным типам утечек памяти относятся забытые таймеры и подписки, глобальные переменные, неочищенные обработчики событий, удерживаемые DOM-узлы и замыкания, которые продолжают ссылаться на ненужные объекты."
  },
  {
    "id": "js-067",
    "topic": "javascript",
    "question": "Как замыкания могут приводить к утечкам?",
    "answer": "Замыкания могут приводить к утечкам памяти, когда функция сохраняет ссылки на переменные или объекты из внешней области видимости и продолжает удерживать их в памяти даже после того, как они логически больше не нужны."
  },
  {
    "id": "js-068",
    "topic": "javascript",
    "question": "Что такое модуль в JavaScript?",
    "answer": "Модуль в JavaScript — это изолированный файл с собственным scope, который позволяет структурировать код, явно экспортировать публичный API и импортировать зависимости, улучшая читаемость, переиспользуемость и поддержку приложения."
  },
  {
    "id": "js-069",
    "topic": "javascript",
    "question": "Чем import отличается от require?",
    "answer": "import является частью стандарта ES Modules и работает статически на этапе загрузки модуля, тогда как require относится к CommonJS, выполняется динамически во время выполнения кода и чаще используется в Node.js, при этом import поддерживает tree-shaking и более строгую структуру модулей."
  },
  {
    "id": "js-070",
    "topic": "javascript",
    "question": "Что такое named и default export?",
    "answer": "Named export позволяет экспортировать несколько сущностей из модуля по именам и импортировать их с теми же именами, тогда как default export предназначен для экспорта одного основного значения и может быть импортирован под любым именем."
  },
  {
    "id": "js-071",
    "topic": "javascript",
    "question": "Когда код выполняется при импорте модуля?",
    "answer": "Код модуля выполняется один раз в момент его первого импорта, после чего результат выполнения кэшируется, и при последующих импортах используется уже инициализированный экземпляр модуля."
  },
  {
    "id": "js-072",
    "topic": "javascript",
    "question": "Какие типы ошибок существуют в JavaScript?",
    "answer": "В JavaScript существуют синтаксические ошибки, которые возникают при разборе кода, runtime-ошибки, возникающие во время выполнения, а также логические ошибки, когда код выполняется без сбоев, но даёт неверный результат; кроме того, есть встроенные типы ошибок, такие как ReferenceError, TypeError, SyntaxError, RangeError и Error."
  },
  {
    "id": "js-073",
    "topic": "javascript",
    "question": "Чем throw отличается от return?",
    "answer": "return завершает выполнение функции и возвращает значение вызывающему коду, тогда как throw прерывает нормальный поток выполнения и генерирует исключение, которое должно быть перехвачено с помощью try / catch или приведёт к ошибке выполнения."
  },
  {
    "id": "js-074",
    "topic": "javascript",
    "question": "Как работает try / catch?",
    "answer": "try / catch оборачивает потенциально опасный код, где try содержит выполнение, которое может выбросить ошибку, а catch перехватывает это исключение и позволяет обработать его без остановки программы, при этом блок finally выполняется всегда независимо от результата."
  },
  {
    "id": "js-075",
    "topic": "javascript",
    "question": "Можно ли ловить async-ошибки через try / catch?",
    "answer": "Да, ошибки в асинхронном коде можно ловить через try / catch при использовании async / await, так как отклонённый Promise автоматически преобразуется в исключение, тогда как при работе с then необходимо использовать метод catch."
  },
  {
    "id": "js-076",
    "topic": "javascript",
    "question": "Почему 0.1 + 0.2 !== 0.3?",
    "answer": "0.1 + 0.2 !== 0.3 из-за особенностей представления чисел с плавающей точкой в формате IEEE 754, где десятичные дроби не могут быть точно представлены в бинарной системе, что приводит к накоплению погрешности при вычислениях."
  },
  {
    "id": "js-077",
    "topic": "javascript",
    "question": "Почему typeof null === \"object\"?",
    "answer": "typeof null возвращает \"object\" из-за исторической ошибки в ранней реализации JavaScript, где null был представлен как нулевой указатель, и это поведение сохранено для обратной совместимости."
  },
  {
    "id": "js-078",
    "topic": "javascript",
    "question": "Что вернёт [] == []?",
    "answer": "Выражение [] == [] вернёт false, потому что массивы являются объектами и при сравнении по ссылке сравниваются разные участки памяти, даже если их содержимое одинаково."
  },
  {
    "id": "js-079",
    "topic": "javascript",
    "question": "Что вернёт {} + {}?",
    "answer": "Выражение {} + {} в глобальном контексте обычно интерпретируется как пустой блок кода плюс пустой объект и возвращает строку \"[object Object]\", однако результат зависит от контекста выполнения и может отличаться."
  },
  {
    "id": "js-080",
    "topic": "javascript",
    "question": "Почему функции — объекты?",
    "answer": "Функции в JavaScript являются объектами, потому что они могут иметь свойства, методы и прототип, а также передаваться как значения, что позволяет использовать их как данные и реализовывать функциональные паттерны."
  },
  {
    "id": "js-081",
    "topic": "javascript",
    "question": "Что произойдёт при изменении объекта через ссылку?",
    "answer": "При изменении объекта через ссылку изменения отразятся во всех переменных, которые ссылаются на этот объект, так как объекты в JavaScript передаются и хранятся по ссылке, а не копируются."
  },
  {
    "id": "js-082",
    "topic": "javascript",
    "question": "Как сделать глубокую копию объекта?",
    "answer": "Глубокую копию объекта можно сделать с помощью structuredClone, рекурсивного копирования, библиотек вроде lodash cloneDeep или через JSON.parse(JSON.stringify()), при этом последний способ имеет ограничения и не поддерживает функции, даты и undefined."
  },
  {
    "id": "js-083",
    "topic": "javascript",
    "question": "Чем shallow copy отличается от deep copy?",
    "answer": "Shallow copy копирует только верхний уровень объекта и сохраняет ссылки на вложенные объекты, тогда как deep copy полностью копирует всю структуру данных, создавая новые экземпляры для всех вложенных объектов."
  },
  {
    "id": "js-084",
    "topic": "javascript",
    "question": "Как проверить, есть ли свойство у объекта?",
    "answer": "Наличие свойства у объекта можно проверить с помощью оператора in, метода hasOwnProperty или Object.hasOwn, при этом важно учитывать разницу между собственными и унаследованными свойствами."
  },
  {
    "id": "js-085",
    "topic": "javascript",
    "question": "Почему важно не мутировать данные?",
    "answer": "Не мутировать данные важно для предсказуемости поведения программы, упрощения отладки, корректной работы механизмов сравнения и оптимизации, а также для правильной работы библиотек и фреймворков, таких как React, которые полагаются на иммутабельность."
  },
  {
    "id": "js-086",
    "topic": "javascript",
    "question": "Что такое DOM?",
    "answer": "DOM (Document Object Model) — это объектное представление HTML-документа в виде дерева узлов, которое браузер создаёт для того, чтобы JavaScript мог читать, изменять структуру, содержимое и стили страницы динамически."
  },
  {
    "id": "js-087",
    "topic": "javascript",
    "question": "Чем DOMContentLoaded отличается от load?",
    "answer": "DOMContentLoaded срабатывает, когда HTML-документ полностью загружен и разобран, но внешние ресурсы вроде изображений и стилей могут ещё загружаться, тогда как событие load происходит только после полной загрузки всех ресурсов страницы."
  },
  {
    "id": "js-088",
    "topic": "javascript",
    "question": "Что такое bubbling и capturing?",
    "answer": "Bubbling и capturing — это фазы распространения события в DOM, где capturing идёт сверху вниз от window к целевому элементу, а bubbling — снизу вверх от целевого элемента к корню документа."
  },
  {
    "id": "js-089",
    "topic": "javascript",
    "question": "Как работает делегирование событий?",
    "answer": "Делегирование событий основано на фазе всплытия и заключается в том, что обработчик вешается на общий родительский элемент, который перехватывает события от дочерних элементов и определяет источник события через event.target."
  },
  {
    "id": "js-090",
    "topic": "javascript",
    "question": "Что такое localStorage, sessionStorage и cookies?",
    "answer": "localStorage и sessionStorage — это Web Storage API для хранения данных в браузере в виде строк, где localStorage сохраняется бессрочно, а sessionStorage очищается при закрытии вкладки, тогда как cookies — это небольшие данные, которые отправляются с каждым HTTP-запросом на сервер."
  },
  {
    "id": "js-091",
    "topic": "javascript",
    "question": "Чем localStorage отличается от cookies?",
    "answer": "localStorage хранит больше данных, не отправляется автоматически на сервер и используется только на клиенте, тогда как cookies имеют меньший размер, автоматически передаются с HTTP-запросами и часто применяются для аутентификации и серверных сценариев."
  }
]
