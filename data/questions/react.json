[
  {
    "id": "react-001",
    "topic": "react",
    "question": "Что такое виртуальный DOM и какие задачи он решает в React?",
    "answer": "Виртуальный DOM — это абстрактное представление реального DOM в виде JavaScript-объектов, которое React хранит в памяти для оптимизации обновлений интерфейса; при изменении state или props React создаёт новое виртуальное дерево компонентов, сравнивает его с предыдущей версией с помощью алгоритма diffing и вычисляет минимальный набор изменений, которые необходимо применить к реальному DOM, что позволяет сократить количество дорогих операций с DOM, повысить производительность и сделать обновления UI более предсказуемыми и управляемыми."
  },
  {
    "id": "react-002",
    "topic": "react",
    "question": "Как работает процесс reconciliation и почему он важен?",
    "answer": "Reconciliation — это процесс, в ходе которого React сравнивает новое виртуальное DOM-дерево с предыдущим состоянием интерфейса, анализируя типы элементов и их ключи, чтобы определить, какие компоненты можно переиспользовать, а какие необходимо пересоздать, после чего React применяет к реальному DOM только необходимые изменения, что позволяет избежать полной перерисовки страницы и значительно улучшить производительность, особенно в сложных интерфейсах с большим количеством компонентов."
  },
  {
    "id": "react-003",
    "topic": "react",
    "question": "Почему React рекомендует использовать функциональные компоненты вместо классовых?",
    "answer": "Функциональные компоненты стали рекомендуемым подходом в React после появления хуков, так как они позволяют использовать состояние, побочные эффекты и другую логику без классов, уменьшают количество шаблонного кода, упрощают композицию и переиспользование логики, делают поведение компонентов более предсказуемым и облегчают тестирование и сопровождение приложения по сравнению с классовыми компонентами."
  },
  {
    "id": "react-004",
    "topic": "react",
    "question": "Как React обрабатывает обновления state внутри функционального компонента?",
    "answer": "При обновлении state с помощью функции из useState React не изменяет состояние немедленно, а ставит обновление в очередь, может объединить несколько обновлений в один рендер для оптимизации, затем повторно вызывает функцию компонента, создаёт новое виртуальное DOM-дерево, запускает процесс reconciliation и применяет к реальному DOM только минимально необходимые изменения, обеспечивая эффективное и производительное обновление интерфейса."
  },
  {
    "id": "react-005",
    "topic": "react",
    "question": "В чём заключается проблема props drilling и как её обычно решают?",
    "answer": "Props drilling возникает, когда данные и колбэки передаются через несколько уровней компонентов, которые сами их не используют, что приводит к усложнению структуры кода и ухудшению читаемости и поддержки, а решается эта проблема с помощью React Context для глобально доступных данных, state-менеджеров, композиции компонентов или более грамотного подъёма состояния на уровень, где оно действительно необходимо."
  },
  {
    "id": "react-006",
    "topic": "react",
    "question": "Что такое React и зачем он нужен?",
    "answer": "React — это JavaScript-библиотека для построения пользовательских интерфейсов, основная задача которой заключается в создании декларативного, компонентного и предсказуемого UI; React позволяет разбивать интерфейс на независимые компоненты, эффективно обновлять отображение при изменении данных и управлять сложным состоянием приложения, что особенно полезно при разработке масштабируемых и динамических веб-приложений."
  },
  {
    "id": "react-007",
    "topic": "react",
    "question": "В чём разница между React и обычным JavaScript?",
    "answer": "Обычный JavaScript предполагает императивное управление DOM, где разработчик вручную описывает, какие элементы и как изменять, тогда как React использует декларативный подход, при котором разработчик описывает, как интерфейс должен выглядеть в зависимости от состояния, а React самостоятельно определяет и применяет необходимые изменения к DOM, снижая сложность кода и вероятность ошибок."
  },
  {
    "id": "react-008",
    "topic": "react",
    "question": "Что такое JSX?",
    "answer": "JSX — это синтаксическое расширение JavaScript, которое позволяет описывать структуру пользовательского интерфейса с помощью HTML-подобного синтаксиса прямо в коде, делая компоненты более читаемыми и декларативными, при этом на этапе сборки JSX компилируется в вызовы React.createElement и не используется браузером напрямую."
  },
  {
    "id": "react-009",
    "topic": "react",
    "question": "Можно ли писать React без JSX?",
    "answer": "Да, React можно писать без JSX, используя прямые вызовы React.createElement, однако такой код быстро становится громоздким и трудночитаемым, поэтому на практике JSX используется почти всегда, так как он значительно упрощает описание интерфейса и улучшает читаемость и поддержку кода."
  },
  {
    "id": "react-010",
    "topic": "react",
    "question": "Что такое компонент в React?",
    "answer": "Компонент в React — это независимая и переиспользуемая часть пользовательского интерфейса, которая принимает данные через props, может управлять собственным состоянием и возвращает описание UI в виде JSX или элементов React, что позволяет строить сложные интерфейсы из простых и логически изолированных блоков."
  },
  {
    "id": "react-011",
    "topic": "react",
    "question": "Чем отличаются функциональные и классовые компоненты?",
    "answer": "Классовые компоненты основаны на ES6-классах и используют методы жизненного цикла для управления логикой, тогда как функциональные компоненты представляют собой обычные функции и с появлением хуков получили доступ к состоянию, эффектам и контексту, что позволило упростить код, сократить количество шаблонных конструкций, улучшить переиспользование логики и сделать компоненты более предсказуемыми и удобными для тестирования."
  },
  {
    "id": "react-012",
    "topic": "react",
    "question": "Что такое props?",
    "answer": "Props — это входные данные компонента в React, которые передаются ему от родительского компонента и используются для конфигурации поведения и отображения UI, позволяя делать компоненты переиспользуемыми, декларативными и независимыми от конкретной реализации родителя."
  },
  {
    "id": "react-013",
    "topic": "react",
    "question": "Можно ли изменять props?",
    "answer": "Изменять props напрямую нельзя, так как они считаются неизменяемыми и принадлежат родительскому компоненту, а попытка их изменения нарушает однонаправленный поток данных; если компоненту нужно изменить данные, он должен вызвать колбэк, переданный через props, чтобы родитель обновил своё состояние и передал новые props вниз."
  },
  {
    "id": "react-014",
    "topic": "react",
    "question": "Что такое state?",
    "answer": "State — это внутреннее состояние компонента, предназначенное для хранения данных, которые могут изменяться со временем и напрямую влияют на отображение интерфейса, например значения форм, флаги загрузки или результаты запросов, при обновлении state React автоматически инициирует повторный рендер компонента."
  },
  {
    "id": "react-015",
    "topic": "react",
    "question": "Чем state отличается от props?",
    "answer": "Props используются для передачи данных от родительского компонента к дочернему и считаются неизменяемыми внутри компонента, тогда как state управляется самим компонентом и может изменяться со временем, при этом оба механизма участвуют в рендере, но выполняют разные роли в архитектуре и управлении данными приложения."
  },
  {
    "id": "react-016",
    "topic": "react",
    "question": "Что такое Virtual DOM?",
    "answer": "Virtual DOM — это абстрактное представление реального DOM в виде JavaScript-объектов, которое React использует для хранения текущего состояния интерфейса в памяти и для вычисления различий между предыдущим и новым состоянием UI, что позволяет оптимизировать обновления и минимизировать количество прямых операций с реальным DOM."
  },
  {
    "id": "react-017",
    "topic": "react",
    "question": "Как React понимает, что компонент нужно перерендерить?",
    "answer": "React принимает решение о перерендере компонента, когда изменяются его state или props, либо когда перерендеривается родительский компонент, после чего React повторно вызывает функцию компонента для вычисления нового виртуального DOM и определения необходимых обновлений интерфейса."
  },
  {
    "id": "react-018",
    "topic": "react",
    "question": "Что такое reconciliation?",
    "answer": "Reconciliation — это процесс сравнения нового виртуального DOM-дерева с предыдущей версией, в ходе которого React анализирует типы элементов и их ключи, чтобы определить, какие части дерева можно переиспользовать, а какие необходимо обновить или пересоздать, и затем применяет минимальный набор изменений к реальному DOM."
  },
  {
    "id": "react-019",
    "topic": "react",
    "question": "Что происходит при изменении state?",
    "answer": "При изменении state React ставит обновление в очередь, может объединить несколько обновлений для оптимизации, затем повторно вызывает компонент для создания нового виртуального DOM, запускает процесс reconciliation и после этого обновляет реальный DOM только в тех местах, где произошли изменения."
  },
  {
    "id": "react-020",
    "topic": "react",
    "question": "Чем отличается initial render от re-render?",
    "answer": "Initial render — это первый рендер компонента, при котором React создаёт DOM-узлы с нуля и монтирует их в документ, тогда как re-render происходит при изменении state или props и включает повторный вызов компонента, сравнение виртуального DOM и обновление только изменившихся частей интерфейса без полного пересоздания DOM."
  },
  {
    "id": "react-021",
    "topic": "react",
    "question": "Что такое хуки в React?",
    "answer": "Хуки в React — это специальные функции, которые позволяют использовать состояние, побочные эффекты и другую функциональность React внутри функциональных компонентов без использования классов, делая код более простым, декларативным и удобным для повторного использования логики между компонентами."
  },
  {
    "id": "react-022",
    "topic": "react",
    "question": "Зачем нужен useState?",
    "answer": "useState используется для добавления локального состояния в функциональный компонент и позволяет хранить и обновлять данные, которые влияют на рендер UI, при этом каждое обновление state инициирует повторный рендер компонента с актуальными значениями."
  },
  {
    "id": "react-023",
    "topic": "react",
    "question": "Зачем нужен useEffect?",
    "answer": "useEffect предназначен для выполнения побочных эффектов в функциональных компонентах, таких как загрузка данных, подписки на события, работа с таймерами или прямое взаимодействие с DOM, которые не должны выполняться непосредственно во время рендера компонента."
  },
  {
    "id": "react-024",
    "topic": "react",
    "question": "Когда вызывается useEffect?",
    "answer": "useEffect вызывается после того, как компонент был отрендерен и изменения были применены к DOM, а также может повторно вызываться после каждого последующего рендера в зависимости от указанных зависимостей, что позволяет синхронизировать внешний мир с состоянием компонента."
  },
  {
    "id": "react-025",
    "topic": "react",
    "question": "Что означает массив зависимостей в useEffect?",
    "answer": "Массив зависимостей в useEffect определяет, при изменении каких значений эффект должен быть выполнен повторно, при пустом массиве эффект выполнится только один раз после монтирования, а при его отсутствии эффект будет запускаться после каждого рендера компонента."
  },
  {
    "id": "react-026",
    "topic": "react",
    "question": "Что означает массив зависимостей в useEffect?",
    "answer": "Массив зависимостей в useEffect указывает React, при изменении каких значений эффект должен быть выполнен повторно, при этом React сравнивает значения зависимостей между рендерами по ссылке, и если хотя бы одно из них изменилось, эффект перезапускается, что позволяет точно контролировать момент выполнения побочных эффектов."
  },
  {
    "id": "react-027",
    "topic": "react",
    "question": "Что будет, если не передать зависимости в useEffect?",
    "answer": "Если не передать массив зависимостей в useEffect, эффект будет выполняться после каждого рендера компонента, что может привести к лишним вызовам побочных эффектов, ухудшению производительности и даже к бесконечным циклам обновления при изменении state внутри эффекта."
  },
  {
    "id": "react-028",
    "topic": "react",
    "question": "Можно ли использовать хуки в условиях или циклах?",
    "answer": "Использовать хуки внутри условий, циклов или вложенных функций нельзя, так как React полагается на строгий порядок вызова хуков между рендерами, и любое условное выполнение может привести к несоответствию этого порядка и некорректной работе состояния."
  },
  {
    "id": "react-029",
    "topic": "react",
    "question": "Почему существуют правила хуков?",
    "answer": "Правила хуков существуют для того, чтобы React мог корректно сопоставлять вызовы хуков с их внутренним состоянием между рендерами, так как React не использует имена хуков, а опирается исключительно на порядок их вызова внутри компонента."
  },
  {
    "id": "react-030",
    "topic": "react",
    "question": "Что такое кастомный хук?",
    "answer": "Кастомный хук — это обычная JavaScript-функция, имя которой начинается с use и которая внутри себя использует другие хуки React, позволяя инкапсулировать и переиспользовать логику состояния и эффектов между разными компонентами."
  },
  {
    "id": "react-031",
    "topic": "react",
    "question": "Когда стоит создавать кастомный хук?",
    "answer": "Кастомный хук стоит создавать, когда одна и та же логика работы со state, эффектами или подписками повторяется в нескольких компонентах, либо когда компонент становится перегруженным логикой и её нужно вынести для улучшения читаемости, переиспользования и тестируемости."
  },
  {
    "id": "react-032",
    "topic": "react",
    "question": "Как обрабатываются события в React?",
    "answer": "События в React обрабатываются с помощью обработчиков, которые передаются в JSX в виде функций, например onClick или onChange, при этом React использует декларативный подход, где логика обработки события описывается в компоненте, а сам React берёт на себя подписку и управление жизненным циклом этих событий."
  },
  {
    "id": "react-033",
    "topic": "react",
    "question": "Чем синтетические события отличаются от нативных?",
    "answer": "Синтетические события в React представляют собой обёртку над нативными событиями браузера и обеспечивают единый интерфейс работы с событиями во всех браузерах, при этом React использует механизм event delegation и нормализует поведение событий, чтобы разработчику не приходилось учитывать браузерные различия."
  },
  {
    "id": "react-034",
    "topic": "react",
    "question": "Как передать параметр в обработчик события?",
    "answer": "Параметр в обработчик события передаётся с помощью оборачивания вызова функции в стрелочную функцию или через bind, например onClick={() => handleClick(id)}, что позволяет передать дополнительные данные, не вызывая обработчик сразу при рендере компонента."
  },
  {
    "id": "react-035",
    "topic": "react",
    "question": "Что такое controlled component?",
    "answer": "Controlled component — это компонент формы, значение которого полностью контролируется состоянием React, где текущее значение хранится в state и обновляется через обработчики событий, что позволяет централизованно управлять данными формы, выполнять валидацию и синхронизировать UI с состоянием приложения."
  },
  {
    "id": "react-036",
    "topic": "react",
    "question": "Что такое uncontrolled component?",
    "answer": "Uncontrolled component — это компонент формы, в котором значение хранится непосредственно в DOM, а доступ к нему осуществляется через refs, такой подход используется реже и подходит для простых сценариев, где не требуется полный контроль состояния формы со стороны React."
  },
  {
    "id": "react-037",
    "topic": "react",
    "question": "Как работать с формами в React?",
    "answer": "Работа с формами в React обычно строится через обработчики событий и состояние компонента, где значения полей ввода связываются с state, обновляются через onChange и используются для управления отображением, отправкой данных и валидацией, что позволяет полностью контролировать поведение формы на уровне приложения."
  },
  {
    "id": "react-038",
    "topic": "react",
    "question": "Как хранить данные формы?",
    "answer": "Данные формы чаще всего хранятся в state компонента с помощью useState или useReducer, где каждое поле формы соответствует отдельному значению или свойству объекта, что позволяет централизованно управлять данными, отслеживать изменения и использовать их при валидации и отправке формы."
  },
  {
    "id": "react-039",
    "topic": "react",
    "question": "Чем controlled input отличается от uncontrolled?",
    "answer": "Controlled input управляется состоянием React, где значение поля задаётся через state и обновляется через onChange, тогда как uncontrolled input хранит значение внутри DOM и доступ к нему осуществляется через refs, что делает controlled-подход более предсказуемым и предпочтительным для сложных форм."
  },
  {
    "id": "react-040",
    "topic": "react",
    "question": "Как валидировать форму?",
    "answer": "Валидация формы в React обычно реализуется через проверку значений, хранящихся в state, либо во время ввода, либо при отправке формы, с использованием кастомной логики, регулярных выражений или сторонних библиотек, при этом результаты валидации используются для отображения ошибок и управления доступностью отправки формы."
  },
  {
    "id": "react-041",
    "topic": "react",
    "question": "Что такое React.memo?",
    "answer": "React.memo — это функция высшего порядка, которая позволяет мемоизировать функциональный компонент и предотвращает его повторный рендер, если его props не изменились, что помогает сократить количество лишних перерендеров и повысить производительность при работе с тяжёлыми или часто обновляемыми компонентами."
  },
  {
    "id": "react-042",
    "topic": "react",
    "question": "Зачем нужен useCallback?",
    "answer": "useCallback используется для мемоизации функции и возвращает одну и ту же ссылку на функцию между рендерами, пока не изменятся зависимости, что особенно полезно при передаче колбэков в дочерние компоненты, оптимизированные с помощью React.memo, чтобы избежать лишних перерендеров."
  },
  {
    "id": "react-043",
    "topic": "react",
    "question": "Зачем нужен useMemo?",
    "answer": "useMemo применяется для мемоизации вычисляемых значений и позволяет избежать повторного выполнения дорогостоящих вычислений при каждом рендере, пересчитывая значение только при изменении указанных зависимостей, что может существенно улучшить производительность в сложных сценариях."
  },
  {
    "id": "react-044",
    "topic": "react",
    "question": "В чём разница между useCallback и useMemo?",
    "answer": "useCallback мемоизирует функцию и возвращает стабильную ссылку на неё, тогда как useMemo мемоизирует результат вычисления и возвращает само значение, при этом useCallback по сути является частным случаем useMemo, оптимизированным для функций."
  },
  {
    "id": "react-045",
    "topic": "react",
    "question": "Когда оптимизация в React может навредить?",
    "answer": "Оптимизация в React может навредить, если использовать мемоизацию без реальной необходимости, так как она усложняет код, увеличивает когнитивную нагрузку и может даже ухудшить производительность из-за дополнительных сравнений зависимостей и хранения мемоизированных значений."
  },
  {
    "id": "react-046",
    "topic": "react",
    "question": "Что такое key и зачем он нужен?",
    "answer": "Key — это специальный атрибут, который используется React при рендере списков для уникальной идентификации элементов, позволяя корректно сопоставлять элементы между рендерами, сохранять их состояние и выполнять эффективные обновления без лишних пересозданий DOM-узлов."
  },
  {
    "id": "react-047",
    "topic": "react",
    "question": "Что такое lifting state up?",
    "answer": "Lifting state up — это архитектурный приём в React, при котором состояние поднимается из дочерних компонентов в ближайший общий родительский компонент, чтобы несколько компонентов могли использовать и синхронно обновлять одни и те же данные через props."
  },
  {
    "id": "react-048",
    "topic": "react",
    "question": "Что такое prop drilling?",
    "answer": "Prop drilling — это ситуация, когда данные и колбэки передаются через несколько уровней компонентов, которые сами эти данные не используют, что приводит к усложнению структуры компонентов и ухудшению читаемости и поддержки кода."
  },
  {
    "id": "react-049",
    "topic": "react",
    "question": "Как решить проблему prop drilling?",
    "answer": "Проблема prop drilling решается с помощью React Context для глобально доступных данных, использования state-менеджеров, композиции компонентов или более грамотного подъёма состояния на уровень, где оно действительно необходимо, чтобы сократить глубину передачи props."
  },
  {
    "id": "react-050",
    "topic": "react",
    "question": "Что такое Context API?",
    "answer": "Context API — это встроенный механизм React, который позволяет передавать данные через дерево компонентов без явной передачи props на каждом уровне, что удобно для хранения глобальных данных, таких как тема, язык интерфейса или данные авторизации."
  },
  {
    "id": "react-051",
    "topic": "react",
    "question": "Когда не стоит использовать Context?",
    "answer": "Context не стоит использовать для часто изменяющихся данных или локального состояния, так как каждое обновление контекста вызывает перерендер всех подписанных компонентов, что может негативно сказаться на производительности и усложнить архитектуру приложения."
  },
  {
    "id": "react-052",
    "topic": "react",
    "question": "Что такое composition в React?",
    "answer": "Composition в React — это подход к построению интерфейса, при котором сложные компоненты создаются путём комбинирования простых компонентов через props и children, что позволяет гибко переиспользовать логику и UI без жёсткой иерархии наследования."
  },
  {
    "id": "react-053",
    "topic": "react",
    "question": "Как делать HTTP-запросы в React?",
    "answer": "HTTP-запросы в React обычно выполняют внутри useEffect или в обработчиках событий, используя fetch или библиотеки вроде axios, при этом важно не делать запросы прямо в теле рендера, чтобы избежать повторных запросов на каждом ререндере, а результаты запроса сохранять в state и на их основе отображать UI."
  },
  {
    "id": "react-054",
    "topic": "react",
    "question": "Где лучше делать запросы: в компоненте или отдельно?",
    "answer": "Запросы можно делать в компоненте для простых случаев, но чаще лучше выносить сетевую логику в отдельный слой (api-клиент, сервисы, hooks или data-fetching библиотеку), чтобы улучшить переиспользуемость, тестируемость и разделение ответственности, а компоненту оставить роль отображения и управления состояниями загрузки."
  },
  {
    "id": "react-055",
    "topic": "react",
    "question": "Как обрабатывать loading и error состояния?",
    "answer": "Loading и error обычно обрабатывают через отдельные поля состояния, например isLoading и error, где перед запросом включают loading, при успехе сохраняют данные и выключают loading, а при ошибке записывают объект ошибки и показывают пользователю сообщение, при этом важно также предусмотреть повтор запроса и корректные состояния для пустых данных."
  },
  {
    "id": "react-056",
    "topic": "react",
    "question": "Что делать при размонтировании компонента и незавершённом запросе?",
    "answer": "При размонтировании компонента важно предотвратить попытку обновить state после завершения запроса, для этого обычно используют AbortController для отмены fetch в cleanup-функции useEffect или флаг актуальности запроса, а при использовании библиотек вроде React Query отмена и управление жизненным циклом запросов часто решаются автоматически."
  },
  {
    "id": "react-057",
    "topic": "react",
    "question": "Какие этапы жизненного цикла компонента ты знаешь?",
    "answer": "Жизненный цикл компонента в React включает этапы монтирования, обновления и размонтирования, где на этапе монтирования компонент создаётся и вставляется в DOM, на этапе обновления происходит повторный рендер при изменении state или props, а на этапе размонтирования компонент удаляется из DOM и должна выполняться очистка ресурсов."
  },
  {
    "id": "react-058",
    "topic": "react",
    "question": "Какие аналоги lifecycle методов есть в хуках?",
    "answer": "В функциональных компонентах аналоги lifecycle методов реализуются с помощью useEffect и useLayoutEffect, где useEffect с пустым массивом зависимостей соответствует componentDidMount, cleanup-функция useEffect соответствует componentWillUnmount, а useEffect с зависимостями используется для обработки обновлений, аналогично componentDidUpdate."
  },
  {
    "id": "react-059",
    "topic": "react",
    "question": "Когда компонент монтируется?",
    "answer": "Компонент считается смонтированным в момент, когда React впервые вызывает функцию компонента, создаёт соответствующие DOM-узлы на основе виртуального DOM и вставляет их в реальный DOM, после чего можно выполнять побочные эффекты, связанные с доступом к DOM или внешними ресурсами."
  },
  {
    "id": "react-060",
    "topic": "react",
    "question": "Когда компонент размонтируется?",
    "answer": "Компонент размонтируется, когда React удаляет его из дерева компонентов и из реального DOM, например при изменении условий рендера или переходе на другую страницу, и в этот момент необходимо освобождать ресурсы, отменять подписки и запросы, чтобы избежать утечек памяти."
  },
  {
    "id": "react-061",
    "topic": "react",
    "question": "Что такое SPA?",
    "answer": "SPA (Single Page Application) — это веб-приложение, в котором загрузка HTML-документа происходит один раз, а дальнейшая навигация и обновление контента выполняются на клиенте с помощью JavaScript без полной перезагрузки страницы, что обеспечивает более быстрый и плавный пользовательский опыт."
  },
  {
    "id": "react-062",
    "topic": "react",
    "question": "Как работает роутинг в React?",
    "answer": "Роутинг в React обычно реализуется на стороне клиента с помощью библиотек вроде React Router, которые отслеживают изменения URL через History API браузера и в зависимости от текущего маршрута отображают соответствующие компоненты без перезагрузки страницы."
  },
  {
    "id": "react-063",
    "topic": "react",
    "question": "Чем отличается client-side routing от server-side routing?",
    "answer": "Client-side routing выполняется в браузере и изменяет отображаемый контент без перезагрузки страницы, тогда как server-side routing обрабатывается сервером, где каждый URL приводит к загрузке нового HTML-документа, что влияет на производительность и пользовательский опыт."
  },
  {
    "id": "react-064",
    "topic": "react",
    "question": "Что такое SSR?",
    "answer": "SSR (Server-Side Rendering) — это подход, при котором HTML-страница генерируется на сервере для каждого запроса и отправляется в браузер уже с готовым контентом, что улучшает время первого отображения и SEO по сравнению с чистым клиентским рендерингом."
  },
  {
    "id": "react-065",
    "topic": "react",
    "question": "В чём разница между CSR и SSR?",
    "answer": "При CSR (Client-Side Rendering) HTML создаётся в браузере с помощью JavaScript после загрузки приложения, тогда как при SSR HTML формируется на сервере и сразу отправляется пользователю, что ускоряет первый рендер, но усложняет архитектуру и нагрузку на сервер."
  },
  {
    "id": "react-066",
    "topic": "react",
    "question": "Зачем нужен Next.js?",
    "answer": "Next.js — это фреймворк поверх React, который упрощает создание приложений с SSR, SSG и гибридным рендерингом, предоставляет встроенный роутинг, оптимизацию производительности и удобные инструменты для работы с SEO, что делает его подходящим для продакшен-приложений."
  },
  {
    "id": "react-067",
    "topic": "react",
    "question": "Почему компонент может ререндериться слишком часто?",
    "answer": "Компонент может ререндериться слишком часто из-за частых обновлений state или props, перерендеров родительского компонента, создания новых ссылок на функции или объекты при каждом рендере, отсутствия мемоизации и неправильного использования хуков, что в совокупности приводит к лишним вычислениям и снижению производительности."
  },
  {
    "id": "react-068",
    "topic": "react",
    "question": "Как предотвратить лишние ререндеры?",
    "answer": "Лишние ререндеры предотвращают с помощью React.memo, useCallback и useMemo, корректного использования key, подъёма состояния только при необходимости, разделения компонентов на более мелкие и избегания создания новых объектов и функций при каждом рендере без необходимости."
  },
  {
    "id": "react-069",
    "topic": "react",
    "question": "Почему нельзя использовать index как key?",
    "answer": "Index нельзя использовать как key, потому что при изменении порядка элементов, добавлении или удалении React может неправильно сопоставить элементы между рендерами, что приводит к багам, потере состояния компонентов и некорректному обновлению интерфейса."
  },
  {
    "id": "react-070",
    "topic": "react",
    "question": "Что будет, если напрямую изменить state?",
    "answer": "При прямом изменении state React не узнаёт об изменении данных и не запускает повторный рендер, что приводит к несинхронизированному UI, трудноуловимым багам и нарушению принципов предсказуемости работы компонентов."
  },
  {
    "id": "react-071",
    "topic": "react",
    "question": "Как передать данные от дочернего компонента к родительскому?",
    "answer": "Данные от дочернего компонента к родительскому передаются через колбэк-функцию, переданную в props, которую дочерний компонент вызывает с нужными данными, после чего родитель обновляет свой state и передаёт новые props вниз."
  },
  {
    "id": "react-072",
    "topic": "react",
    "question": "Как организовать глобальное состояние?",
    "answer": "Глобальное состояние в React можно организовать с помощью Context API для простых сценариев, специализированных state-менеджеров вроде Redux, Zustand или MobX для более сложных случаев, либо библиотек для работы с серверным состоянием, таких как React Query."
  },
  {
    "id": "react-073",
    "topic": "react",
    "question": "Что ты выберешь: Context или Redux и почему?",
    "answer": "Выбор между Context и Redux зависит от задачи: Context подходит для простых и редко изменяющихся глобальных данных, таких как тема или язык, тогда как Redux лучше использовать для сложного состояния с частыми обновлениями, строгой архитектурой и необходимостью дебага и масштабирования."
  },
  {
    "id": "react-074",
    "topic": "react",
    "question": "Как бы ты структурировал большой React-проект?",
    "answer": "Большой React-проект обычно структурируют по фичам или доменам, разделяя код на модули с компонентами, хуками, сервисами и состоянием, вынося общие части в shared-слой и соблюдая принципы разделения ответственности и масштабируемости."
  },
  {
    "id": "react-075",
    "topic": "react",
    "question": "Какие ошибки чаще всего допускают React-разработчики?",
    "answer": "React-разработчики часто допускают ошибки, такие как неправильное использование хуков и зависимостей useEffect, чрезмерная оптимизация, прямое изменение state, использование index как key, отсутствие разделения логики и UI, а также неправильная работа с асинхронными эффектами."
  },
  {
    "id": "react-076",
    "topic": "react",
    "question": "Что происходит, если в useEffect изменить state без зависимостей?",
    "answer": "Если в useEffect изменить state без указания массива зависимостей, эффект будет выполняться после каждого рендера, что приведёт к бесконечному циклу рендеров и обновлений состояния, потенциально полностью блокируя приложение."
  }
]
