[
  {
    "id": "fundamentals-002",
    "topic": "fundamentals",
    "question": "Что такое Critical Rendering Path?",
    "answer": "Critical Rendering Path — это последовательность шагов от загрузки HTML, CSS и JavaScript до первого отображения контента на экране, включающая построение DOM, CSSOM, render tree, layout и paint, оптимизация которой напрямую влияет на скорость загрузки страницы."
  },
  {
    "id": "fundamentals-003",
    "topic": "fundamentals",
    "question": "В каком порядке загружаются HTML, CSS и JS?",
    "answer": "HTML загружается и парсится последовательно, CSS загружается параллельно и блокирует рендер до построения CSSOM, а JavaScript по умолчанию блокирует парсинг HTML до выполнения, если не используется async или defer."
  },
  {
    "id": "fundamentals-004",
    "topic": "fundamentals",
    "question": "Почему CSS может блокировать рендер?",
    "answer": "CSS блокирует рендер, потому что браузеру необходимо полностью построить CSSOM до создания render tree, иначе он не сможет корректно рассчитать стили и размеры элементов."
  },
  {
    "id": "fundamentals-005",
    "topic": "fundamentals",
    "question": "Почему JS может блокировать рендер?",
    "answer": "JavaScript блокирует рендер, потому что браузер должен приостановить парсинг HTML и выполнение других задач до выполнения скрипта, так как JS может изменить DOM и CSSOM."
  },
  {
    "id": "fundamentals-006",
    "topic": "fundamentals",
    "question": "Что такое reflow и repaint?",
    "answer": "Reflow — это перерасчёт размеров и положения элементов в layout, а repaint — это перерисовка визуального представления элементов без изменения их геометрии."
  },
  {
    "id": "fundamentals-007",
    "topic": "fundamentals",
    "question": "В чём разница между reflow и repaint?",
    "answer": "Reflow является более дорогой операцией, так как влияет на layout и может затронуть множество элементов, тогда как repaint обновляет только визуальные стили, такие как цвет или фон, без пересчёта размеров."
  },
  {
    "id": "fundamentals-008",
    "topic": "fundamentals",
    "question": "Что такое event loop?",
    "answer": "Event loop — это механизм JavaScript-движка, который управляет выполнением кода, обрабатывая call stack, очереди microtask и macrotask и обеспечивая асинхронное, неблокирующее выполнение в однопоточном окружении."
  },
  {
    "id": "fundamentals-009",
    "topic": "fundamentals",
    "question": "Что такое call stack?",
    "answer": "Call stack — это структура данных, в которой хранятся контексты выполнения функций, где функции добавляются при вызове и удаляются после завершения выполнения."
  },
  {
    "id": "fundamentals-010",
    "topic": "fundamentals",
    "question": "Чем microtask отличается от macrotask?",
    "answer": "Microtask имеет более высокий приоритет и выполняется сразу после завершения текущего синхронного кода, тогда как macrotask выполняется позже и включает такие операции, как setTimeout и обработчики событий."
  },
  {
    "id": "fundamentals-011",
    "topic": "fundamentals",
    "question": "В каком порядке выполняются sync-код, Promise и setTimeout?",
    "answer": "Сначала выполняется весь синхронный код, затем выполняются все microtask из Promise, и только после этого event loop переходит к выполнению macrotask, таких как callbacks из setTimeout."
  },
  {
    "id": "fundamentals-012",
    "topic": "fundamentals",
    "question": "Что происходит при клике по кнопке в браузере?",
    "answer": "При клике браузер фиксирует событие, помещает его в очередь macrotask, после чего event loop обрабатывает его, выполняет обработчики событий с учётом фаз capturing и bubbling, может запустить синхронный код, microtask и вызвать перерисовку интерфейса."
  },
  {
    "id": "fundamentals-013",
    "topic": "fundamentals",
    "question": "Что такое HTTP?",
    "answer": "HTTP (HyperText Transfer Protocol) — это прикладной протокол передачи данных, который определяет правила обмена запросами и ответами между клиентом и сервером в модели клиент–сервер и является stateless, то есть не хранит состояние между запросами."
  },
  {
    "id": "fundamentals-014",
    "topic": "fundamentals",
    "question": "Чем HTTP отличается от HTTPS?",
    "answer": "HTTPS отличается от HTTP тем, что использует шифрование TLS, обеспечивая конфиденциальность, целостность и подлинность данных, тогда как HTTP передаёт данные в открытом виде и уязвим для перехвата и подмены."
  },
  {
    "id": "fundamentals-015",
    "topic": "fundamentals",
    "question": "Какие HTTP-методы ты знаешь?",
    "answer": "Основные HTTP-методы включают GET для получения данных, POST для создания ресурсов, PUT и PATCH для обновления, DELETE для удаления, а также HEAD, OPTIONS и TRACE для служебных и диагностических операций."
  },
  {
    "id": "fundamentals-016",
    "topic": "fundamentals",
    "question": "В чём разница между PUT и PATCH?",
    "answer": "PUT предназначен для полного обновления ресурса и заменяет его целиком, тогда как PATCH используется для частичного обновления и изменяет только переданные поля, не затрагивая остальные данные."
  },
  {
    "id": "fundamentals-017",
    "topic": "fundamentals",
    "question": "Какие группы HTTP-статусов существуют?",
    "answer": "HTTP-статусы делятся на группы: 1xx — информационные, 2xx — успешные ответы, 3xx — редиректы, 4xx — ошибки клиента и 5xx — ошибки сервера."
  },
  {
    "id": "fundamentals-018",
    "topic": "fundamentals",
    "question": "Чем отличаются 401 и 403?",
    "answer": "401 означает, что пользователь не аутентифицирован или аутентификация не выполнена, тогда как 403 означает, что пользователь аутентифицирован, но не имеет прав доступа к ресурсу."
  },
  {
    "id": "fundamentals-019",
    "topic": "fundamentals",
    "question": "Что такое headers?",
    "answer": "Headers — это метаданные HTTP-запроса или ответа в формате ключ–значение, которые передают информацию о типе контента, авторизации, кешировании, cookies и других параметрах взаимодействия."
  },
  {
    "id": "fundamentals-020",
    "topic": "fundamentals",
    "question": "Что такое cookies?",
    "answer": "Cookies — это небольшие фрагменты данных, которые сервер сохраняет в браузере клиента и которые автоматически отправляются с каждым запросом к соответствующему домену для хранения состояния, сессий и авторизации."
  },
  {
    "id": "fundamentals-021",
    "topic": "fundamentals",
    "question": "Что такое CORS?",
    "answer": "CORS (Cross-Origin Resource Sharing) — это механизм безопасности браузера, который определяет, разрешено ли веб-странице запрашивать ресурсы с другого домена, основываясь на специальных HTTP-заголовках."
  },
  {
    "id": "fundamentals-022",
    "topic": "fundamentals",
    "question": "Почему возникает CORS-ошибка?",
    "answer": "CORS-ошибка возникает, когда браузер блокирует запрос из-за отсутствия или некорректных CORS-заголовков в ответе сервера, даже если сам сервер корректно обработал запрос."
  },
  {
    "id": "fundamentals-023",
    "topic": "fundamentals",
    "question": "Что такое preflight-запрос?",
    "answer": "Preflight-запрос — это предварительный OPTIONS-запрос, который браузер отправляет перед небезопасными кросс-доменными запросами, чтобы проверить, разрешает ли сервер такие методы, заголовки и источники."
  },
  {
    "id": "fundamentals-024",
    "topic": "fundamentals",
    "question": "Чем REST отличается от GraphQL?",
    "answer": "REST использует несколько эндпоинтов и фиксированную структуру ответов, тогда как GraphQL предоставляет единый эндпоинт и позволяет клиенту точно указывать, какие данные ему нужны, уменьшая overfetching и underfetching."
  },
  {
    "id": "fundamentals-025",
    "topic": "fundamentals",
    "question": "Что такое idempotent-запрос?",
    "answer": "Idempotent-запрос — это запрос, повторное выполнение которого приводит к одному и тому же результату на сервере, например GET, PUT и DELETE, в отличие от POST, который обычно не является идемпотентным."
  },
  {
    "id": "fundamentals-026",
    "topic": "fundamentals",
    "question": "Что такое CRUD?",
    "answer": "CRUD — это базовый набор операций для работы с данными, включающий Create (создание), Read (чтение), Update (обновление) и Delete (удаление), который лежит в основе большинства клиент-серверных приложений и API."
  },
  {
    "id": "fundamentals-027",
    "topic": "fundamentals",
    "question": "Как организовать загрузку данных на клиенте?",
    "answer": "Загрузка данных на клиенте обычно организуется через асинхронные HTTP-запросы с использованием fetch или библиотек вроде Axios, с разделением состояний на loading, success и error и возможным кешированием данных."
  },
  {
    "id": "fundamentals-028",
    "topic": "fundamentals",
    "question": "Что делать с loading-состоянием?",
    "answer": "Loading-состояние следует явно обрабатывать в интерфейсе, показывая пользователю индикаторы загрузки или skeleton UI, чтобы улучшить UX и избежать ощущения зависшего приложения."
  },
  {
    "id": "fundamentals-029",
    "topic": "fundamentals",
    "question": "Как обрабатывать ошибки API?",
    "answer": "Ошибки API обрабатываются через проверку HTTP-статусов и try/catch, отображение понятных сообщений пользователю, логирование ошибок и реализацию fallback-сценариев или повторных запросов."
  },
  {
    "id": "fundamentals-030",
    "topic": "fundamentals",
    "question": "Что такое debounce?",
    "answer": "Debounce — это техника ограничения частоты вызова функции, при которой она выполняется только после паузы в событиях, что часто используется для оптимизации ввода, поиска и resize-событий."
  },
  {
    "id": "fundamentals-031",
    "topic": "fundamentals",
    "question": "Чем debounce отличается от throttle?",
    "answer": "Debounce откладывает выполнение функции до окончания серии событий, тогда как throttle гарантирует выполнение функции не чаще заданного интервала времени независимо от количества событий."
  },
  {
    "id": "fundamentals-032",
    "topic": "fundamentals",
    "question": "Что такое pagination?",
    "answer": "Pagination — это способ постраничной загрузки данных, при котором элементы разбиваются на страницы, что снижает нагрузку на сервер и клиент и упрощает навигацию по большим спискам."
  },
  {
    "id": "fundamentals-033",
    "topic": "fundamentals",
    "question": "Что такое infinite scroll?",
    "answer": "Infinite scroll — это подход к загрузке данных, при котором новые элементы подгружаются автоматически при прокрутке страницы, создавая ощущение бесконечного списка и улучшая вовлечённость пользователя."
  },
  {
    "id": "fundamentals-034",
    "topic": "fundamentals",
    "question": "Как отменить HTTP-запрос?",
    "answer": "HTTP-запрос можно отменить с помощью AbortController, передав его signal в fetch или поддерживающую библиотеку, что позволяет прерывать запросы при размонтировании компонента или смене условий."
  },
  {
    "id": "fundamentals-035",
    "topic": "fundamentals",
    "question": "Что такое AbortController?",
    "answer": "AbortController — это Web API, позволяющее управлять отменой асинхронных операций, таких как fetch-запросы, путём отправки сигнала abort для остановки выполнения."
  },
  {
    "id": "fundamentals-036",
    "topic": "fundamentals",
    "question": "Что делать при нестабильном API?",
    "answer": "При нестабильном API следует реализовывать повторные запросы с backoff, таймауты, кеширование успешных ответов, graceful degradation интерфейса и информирование пользователя о проблемах."
  },
  {
    "id": "fundamentals-037",
    "topic": "fundamentals",
    "question": "Как работать с авторизацией на фронтенде?",
    "answer": "Авторизация на фронтенде обычно реализуется через хранение токенов или сессионных cookies, проверку прав доступа, защиту маршрутов, обновление токенов и корректную обработку состояний входа и выхода пользователя."
  },
  {
    "id": "fundamentals-038",
    "topic": "fundamentals",
    "question": "Что такое frontend-архитектура?",
    "answer": "Frontend-архитектура — это набор принципов, правил и структур организации кода, которые определяют, как разделяются ответственность, данные, UI и бизнес-логика в приложении для обеспечения масштабируемости, поддержки и развития проекта."
  },
  {
    "id": "fundamentals-039",
    "topic": "fundamentals",
    "question": "Зачем разделять код по слоям?",
    "answer": "Разделение кода по слоям позволяет изолировать ответственность, снизить связанность между частями приложения, упростить тестирование, поддержку и развитие функциональности без каскадных изменений."
  },
  {
    "id": "fundamentals-040",
    "topic": "fundamentals",
    "question": "Что такое separation of concerns?",
    "answer": "Separation of concerns — это принцип разработки, при котором каждая часть системы отвечает только за одну зону ответственности, например UI, бизнес-логику или работу с данными, что делает код более понятным и управляемым."
  },
  {
    "id": "fundamentals-041",
    "topic": "fundamentals",
    "question": "Как структурировать большой frontend-проект?",
    "answer": "Большой frontend-проект следует структурировать по доменам и ответственности, группируя код по фичам или слоям, отделяя UI, бизнес-логику, состояние и инфраструктуру, а также используя общие правила именования и навигации по проекту."
  },
  {
    "id": "fundamentals-042",
    "topic": "fundamentals",
    "question": "Где должна находиться бизнес-логика?",
    "answer": "Бизнес-логика должна находиться вне UI-компонентов, в отдельных слоях или модулях, чтобы быть переиспользуемой, тестируемой и независимой от конкретного фреймворка или представления."
  },
  {
    "id": "fundamentals-043",
    "topic": "fundamentals",
    "question": "Что такое Feature-Sliced Design?",
    "answer": "Feature-Sliced Design — это архитектурная методология для фронтенда, которая предлагает структурировать проект по слоям и фичам, разделяя код на app, processes, pages, widgets, features, entities и shared."
  },
  {
    "id": "fundamentals-044",
    "topic": "fundamentals",
    "question": "Чем feature отличается от widget?",
    "answer": "Feature представляет собой законченную пользовательскую возможность с бизнес-логикой, тогда как widget — это композиция UI-элементов, объединяющая несколько features или entities для отображения части интерфейса."
  },
  {
    "id": "fundamentals-045",
    "topic": "fundamentals",
    "question": "Какие проблемы решает архитектура?",
    "answer": "Архитектура решает проблемы масштабируемости, сложности поддержки, роста связности, дублирования логики, хаотичной структуры кода и снижает риски при добавлении новых фич и работе команды."
  },
  {
    "id": "fundamentals-046",
    "topic": "fundamentals",
    "question": "Как избежать \"спагетти-кода\"?",
    "answer": "Чтобы избежать спагетти-кода, необходимо соблюдать принципы архитектуры, разделять ответственность, избегать жёстких зависимостей, ограничивать размер компонентов и регулярно проводить рефакторинг."
  },
  {
    "id": "fundamentals-047",
    "topic": "fundamentals",
    "question": "Как понять, что архитектура плохая?",
    "answer": "Плохая архитектура проявляется через сложность внесения изменений, частые баги при правках, сильную связанность модулей, дублирование логики, неочевидную структуру проекта и страх разработчиков что-либо менять."
  },
  {
    "id": "fundamentals-048",
    "topic": "fundamentals",
    "question": "Что такое state?",
    "answer": "State — это данные приложения, которые могут изменяться со временем и напрямую влияют на то, как интерфейс выглядит и ведёт себя в текущий момент."
  },
  {
    "id": "fundamentals-049",
    "topic": "fundamentals",
    "question": "Чем локальный state отличается от глобального?",
    "answer": "Локальный state принадлежит конкретному компоненту и используется только внутри него, тогда как глобальный state доступен нескольким частям приложения и используется для хранения общих данных."
  },
  {
    "id": "fundamentals-050",
    "topic": "fundamentals",
    "question": "Когда локального state недостаточно?",
    "answer": "Локального state недостаточно, когда данные должны использоваться несколькими удалёнными компонентами, синхронизироваться между экранами или сохраняться при навигации по приложению."
  },
  {
    "id": "fundamentals-051",
    "topic": "fundamentals",
    "question": "Что такое server state?",
    "answer": "Server state — это состояние, источником которого является сервер, например данные API, и которое может изменяться независимо от клиента, требуя синхронизации, кеширования и повторной загрузки."
  },
  {
    "id": "fundamentals-052",
    "topic": "fundamentals",
    "question": "Чем server state отличается от client state?",
    "answer": "Server state управляется сервером и требует загрузки, обновления и кеширования, тогда как client state полностью контролируется клиентом и используется для UI-состояний, таких как открытые модалки или выбранные элементы."
  },
  {
    "id": "fundamentals-053",
    "topic": "fundamentals",
    "question": "Когда Context — плохой выбор?",
    "answer": "Context является плохим выбором, когда состояние часто меняется и приводит к массовым перерендерам, либо когда он используется как полноценная замена state-менеджеру без чётких границ ответственности."
  },
  {
    "id": "fundamentals-054",
    "topic": "fundamentals",
    "question": "В каких случаях нужен Redux?",
    "answer": "Redux нужен в больших приложениях с сложным глобальным состоянием, множеством источников изменений, требованиями к предсказуемости, дебагу и строгому контролю потока данных."
  },
  {
    "id": "fundamentals-055",
    "topic": "fundamentals",
    "question": "Зачем нужен Redux Toolkit?",
    "answer": "Redux Toolkit упрощает работу с Redux, уменьшая шаблонный код, предоставляя безопасные паттерны обновления состояния, встроенную работу с асинхронностью и лучшую поддержку масштабирования."
  },
  {
    "id": "fundamentals-056",
    "topic": "fundamentals",
    "question": "Что решает React Query?",
    "answer": "React Query решает проблемы server state, автоматически управляя загрузкой данных, кешированием, повторной валидацией, синхронизацией и обработкой ошибок без необходимости хранить данные API в Redux."
  },
  {
    "id": "fundamentals-057",
    "topic": "fundamentals",
    "question": "Где лучше хранить состояние формы?",
    "answer": "Состояние формы лучше хранить локально в компоненте или в специализированных библиотеках для форм, так как оно тесно связано с UI и редко требуется глобально."
  },
  {
    "id": "fundamentals-058",
    "topic": "fundamentals",
    "question": "Где нельзя хранить state?",
    "answer": "State не следует хранить в глобальных переменных, напрямую в DOM, в props или в местах, где он теряет контроль обновлений и приводит к непредсказуемому поведению приложения."
  },
  {
    "id": "fundamentals-059",
    "topic": "fundamentals",
    "question": "Что такое производительность во frontend?",
    "answer": "Производительность во frontend — это совокупность характеристик, определяющих скорость загрузки, отзывчивость и плавность интерфейса, включая время первого рендера, скорость реакции на действия пользователя и стабильность визуального отображения."
  },
  {
    "id": "fundamentals-060",
    "topic": "fundamentals",
    "question": "Почему приложение может тормозить?",
    "answer": "Frontend-приложение может тормозить из-за тяжёлого JavaScript, частых и лишних перерендеров, неэффективных вычислений, блокирующих операций, больших бандлов, неоптимальных изображений и чрезмерных reflow и repaint."
  },
  {
    "id": "fundamentals-061",
    "topic": "fundamentals",
    "question": "Что такое unnecessary re-renders?",
    "answer": "Unnecessary re-renders — это лишние перерисовки компонентов, которые происходят без реального изменения отображаемых данных и приводят к ухудшению производительности интерфейса."
  },
  {
    "id": "fundamentals-062",
    "topic": "fundamentals",
    "question": "Как определить проблему производительности?",
    "answer": "Проблемы производительности определяются с помощью инструментов браузера, таких как Chrome DevTools, Performance и Lighthouse, React DevTools Profiler, анализа Web Vitals и наблюдения за поведением интерфейса."
  },
  {
    "id": "fundamentals-063",
    "topic": "fundamentals",
    "question": "Что такое code splitting?",
    "answer": "Code splitting — это техника разделения JavaScript-кода на независимые чанки, которые загружаются по мере необходимости, что уменьшает размер начального бандла и ускоряет первый рендер страницы."
  },
  {
    "id": "fundamentals-064",
    "topic": "fundamentals",
    "question": "Что такое lazy loading?",
    "answer": "Lazy loading — это подход, при котором ресурсы, компоненты или данные загружаются только в момент, когда они действительно нужны пользователю, например при прокрутке или навигации."
  },
  {
    "id": "fundamentals-065",
    "topic": "fundamentals",
    "question": "Что такое memoization?",
    "answer": "Memoization — это техника оптимизации, при которой результат вычислений сохраняется и переиспользуется при повторных вызовах с теми же входными данными, снижая количество дорогостоящих операций."
  },
  {
    "id": "fundamentals-066",
    "topic": "fundamentals",
    "question": "Когда useMemo и useCallback бесполезны?",
    "answer": "useMemo и useCallback бесполезны или вредны, когда вычисления дешёвые, компоненты редко перерисовываются или мемоизация добавляет больше накладных расходов, чем экономии производительности."
  },
  {
    "id": "fundamentals-067",
    "topic": "fundamentals",
    "question": "Что такое Web Vitals?",
    "answer": "Web Vitals — это набор метрик от Google, предназначенных для измерения ключевых аспектов пользовательского опыта, включая скорость загрузки, интерактивность и визуальную стабильность страницы."
  },
  {
    "id": "fundamentals-068",
    "topic": "fundamentals",
    "question": "Что такое LCP?",
    "answer": "LCP (Largest Contentful Paint) — это метрика Web Vitals, которая измеряет время отображения самого крупного видимого элемента контента на странице и отражает скорость загрузки основного содержимого."
  },
  {
    "id": "fundamentals-069",
    "topic": "fundamentals",
    "question": "Что такое CLS?",
    "answer": "CLS (Cumulative Layout Shift) — это метрика, измеряющая суммарное смещение элементов страницы во время загрузки, которое негативно влияет на восприятие стабильности интерфейса."
  },
  {
    "id": "fundamentals-070",
    "topic": "fundamentals",
    "question": "Что такое FID?",
    "answer": "FID (First Input Delay) — это метрика, показывающая время между первым взаимодействием пользователя и фактическим выполнением обработчика события, отражающая отзывчивость страницы."
  },
  {
    "id": "fundamentals-071",
    "topic": "fundamentals",
    "question": "Как frontend влияет на SEO?",
    "answer": "Frontend влияет на SEO через скорость загрузки, корректный SSR или SSG, семантическую HTML-разметку, доступность контента для поисковых роботов, оптимизацию Web Vitals и правильную работу навигации."
  },
  {
    "id": "fundamentals-072",
    "topic": "fundamentals",
    "question": "Что такое accessibility?",
    "answer": "Accessibility или a11y — это практика проектирования и разработки интерфейсов таким образом, чтобы ими могли пользоваться люди с различными ограничениями, включая нарушения зрения, слуха, моторики и когнитивных способностей."
  },
  {
    "id": "fundamentals-073",
    "topic": "fundamentals",
    "question": "Почему доступность важна?",
    "answer": "Доступность важна потому, что делает продукт пригодным для более широкой аудитории, улучшает пользовательский опыт для всех, соответствует юридическим требованиям во многих странах и повышает качество и устойчивость интерфейсов."
  },
  {
    "id": "fundamentals-074",
    "topic": "fundamentals",
    "question": "Как семантический HTML улучшает a11y?",
    "answer": "Семантический HTML улучшает a11y, так как даёт скринридерам и вспомогательным технологиям точную информацию о роли и структуре элементов, позволяя пользователям корректно навигировать и понимать содержимое страницы."
  },
  {
    "id": "fundamentals-075",
    "topic": "fundamentals",
    "question": "Что такое screen reader?",
    "answer": "Screen reader — это вспомогательная технология, которая озвучивает содержимое интерфейса и структуру страницы, позволяя пользователям с нарушениями зрения взаимодействовать с веб-приложениями."
  },
  {
    "id": "fundamentals-076",
    "topic": "fundamentals",
    "question": "Зачем нужен alt?",
    "answer": "Атрибут alt нужен для описания содержания изображения скринридерам, отображения альтернативного текста при ошибке загрузки и улучшения доступности и SEO."
  },
  {
    "id": "fundamentals-077",
    "topic": "fundamentals",
    "question": "Что такое aria-атрибуты?",
    "answer": "ARIA-атрибуты — это специальные атрибуты, которые добавляют или уточняют роль, состояние и свойства элементов интерфейса для вспомогательных технологий, когда семантического HTML недостаточно."
  },
  {
    "id": "fundamentals-078",
    "topic": "fundamentals",
    "question": "Когда нельзя использовать div?",
    "answer": "div не следует использовать, когда существует подходящий семантический тег, например button, nav, header или main, так как это ухудшает доступность и требует дополнительной настройки ролей и клавиатурного управления."
  },
  {
    "id": "fundamentals-079",
    "topic": "fundamentals",
    "question": "Как проверить доступность сайта?",
    "answer": "Доступность сайта проверяется с помощью автоматических инструментов, таких как Lighthouse и axe, ручного тестирования с клавиатуры, проверки контраста, а также тестирования со скринридерами."
  },
  {
    "id": "fundamentals-080",
    "topic": "fundamentals",
    "question": "Что такое XSS?",
    "answer": "XSS (Cross-Site Scripting) — это уязвимость безопасности, при которой злоумышленник внедряет вредоносный JavaScript-код в страницу, чтобы выполнить его в браузере пользователя и получить доступ к данным, cookies или сессии."
  },
  {
    "id": "fundamentals-081",
    "topic": "fundamentals",
    "question": "Что такое CSRF?",
    "answer": "CSRF (Cross-Site Request Forgery) — это атака, при которой злоумышленник заставляет браузер авторизованного пользователя отправить нежелательный запрос к серверу от его имени, используя автоматически прикрепляемые cookies."
  },
  {
    "id": "fundamentals-082",
    "topic": "fundamentals",
    "question": "Почему нельзя доверять данным с клиента?",
    "answer": "Данным с клиента нельзя доверять, потому что пользователь может изменить их вручную, отправить произвольный запрос или подменить параметры, поэтому все данные должны валидироваться и проверяться на сервере."
  },
  {
    "id": "fundamentals-083",
    "topic": "fundamentals",
    "question": "Где безопасно хранить токены?",
    "answer": "Наиболее безопасным способом хранения токенов является использование HttpOnly cookies с флагами Secure и SameSite, так как они недоступны JavaScript и защищены от XSS-атак."
  },
  {
    "id": "fundamentals-084",
    "topic": "fundamentals",
    "question": "Чем cookies отличаются от localStorage?",
    "answer": "Cookies автоматически отправляются с каждым HTTP-запросом и могут быть защищены флагами безопасности, тогда как localStorage доступен через JavaScript, не отправляется на сервер автоматически и более уязвим для XSS."
  },
  {
    "id": "fundamentals-085",
    "topic": "fundamentals",
    "question": "Почему опасно хранить JWT в localStorage?",
    "answer": "Хранить JWT в localStorage опасно, потому что при XSS-атаке злоумышленник может получить доступ к токену и полностью скомпрометировать аккаунт пользователя без возможности ограничения доступа."
  },
  {
    "id": "fundamentals-086",
    "topic": "fundamentals",
    "question": "Чем npm отличается от yarn?",
    "answer": "npm и yarn — это менеджеры пакетов для JavaScript, при этом yarn изначально делал упор на скорость и детерминированность установок через lock-файл, а npm со временем получил схожие возможности и теснее интегрирован с экосистемой Node.js."
  },
  {
    "id": "fundamentals-087",
    "topic": "fundamentals",
    "question": "Что такое package.json?",
    "answer": "package.json — это конфигурационный файл проекта, в котором описаны зависимости, скрипты, метаданные проекта, версии пакетов и настройки, необходимые для сборки и запуска приложения."
  },
  {
    "id": "fundamentals-088",
    "topic": "fundamentals",
    "question": "Что такое devDependencies?",
    "answer": "devDependencies — это зависимости, которые нужны только в процессе разработки и сборки проекта, такие как линтеры, форматтеры и инструменты тестирования, и не требуются для работы приложения в production."
  },
  {
    "id": "fundamentals-089",
    "topic": "fundamentals",
    "question": "Зачем нужен ESLint?",
    "answer": "ESLint используется для статического анализа кода, поиска потенциальных ошибок, соблюдения единых правил код-стайла и предотвращения проблем ещё до выполнения приложения."
  },
  {
    "id": "fundamentals-090",
    "topic": "fundamentals",
    "question": "Зачем нужен Prettier?",
    "answer": "Prettier автоматически форматирует код по заданным правилам, устраняя споры о стиле, улучшая читаемость и обеспечивая единообразие кода в команде."
  },
  {
    "id": "fundamentals-091",
    "topic": "fundamentals",
    "question": "Что такое environment variables?",
    "answer": "Environment variables — это переменные окружения, используемые для хранения конфигурации и чувствительных данных, таких как ключи API и адреса сервисов, без жёсткого встраивания их в код."
  },
  {
    "id": "fundamentals-092",
    "topic": "fundamentals",
    "question": "Чем Vite отличается от Webpack?",
    "answer": "Vite использует ES-модули и dev-сервер без предварительной сборки для мгновенного старта разработки, тогда как Webpack собирает бандл заранее и предоставляет более гибкую, но сложную систему конфигурации."
  },
  {
    "id": "fundamentals-093",
    "topic": "fundamentals",
    "question": "Что такое build?",
    "answer": "Build — это процесс преобразования исходного кода приложения в оптимизированные файлы для production, включающий сборку бандлов, минификацию, оптимизацию ресурсов и подготовку к деплою."
  },
  {
    "id": "fundamentals-094",
    "topic": "fundamentals",
    "question": "Чем dev-сборка отличается от prod?",
    "answer": "Dev-сборка ориентирована на удобство разработки и включает sourcemaps и подробные ошибки, тогда как prod-сборка оптимизирована для производительности, использует минификацию, tree shaking и исключает лишний код."
  }
]
