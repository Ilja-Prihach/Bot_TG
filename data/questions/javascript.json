[
  {
    "id": "js-001",
    "topic": "javascript",
    "question": "Что такое JavaScript?",
    "answer": "JavaScript — это высокоуровневый интерпретируемый язык программирования, который используется для создания интерактивного поведения в веб-приложениях, поддерживает событийную модель, асинхронность и может выполняться как в браузере, так и на сервере."
  },
  {
    "id": "js-002",
    "topic": "javascript",
    "question": "Где и как выполняется JavaScript?",
    "answer": "JavaScript выполняется в среде выполнения, такой как браузер или Node.js, где код интерпретируется JavaScript-движком, например V8, который читает, компилирует и выполняет код, обеспечивая доступ к Web API или серверным возможностям."
  },
  {
    "id": "js-003",
    "topic": "javascript",
    "question": "Чем var отличается от let и const?",
    "answer": "var имеет функциональную область видимости и подвержен hoisting с инициализацией undefined, тогда как let и const имеют блочную область видимости, не доступны до объявления, при этом const запрещает переназначение переменной, но не изменение содержимого объектов."
  },
  {
    "id": "js-004",
    "topic": "javascript",
    "question": "Что такое типы данных в JavaScript?",
    "answer": "Типы данных в JavaScript определяют, какие значения может принимать переменная и какие операции с ними возможны, при этом язык поддерживает как примитивные типы, так и объекты для хранения более сложных структур данных."
  },
  {
    "id": "js-005",
    "topic": "javascript",
    "question": "Какие типы данных являются примитивами?",
    "answer": "К примитивным типам данных в JavaScript относятся string, number, boolean, null, undefined, symbol и bigint, которые являются неизменяемыми и передаются по значению, а не по ссылке."
  },
  {
    "id": "js-006",
    "topic": "javascript",
    "question": "Чем null отличается от undefined?",
    "answer": "undefined означает, что переменная была объявлена, но ей не присвоено значение, тогда как null является явным значением, которое используется разработчиком для обозначения отсутствия значения."
  },
  {
    "id": "js-007",
    "topic": "javascript",
    "question": "Что такое NaN?",
    "answer": "NaN означает Not-a-Number и представляет собой специальное числовое значение, которое возникает в результате некорректных математических операций, например при попытке преобразовать нечисловую строку в число."
  },
  {
    "id": "js-008",
    "topic": "javascript",
    "question": "Как проверить тип значения?",
    "answer": "Тип значения в JavaScript можно проверить с помощью оператора typeof, метода Array.isArray для массивов, оператора instanceof или сравнения с null, так как typeof null возвращает object."
  },
  {
    "id": "js-009",
    "topic": "javascript",
    "question": "Что такое динамическая типизация?",
    "answer": "Динамическая типизация означает, что тип переменной в JavaScript определяется во время выполнения программы и может изменяться в процессе работы, так как переменная не привязана к одному типу данных."
  },
  {
    "id": "js-010",
    "topic": "javascript",
    "question": "Что такое строгий режим (\"use strict\")?",
    "answer": "Строгий режим в JavaScript включает более жёсткие правила выполнения кода, предотвращает использование потенциально опасных конструкций, запрещает неявное создание глобальных переменных и помогает находить ошибки на раннем этапе."
  },
  {
    "id": "js-011",
    "topic": "javascript",
    "question": "Чем == отличается от ===?",
    "answer": "Оператор == выполняет неявное приведение типов перед сравнением значений, что может приводить к неожиданным результатам, тогда как === сравнивает значения строго без приведения типов, проверяя и тип, и значение, поэтому === считается более безопасным и предпочтительным."
  },
  {
    "id": "js-012",
    "topic": "javascript",
    "question": "Что такое неявное приведение типов?",
    "answer": "Неявное приведение типов — это автоматическое преобразование одного типа данных в другой, которое JavaScript выполняет при операциях сравнения, арифметики или логических выражениях, что может упрощать код, но часто становится источником ошибок."
  },
  {
    "id": "js-013",
    "topic": "javascript",
    "question": "Какие значения приводятся к false?",
    "answer": "К false при приведении к boolean приводятся следующие значения: false, 0, -0, 0n, пустая строка, null, undefined и NaN, все остальные значения считаются truthy."
  },
  {
    "id": "js-014",
    "topic": "javascript",
    "question": "Что вернёт Boolean([]) и почему?",
    "answer": "Boolean([]) вернёт true, потому что массив является объектом, а все объекты в JavaScript при приведении к boolean считаются truthy независимо от их содержимого."
  },
  {
    "id": "js-015",
    "topic": "javascript",
    "question": "Что произойдёт при сложении строки и числа?",
    "answer": "При сложении строки и числа JavaScript приведёт число к строке и выполнит конкатенацию, так как оператор + при наличии строки работает как оператор объединения строк."
  },
  {
    "id": "js-016",
    "topic": "javascript",
    "question": "Как работает оператор +?",
    "answer": "Оператор + в JavaScript выполняет либо арифметическое сложение, либо конкатенацию строк, и если хотя бы один из операндов является строкой, происходит приведение второго операнда к строке и выполняется объединение."
  },
  {
    "id": "js-017",
    "topic": "javascript",
    "question": "Чем отличается Object.is от ===?",
    "answer": "Object.is работает почти так же, как ===, но корректно различает NaN и NaN как равные и считает +0 и -0 разными значениями, тогда как === считает NaN неравным самому себе и +0 и -0 равными."
  },
  {
    "id": "js-018",
    "topic": "javascript",
    "question": "Что такое scope?",
    "answer": "Scope — это область видимости переменных и функций в JavaScript, которая определяет, где в коде можно получить доступ к объявленным идентификаторам и какие значения будут использованы при обращении к ним."
  },
  {
    "id": "js-019",
    "topic": "javascript",
    "question": "Какие виды scope существуют?",
    "answer": "В JavaScript существуют глобальный scope, функциональный scope и блочный scope, где глобальный доступен везде, функциональный ограничен телом функции, а блочный применяется к конструкциям вроде if, for и доступен для let и const."
  },
  {
    "id": "js-020",
    "topic": "javascript",
    "question": "Что такое lexical scope?",
    "answer": "Lexical scope — это правило, согласно которому область видимости переменных определяется местом их объявления в исходном коде, а не местом вызова функции, поэтому вложенные функции имеют доступ к переменным внешних областей."
  },
  {
    "id": "js-021",
    "topic": "javascript",
    "question": "Что такое hoisting?",
    "answer": "Hoisting — это механизм JavaScript, при котором объявления переменных и функций обрабатываются до выполнения кода, из-за чего функции и переменные, объявленные через var, доступны до строки их объявления в коде."
  },
  {
    "id": "js-022",
    "topic": "javascript",
    "question": "Что поднимается при hoisting?",
    "answer": "При hoisting поднимаются объявления функций целиком и объявления переменных, при этом переменные, объявленные через var, инициализируются значением undefined, а let и const поднимаются, но остаются недоступными до фактического объявления из-за temporal dead zone."
  },
  {
    "id": "js-023",
    "topic": "javascript",
    "question": "Что такое замыкание?",
    "answer": "Замыкание — это механизм, при котором функция запоминает и имеет доступ к переменным из своей внешней лексической области видимости даже после того, как внешняя функция завершила выполнение."
  },
  {
    "id": "js-024",
    "topic": "javascript",
    "question": "Где на практике используются замыкания?",
    "answer": "Замыкания на практике используются для инкапсуляции данных, создания приватных переменных, реализации фабричных функций, мемоизации, обработки событий и сохранения состояния между вызовами функций."
  },
  {
    "id": "js-025",
    "topic": "javascript",
    "question": "Какие проблемы могут быть с замыканиями?",
    "answer": "Проблемы с замыканиями могут возникать из-за удержания ссылок на переменные и объекты, что приводит к утечкам памяти, а также из-за непонимания области видимости, что может вызывать логические ошибки и неожиданные значения."
  },
  {
    "id": "js-026",
    "topic": "javascript",
    "question": "Какие способы объявления функций ты знаешь?",
    "answer": "В JavaScript функции можно объявлять с помощью function declaration, function expression, arrow function, а также создавать методы объектов и классов, при этом каждый способ имеет особенности области видимости, hoisting и контекста this."
  },
  {
    "id": "js-027",
    "topic": "javascript",
    "question": "Чем function declaration отличается от function expression?",
    "answer": "Function declaration поднимается целиком при hoisting и может быть вызвана до места объявления в коде, тогда как function expression создаётся во время выполнения и доступна только после присваивания переменной."
  },
  {
    "id": "js-028",
    "topic": "javascript",
    "question": "Что такое arrow function?",
    "answer": "Arrow function — это сокращённый синтаксис объявления функции, введённый в ES6, который упрощает запись функций и не создаёт собственного контекста this, arguments, super и new.target."
  },
  {
    "id": "js-029",
    "topic": "javascript",
    "question": "Чем arrow function отличается от обычной функции?",
    "answer": "Arrow function отличается тем, что не имеет собственного this и берёт его из внешнего лексического окружения, не поддерживает вызов через new и не имеет собственного arguments, тогда как обычная функция формирует собственный контекст выполнения."
  },
  {
    "id": "js-030",
    "topic": "javascript",
    "question": "Что такое параметры по умолчанию?",
    "answer": "Параметры по умолчанию позволяют задавать значения аргументов функции прямо в сигнатуре, которые будут использоваться в случае, если соответствующий аргумент не был передан или равен undefined."
  },
  {
    "id": "js-031",
    "topic": "javascript",
    "question": "Что такое rest-параметры?",
    "answer": "Rest-параметры позволяют собрать произвольное количество аргументов функции в массив с помощью оператора ..., что делает работу с переменным числом аргументов более удобной и предсказуемой."
  },
  {
    "id": "js-032",
    "topic": "javascript",
    "question": "Что такое arguments?",
    "answer": "arguments — это псевдомассив, доступный внутри обычных функций, который содержит все переданные аргументы, но не поддерживается в arrow function и считается устаревшим по сравнению с rest-параметрами."
  },
  {
    "id": "js-033",
    "topic": "javascript",
    "question": "Что такое чистая функция?",
    "answer": "Чистая функция — это функция, которая при одинаковых входных данных всегда возвращает одинаковый результат и не имеет побочных эффектов, то есть не изменяет внешнее состояние и не зависит от него."
  },
  {
    "id": "js-034",
    "topic": "javascript",
    "question": "Что такое this?",
    "answer": "this — это специальное ключевое слово в JavaScript, которое указывает на объект, в контексте которого была вызвана функция, и используется для доступа к данным и методам этого объекта во время выполнения кода."
  },
  {
    "id": "js-035",
    "topic": "javascript",
    "question": "От чего зависит значение this?",
    "answer": "Значение this зависит от способа вызова функции: при вызове как метода объекта this указывает на объект, при обычном вызове функции — на глобальный объект или undefined в строгом режиме, при использовании new — на создаваемый экземпляр, а при call, apply и bind — на явно переданный объект."
  },
  {
    "id": "js-036",
    "topic": "javascript",
    "question": "Как работает this в arrow function?",
    "answer": "В arrow function this не создаётся собственный и берётся из внешнего лексического окружения, то есть равен значению this в месте объявления функции, а не в месте её вызова."
  },
  {
    "id": "js-037",
    "topic": "javascript",
    "question": "Что делают call, apply и bind?",
    "answer": "Методы call, apply и bind позволяют явно задать значение this для функции, где call и apply сразу вызывают функцию с указанным контекстом, а bind возвращает новую функцию с навсегда привязанным this."
  },
  {
    "id": "js-038",
    "topic": "javascript",
    "question": "В чём разница между call и apply?",
    "answer": "Разница между call и apply заключается в способе передачи аргументов, так как call принимает аргументы по отдельности, а apply принимает массив аргументов, при этом оба метода сразу вызывают функцию с заданным this."
  },
  {
    "id": "js-039",
    "topic": "javascript",
    "question": "Можно ли изменить this у arrow function?",
    "answer": "Изменить this у arrow function нельзя, так как она не имеет собственного контекста и всегда использует this из внешней области видимости, поэтому методы call, apply и bind на неё не влияют."
  },
  {
    "id": "js-040",
    "topic": "javascript",
    "question": "Как создать объект в JavaScript?",
    "answer": "Объект в JavaScript можно создать с помощью литерала объекта {}, конструктора Object, функции-конструктора с оператором new, метода Object.create для явного указания прототипа или с использованием синтаксиса class, который под капотом также работает через прототипы."
  },
  {
    "id": "js-041",
    "topic": "javascript",
    "question": "Что такое прототип?",
    "answer": "Прототип — это объект, из которого другие объекты могут наследовать свойства и методы, и он используется JavaScript для реализации наследования и повторного использования функциональности."
  },
  {
    "id": "js-042",
    "topic": "javascript",
    "question": "Что такое prototype chain?",
    "answer": "Prototype chain — это цепочка прототипов, по которой JavaScript ищет свойство или метод, начиная с самого объекта и поднимаясь по его прототипам до Object.prototype или null."
  },
  {
    "id": "js-043",
    "topic": "javascript",
    "question": "Как работает наследование в JavaScript?",
    "answer": "Наследование в JavaScript реализуется через прототипы, где один объект ссылается на другой как на свой прототип, благодаря чему он получает доступ к его свойствам и методам без их копирования."
  },
  {
    "id": "js-044",
    "topic": "javascript",
    "question": "Что такое __proto__?",
    "answer": "__proto__ — это внутреннее свойство объекта, которое указывает на его прототип и используется движком JavaScript для поиска свойств в prototype chain, при этом напрямую работать с ним не рекомендуется."
  },
  {
    "id": "js-045",
    "topic": "javascript",
    "question": "Чем класс отличается от функции-конструктора?",
    "answer": "Класс является синтаксическим сахаром над функцией-конструктором и прототипами, предоставляя более читаемый и структурированный синтаксис, при этом под капотом JavaScript продолжает использовать прототипное наследование."
  },
  {
    "id": "js-046",
    "topic": "javascript",
    "question": "Что такое class и что он делает под капотом?",
    "answer": "Class в JavaScript — это синтаксический сахар, который упрощает создание функций-конструкторов и работу с прототипами, автоматически добавляя методы в prototype и настраивая наследование через prototype chain без изменения базовой модели языка."
  },
  {
    "id": "js-047",
    "topic": "javascript",
    "question": "Как скопировать массив?",
    "answer": "Массив можно скопировать с помощью spread-оператора [...arr], метода slice(), Array.from() или map, при этом такие способы создают поверхностную копию, где вложенные объекты продолжают передаваться по ссылке."
  },
  {
    "id": "js-048",
    "topic": "javascript",
    "question": "Чем map отличается от forEach?",
    "answer": "Метод map возвращает новый массив с результатами выполнения функции для каждого элемента и используется для преобразования данных, тогда как forEach просто выполняет функцию для каждого элемента и ничего не возвращает, поэтому чаще применяется для побочных эффектов."
  },
  {
    "id": "js-049",
    "topic": "javascript",
    "question": "Чем filter отличается от find?",
    "answer": "filter возвращает новый массив со всеми элементами, удовлетворяющими условию, тогда как find возвращает только первый найденный элемент или undefined, поэтому filter используют для выборки, а find — для поиска одного значения."
  },
  {
    "id": "js-050",
    "topic": "javascript",
    "question": "Что делает reduce?",
    "answer": "Метод reduce последовательно обрабатывает элементы массива и сводит их к одному значению, которое может быть числом, объектом, массивом или любым другим типом, благодаря чему reduce используется для агрегации данных и сложных преобразований."
  },
  {
    "id": "js-051",
    "topic": "javascript",
    "question": "Мутируют ли массив методы push, splice, sort?",
    "answer": "Методы push, splice и sort мутируют исходный массив, так как изменяют его содержимое напрямую, поэтому при работе с иммутабельными данными их следует использовать осторожно или заменять немутирующими альтернативами."
  },
  {
    "id": "js-052",
    "topic": "javascript",
    "question": "Как проверить, что значение — массив?",
    "answer": "Проверить, что значение является массивом, надёжнее всего с помощью метода Array.isArray, так как typeof возвращает object и не позволяет отличить массив от обычного объекта."
  },
  {
    "id": "js-053",
    "topic": "javascript",
    "question": "Чем массив отличается от объекта?",
    "answer": "Массив является упорядоченной коллекцией значений с числовыми индексами и встроенными методами для работы с последовательностями, тогда как объект представляет собой неупорядоченный набор пар ключ-значение и используется для описания сущностей и структур данных."
  },
  {
    "id": "js-054",
    "topic": "javascript",
    "question": "Что такое асинхронность в JavaScript?",
    "answer": "Асинхронность в JavaScript — это способность выполнять долгие операции, такие как запросы к серверу или таймеры, без блокировки основного потока выполнения, позволяя приложению оставаться отзывчивым и обрабатывать другие задачи параллельно."
  },
  {
    "id": "js-055",
    "topic": "javascript",
    "question": "Что такое callback?",
    "answer": "Callback — это функция, которая передаётся как аргумент другой функции и вызывается позже, обычно после завершения асинхронной операции, для обработки её результата."
  },
  {
    "id": "js-056",
    "topic": "javascript",
    "question": "Какие проблемы есть у callback?",
    "answer": "Основные проблемы callback — это callback hell из-за глубокой вложенности, сложность обработки ошибок, плохая читаемость кода и трудности с масштабированием асинхронной логики."
  },
  {
    "id": "js-057",
    "topic": "javascript",
    "question": "Что такое Promise?",
    "answer": "Promise — это объект, представляющий результат асинхронной операции, который позволяет описывать последовательность асинхронных действий и обрабатывать их результаты или ошибки более читаемым и управляемым способом."
  },
  {
    "id": "js-058",
    "topic": "javascript",
    "question": "Какие состояния есть у Promise?",
    "answer": "Promise может находиться в трёх состояниях: pending — ожидание результата, fulfilled — успешное выполнение с результатом и rejected — завершение с ошибкой."
  },
  {
    "id": "js-059",
    "topic": "javascript",
    "question": "Что такое async / await?",
    "answer": "async / await — это синтаксический сахар над Promise, который позволяет писать асинхронный код в стиле синхронного, делая его более читаемым и упрощая работу с последовательными асинхронными операциями."
  },
  {
    "id": "js-060",
    "topic": "javascript",
    "question": "Чем async / await лучше Promise chaining?",
    "answer": "async / await улучшает читаемость кода, снижает уровень вложенности, упрощает обработку ошибок через try/catch и делает асинхронную логику более похожей на обычный синхронный код по сравнению с цепочками then."
  },
  {
    "id": "js-061",
    "topic": "javascript",
    "question": "Как обрабатывать ошибки в асинхронном коде?",
    "answer": "Ошибки в асинхронном коде обрабатываются с помощью catch у Promise или конструкции try/catch при использовании async / await, при этом важно учитывать как синхронные, так и асинхронные исключения."
  },
  {
    "id": "js-062",
    "topic": "javascript",
    "question": "Что такое event loop?",
    "answer": "Event loop — это механизм JavaScript, который управляет выполнением кода, очередями задач и асинхронных операций, обеспечивая выполнение синхронного кода, microtask и macrotask в определённом порядке."
  },
  {
    "id": "js-063",
    "topic": "javascript",
    "question": "Что такое microtask и macrotask?",
    "answer": "Microtask — это задачи с более высоким приоритетом, такие как обработчики Promise, тогда как macrotask включают setTimeout, setInterval и события браузера, и event loop сначала выполняет все microtask, а затем одну macrotask."
  },
  {
    "id": "js-064",
    "topic": "javascript",
    "question": "В каком порядке выполняются setTimeout, Promise и sync-код?",
    "answer": "Сначала выполняется весь синхронный код, затем выполняются все microtask из Promise, и только после этого event loop переходит к выполнению macrotask, таких как callbacks из setTimeout."
  },
  {
    "id": "js-065",
    "topic": "javascript",
    "question": "Что такое сборщик мусора?",
    "answer": "Сборщик мусора — это механизм JavaScript-движка, который автоматически освобождает память, удаляя объекты, на которые больше нет ссылок и которые недостижимы из корневых объектов, тем самым предотвращая бесконтрольный рост использования памяти."
  },
  {
    "id": "js-066",
    "topic": "javascript",
    "question": "Какие типы утечек памяти ты знаешь?",
    "answer": "К основным типам утечек памяти относятся забытые таймеры и подписки, глобальные переменные, неочищенные обработчики событий, удерживаемые DOM-узлы и замыкания, которые продолжают ссылаться на ненужные объекты."
  },
  {
    "id": "js-067",
    "topic": "javascript",
    "question": "Как замыкания могут приводить к утечкам?",
    "answer": "Замыкания могут приводить к утечкам памяти, когда функция сохраняет ссылки на переменные или объекты из внешней области видимости и продолжает удерживать их в памяти даже после того, как они логически больше не нужны."
  },
  {
    "id": "js-068",
    "topic": "javascript",
    "question": "Что такое модуль в JavaScript?",
    "answer": "Модуль в JavaScript — это изолированный файл с собственным scope, который позволяет структурировать код, явно экспортировать публичный API и импортировать зависимости, улучшая читаемость, переиспользуемость и поддержку приложения."
  },
  {
    "id": "js-069",
    "topic": "javascript",
    "question": "Чем import отличается от require?",
    "answer": "import является частью стандарта ES Modules и работает статически на этапе загрузки модуля, тогда как require относится к CommonJS, выполняется динамически во время выполнения кода и чаще используется в Node.js, при этом import поддерживает tree-shaking и более строгую структуру модулей."
  },
  {
    "id": "js-070",
    "topic": "javascript",
    "question": "Что такое named и default export?",
    "answer": "Named export позволяет экспортировать несколько сущностей из модуля по именам и импортировать их с теми же именами, тогда как default export предназначен для экспорта одного основного значения и может быть импортирован под любым именем."
  },
  {
    "id": "js-071",
    "topic": "javascript",
    "question": "Когда код выполняется при импорте модуля?",
    "answer": "Код модуля выполняется один раз в момент его первого импорта, после чего результат выполнения кэшируется, и при последующих импортах используется уже инициализированный экземпляр модуля."
  },
  {
    "id": "js-072",
    "topic": "javascript",
    "question": "Какие типы ошибок существуют в JavaScript?",
    "answer": "В JavaScript существуют синтаксические ошибки, которые возникают при разборе кода, runtime-ошибки, возникающие во время выполнения, а также логические ошибки, когда код выполняется без сбоев, но даёт неверный результат; кроме того, есть встроенные типы ошибок, такие как ReferenceError, TypeError, SyntaxError, RangeError и Error."
  },
  {
    "id": "js-073",
    "topic": "javascript",
    "question": "Чем throw отличается от return?",
    "answer": "return завершает выполнение функции и возвращает значение вызывающему коду, тогда как throw прерывает нормальный поток выполнения и генерирует исключение, которое должно быть перехвачено с помощью try / catch или приведёт к ошибке выполнения."
  },
  {
    "id": "js-074",
    "topic": "javascript",
    "question": "Как работает try / catch?",
    "answer": "try / catch оборачивает потенциально опасный код, где try содержит выполнение, которое может выбросить ошибку, а catch перехватывает это исключение и позволяет обработать его без остановки программы, при этом блок finally выполняется всегда независимо от результата."
  },
  {
    "id": "js-075",
    "topic": "javascript",
    "question": "Можно ли ловить async-ошибки через try / catch?",
    "answer": "Да, ошибки в асинхронном коде можно ловить через try / catch при использовании async / await, так как отклонённый Promise автоматически преобразуется в исключение, тогда как при работе с then необходимо использовать метод catch."
  },
  {
    "id": "js-076",
    "topic": "javascript",
    "question": "Почему 0.1 + 0.2 !== 0.3?",
    "answer": "0.1 + 0.2 !== 0.3 из-за особенностей представления чисел с плавающей точкой в формате IEEE 754, где десятичные дроби не могут быть точно представлены в бинарной системе, что приводит к накоплению погрешности при вычислениях."
  },
  {
    "id": "js-077",
    "topic": "javascript",
    "question": "Почему typeof null === \"object\"?",
    "answer": "typeof null возвращает \"object\" из-за исторической ошибки в ранней реализации JavaScript, где null был представлен как нулевой указатель, и это поведение сохранено для обратной совместимости."
  },
  {
    "id": "js-078",
    "topic": "javascript",
    "question": "Что вернёт [] == []?",
    "answer": "Выражение [] == [] вернёт false, потому что массивы являются объектами и при сравнении по ссылке сравниваются разные участки памяти, даже если их содержимое одинаково."
  },
  {
    "id": "js-079",
    "topic": "javascript",
    "question": "Что вернёт {} + {}?",
    "answer": "Выражение {} + {} в глобальном контексте обычно интерпретируется как пустой блок кода плюс пустой объект и возвращает строку \"[object Object]\", однако результат зависит от контекста выполнения и может отличаться."
  },
  {
    "id": "js-080",
    "topic": "javascript",
    "question": "Почему функции — объекты?",
    "answer": "Функции в JavaScript являются объектами, потому что они могут иметь свойства, методы и прототип, а также передаваться как значения, что позволяет использовать их как данные и реализовывать функциональные паттерны."
  },
  {
    "id": "js-081",
    "topic": "javascript",
    "question": "Что произойдёт при изменении объекта через ссылку?",
    "answer": "При изменении объекта через ссылку изменения отразятся во всех переменных, которые ссылаются на этот объект, так как объекты в JavaScript передаются и хранятся по ссылке, а не копируются."
  },
  {
    "id": "js-082",
    "topic": "javascript",
    "question": "Как сделать глубокую копию объекта?",
    "answer": "Глубокую копию объекта можно сделать с помощью structuredClone, рекурсивного копирования, библиотек вроде lodash cloneDeep или через JSON.parse(JSON.stringify()), при этом последний способ имеет ограничения и не поддерживает функции, даты и undefined."
  },
  {
    "id": "js-083",
    "topic": "javascript",
    "question": "Чем shallow copy отличается от deep copy?",
    "answer": "Shallow copy копирует только верхний уровень объекта и сохраняет ссылки на вложенные объекты, тогда как deep copy полностью копирует всю структуру данных, создавая новые экземпляры для всех вложенных объектов."
  },
  {
    "id": "js-084",
    "topic": "javascript",
    "question": "Как проверить, есть ли свойство у объекта?",
    "answer": "Наличие свойства у объекта можно проверить с помощью оператора in, метода hasOwnProperty или Object.hasOwn, при этом важно учитывать разницу между собственными и унаследованными свойствами."
  },
  {
    "id": "js-085",
    "topic": "javascript",
    "question": "Почему важно не мутировать данные?",
    "answer": "Не мутировать данные важно для предсказуемости поведения программы, упрощения отладки, корректной работы механизмов сравнения и оптимизации, а также для правильной работы библиотек и фреймворков, таких как React, которые полагаются на иммутабельность."
  },
  {
    "id": "js-086",
    "topic": "javascript",
    "question": "Что такое DOM?",
    "answer": "DOM (Document Object Model) — это объектное представление HTML-документа в виде дерева узлов, которое браузер создаёт для того, чтобы JavaScript мог читать, изменять структуру, содержимое и стили страницы динамически."
  },
  {
    "id": "js-087",
    "topic": "javascript",
    "question": "Чем DOMContentLoaded отличается от load?",
    "answer": "DOMContentLoaded срабатывает, когда HTML-документ полностью загружен и разобран, но внешние ресурсы вроде изображений и стилей могут ещё загружаться, тогда как событие load происходит только после полной загрузки всех ресурсов страницы."
  },
  {
    "id": "js-088",
    "topic": "javascript",
    "question": "Что такое bubbling и capturing?",
    "answer": "Bubbling и capturing — это фазы распространения события в DOM, где capturing идёт сверху вниз от window к целевому элементу, а bubbling — снизу вверх от целевого элемента к корню документа."
  },
  {
    "id": "js-089",
    "topic": "javascript",
    "question": "Как работает делегирование событий?",
    "answer": "Делегирование событий основано на фазе всплытия и заключается в том, что обработчик вешается на общий родительский элемент, который перехватывает события от дочерних элементов и определяет источник события через event.target."
  },
  {
    "id": "js-090",
    "topic": "javascript",
    "question": "Что такое localStorage, sessionStorage и cookies?",
    "answer": "localStorage и sessionStorage — это Web Storage API для хранения данных в браузере в виде строк, где localStorage сохраняется бессрочно, а sessionStorage очищается при закрытии вкладки, тогда как cookies — это небольшие данные, которые отправляются с каждым HTTP-запросом на сервер."
  },
  {
    "id": "js-091",
    "topic": "javascript",
    "question": "Чем localStorage отличается от cookies?",
    "answer": "localStorage хранит больше данных, не отправляется автоматически на сервер и используется только на клиенте, тогда как cookies имеют меньший размер, автоматически передаются с HTTP-запросами и часто применяются для аутентификации и серверных сценариев."
  }
]
