[
  {
    "id": "next-001",
    "topic": "nextjs",
    "question": "Что такое Next.js?",
    "answer": "Next.js — это React-фреймворк для production-приложений, который предоставляет готовую инфраструктуру для серверного рендеринга, статической генерации, маршрутизации, оптимизации и работы с бэкендом поверх React."
  },
  {
    "id": "next-002",
    "topic": "nextjs",
    "question": "Чем Next.js отличается от обычного React-приложения?",
    "answer": "В отличие от обычного React-приложения, которое рендерится только на клиенте, Next.js поддерживает SSR и SSG, имеет встроенный роутинг, оптимизацию производительности и возможность выполнять код на сервере."
  },
  {
    "id": "next-003",
    "topic": "nextjs",
    "question": "Какие основные возможности Next.js ты знаешь?",
    "answer": "Основные возможности Next.js включают серверный и статический рендеринг, file-based routing, API routes, оптимизацию изображений и шрифтов, code splitting, middleware и поддержку Edge Runtime."
  },
  {
    "id": "next-004",
    "topic": "nextjs",
    "question": "Зачем использовать Next.js вместо CRA / Vite?",
    "answer": "Next.js используют вместо CRA или Vite, когда требуется SEO, быстрый первый рендер, серверная логика, удобная маршрутизация и готовые production-инструменты без ручной настройки инфраструктуры."
  },
  {
    "id": "next-005",
    "topic": "nextjs",
    "question": "Что такое file-based routing?",
    "answer": "File-based routing — это механизм маршрутизации, при котором структура URL автоматически формируется на основе структуры файлов и папок в директории pages или app без необходимости ручного описания роутов."
  },
  {
    "id": "next-006",
    "topic": "nextjs",
    "question": "Как работает роутинг в Next.js?",
    "answer": "Роутинг в Next.js основан на файловой системе, где каждый файл или папка в директории pages или app автоматически становится маршрутом, а навигация между страницами выполняется без перезагрузки с помощью компонента Link и встроенного роутера."
  },
  {
    "id": "next-007",
    "topic": "nextjs",
    "question": "В чём разница между pages router и app router?",
    "answer": "Pages router использует директорию pages и классическую модель с getServerSideProps и getStaticProps, тогда как app router основан на директории app, поддерживает Server Components, layouts, streaming и более гибкую модель data fetching."
  },
  {
    "id": "next-008",
    "topic": "nextjs",
    "question": "Что такое dynamic routes?",
    "answer": "Dynamic routes — это динамические маршруты, которые создаются с помощью файлов с квадратными скобками, например [id].js или [slug], и позволяют обрабатывать URL с переменными параметрами."
  },
  {
    "id": "next-009",
    "topic": "nextjs",
    "question": "Как создать вложенные роуты?",
    "answer": "Вложенные роуты создаются путём вложенности папок в pages или app, где каждая папка формирует часть URL, а в app router дополнительно используются layout.tsx для общего интерфейса вложенных маршрутов."
  },
  {
    "id": "next-010",
    "topic": "nextjs",
    "question": "Как работает catch-all routing?",
    "answer": "Catch-all routing позволяет обрабатывать произвольное количество сегментов URL с помощью файлов вида [...slug] или [[...slug]], где параметры собираются в массив и используются для динамической логики маршрута."
  },
  {
    "id": "next-011",
    "topic": "nextjs",
    "question": "Какие типы рендеринга есть в Next.js?",
    "answer": "В Next.js существуют CSR (Client-Side Rendering), SSR (Server-Side Rendering), SSG (Static Site Generation) и ISR (Incremental Static Regeneration), которые позволяют выбирать оптимальный способ генерации страниц в зависимости от требований к производительности, SEO и актуальности данных."
  },
  {
    "id": "next-012",
    "topic": "nextjs",
    "question": "Что такое SSR?",
    "answer": "SSR — это серверный рендеринг, при котором HTML страницы генерируется на сервере при каждом запросе пользователя, что улучшает SEO и время первого отображения, но увеличивает нагрузку на сервер."
  },
  {
    "id": "next-013",
    "topic": "nextjs",
    "question": "Что такое SSG?",
    "answer": "SSG — это статическая генерация страниц во время сборки проекта, при которой HTML создаётся заранее и отдаётся пользователю как статический файл, обеспечивая высокую скорость загрузки и низкую нагрузку на сервер."
  },
  {
    "id": "next-014",
    "topic": "nextjs",
    "question": "Что такое ISR?",
    "answer": "ISR — это гибридный подход, позволяющий пересобирать статические страницы на сервере через заданный интервал времени без полной пересборки проекта, сочетая преимущества SSG и актуальность данных."
  },
  {
    "id": "next-015",
    "topic": "nextjs",
    "question": "В чём разница между CSR, SSR и SSG?",
    "answer": "CSR рендерит страницу полностью в браузере после загрузки JavaScript, SSR генерирует HTML на сервере при каждом запросе, а SSG создаёт HTML заранее на этапе сборки, что влияет на производительность, SEO и нагрузку на сервер."
  },
  {
    "id": "next-016",
    "topic": "nextjs",
    "question": "Когда и что лучше использовать?",
    "answer": "CSR подходит для динамичных интерфейсов без жёстких требований к SEO, SSR — для страниц с часто меняющимися данными и важным SEO, SSG — для контентных и редко обновляемых страниц, а ISR — когда нужна высокая скорость и периодическое обновление данных."
  },
  {
    "id": "next-017",
    "topic": "nextjs",
    "question": "Что такое app directory?",
    "answer": "app directory — это новая структура роутинга в Next.js, основанная на React Server Components, которая позволяет использовать layouts, streaming, вложенные маршруты и более гибкую модель data fetching по сравнению с pages directory."
  },
  {
    "id": "next-018",
    "topic": "nextjs",
    "question": "Что такое Server Components?",
    "answer": "Server Components — это React-компоненты, которые выполняются только на сервере, не попадают в клиентский JavaScript-бандл и могут напрямую обращаться к базе данных, файловой системе и серверным API."
  },
  {
    "id": "next-019",
    "topic": "nextjs",
    "question": "Чем Server Components отличаются от Client Components?",
    "answer": "Server Components рендерятся на сервере и не поддерживают интерактивность и хуки состояния, тогда как Client Components рендерятся на клиенте, поддерживают хуки, события и интерактивное поведение пользователя."
  },
  {
    "id": "next-020",
    "topic": "nextjs",
    "question": "Зачем нужен \"use client\"?",
    "answer": "Директива \"use client\" явно указывает Next.js, что компонент должен быть Client Component, позволяя использовать хуки, обработчики событий и браузерные API внутри этого компонента."
  },
  {
    "id": "next-021",
    "topic": "nextjs",
    "question": "Можно ли использовать хуки в Server Components?",
    "answer": "В Server Components нельзя использовать хуки состояния и эффекты, такие как useState или useEffect, но можно использовать серверные хуки и асинхронные операции для получения данных."
  },
  {
    "id": "next-022",
    "topic": "nextjs",
    "question": "Как данные передаются между Server и Client Components?",
    "answer": "Данные из Server Components передаются в Client Components через props, при этом они сериализуются и передаются только в одну сторону — с сервера на клиент."
  },
  {
    "id": "next-023",
    "topic": "nextjs",
    "question": "Как делать data fetching в Next.js?",
    "answer": "Data fetching в Next.js выполняется либо на сервере в Server Components через async/await и fetch, либо через Route Handlers и Server Actions, а на клиенте в Client Components через useEffect или библиотеки типа React Query, при этом выбор зависит от требований к SEO, интерактивности и актуальности данных."
  },
  {
    "id": "next-024",
    "topic": "nextjs",
    "question": "В чём разница между fetch в Next.js и обычным fetch?",
    "answer": "В Next.js fetch расширен возможностями встроенного кеширования и управления повторной валидацией через параметры cache и next.revalidate, а также может быть автоматически дедуплицирован на сервере, тогда как обычный fetch в браузере не имеет таких фреймворк-уровневых механизмов."
  },
  {
    "id": "next-025",
    "topic": "nextjs",
    "question": "Что такое caching и revalidation?",
    "answer": "Caching — это сохранение результата запроса или страницы для повторного использования без нового обращения к источнику данных, а revalidation — механизм обновления закешированного контента по времени или событию, чтобы данные оставались актуальными."
  },
  {
    "id": "next-026",
    "topic": "nextjs",
    "question": "Как работает revalidate?",
    "answer": "revalidate задаёт интервал в секундах, после которого Next.js может пересоздать закешированный результат запроса или страницы на сервере, позволяя пользователям получать быстрый статический ответ, но с периодическим обновлением данных без полной пересборки приложения."
  },
  {
    "id": "next-027",
    "topic": "nextjs",
    "question": "Что такое generateStaticParams?",
    "answer": "generateStaticParams — это функция в App Router, которая возвращает список параметров для динамических маршрутов и используется для генерации статических страниц на этапе сборки или для предварительного построения популярных маршрутов."
  },
  {
    "id": "next-028",
    "topic": "nextjs",
    "question": "Что такое layout.tsx?",
    "answer": "layout.tsx — это специальный файл в App Router Next.js, который определяет общий интерфейс и обёртку для страниц и вложенных маршрутов, сохраняя своё состояние между переходами."
  },
  {
    "id": "next-029",
    "topic": "nextjs",
    "question": "Чем layout отличается от page?",
    "answer": "page.tsx отвечает за рендер конкретного маршрута и пересоздаётся при навигации, тогда как layout.tsx используется как постоянная обёртка для группы маршрутов и не размонтируется при переходах между ними."
  },
  {
    "id": "next-030",
    "topic": "nextjs",
    "question": "Что такое template.tsx?",
    "answer": "template.tsx похож на layout.tsx, но в отличие от него пересоздаётся при каждой навигации, что делает его полезным для сброса состояния или анимаций при смене маршрута."
  },
  {
    "id": "next-031",
    "topic": "nextjs",
    "question": "Как работают nested layouts?",
    "answer": "Nested layouts работают за счёт вложенности папок, где каждый уровень может иметь свой layout.tsx, и при рендеринге страницы все соответствующие layout-файлы оборачивают page в иерархическом порядке."
  },
  {
    "id": "next-032",
    "topic": "nextjs",
    "question": "Чем Link из Next.js отличается от обычного <a>?",
    "answer": "Link из Next.js выполняет клиентскую навигацию без полной перезагрузки страницы, предварительно подгружает код и данные для маршрута и сохраняет состояние приложения, тогда как обычный тег <a> приводит к полной перезагрузке страницы."
  },
  {
    "id": "next-033",
    "topic": "nextjs",
    "question": "Что такое useRouter?",
    "answer": "useRouter — это хук Next.js, который предоставляет программный доступ к навигации и информации о маршруте, позволяя выполнять переходы, читать параметры URL и управлять историей переходов на клиенте."
  },
  {
    "id": "next-034",
    "topic": "nextjs",
    "question": "Что такое usePathname?",
    "answer": "usePathname — это хук App Router, который возвращает текущий путь URL без query-параметров и используется для определения активных маршрутов или условного рендеринга на клиенте."
  },
  {
    "id": "next-035",
    "topic": "nextjs",
    "question": "Как работает client-side navigation?",
    "answer": "Client-side navigation в Next.js работает за счёт перехвата переходов, динамической загрузки нужных компонентов и данных, обновления URL через History API и частичного обновления интерфейса без перезагрузки страницы."
  },
  {
    "id": "next-036",
    "topic": "nextjs",
    "question": "Что такое API Routes?",
    "answer": "API Routes — это встроенный механизм Next.js, позволяющий создавать серверные эндпоинты внутри проекта для обработки HTTP-запросов, выполнения бизнес-логики и взаимодействия с базами данных без отдельного backend-приложения."
  },
  {
    "id": "next-037",
    "topic": "nextjs",
    "question": "Где и когда выполняются API Routes?",
    "answer": "API Routes выполняются на сервере при каждом HTTP-запросе, либо в Node.js runtime, либо в Edge runtime, в зависимости от конфигурации, и никогда не попадают в клиентский JavaScript-бандл."
  },
  {
    "id": "next-038",
    "topic": "nextjs",
    "question": "Чем API Routes отличаются от backend-сервиса?",
    "answer": "API Routes тесно интегрированы с Next.js-приложением и деплоятся вместе с фронтендом, тогда как полноценный backend-сервис является отдельным приложением, масштабируется независимо и обычно используется для более сложной или нагруженной серверной логики."
  },
  {
    "id": "next-039",
    "topic": "nextjs",
    "question": "Что такое Route Handlers (route.ts)?",
    "answer": "Route Handlers — это современная альтернатива API Routes в App Router, реализуемая через файл route.ts, которая использует Web Fetch API и позволяет обрабатывать HTTP-методы с поддержкой middleware, streaming и Edge runtime."
  },
  {
    "id": "next-040",
    "topic": "nextjs",
    "question": "Зачем нужен компонент Image?",
    "answer": "Компонент Image в Next.js используется для автоматической оптимизации изображений, включая адаптивные размеры, lazy loading, сжатие, использование современных форматов и предотвращение layout shift для улучшения производительности."
  },
  {
    "id": "next-041",
    "topic": "nextjs",
    "question": "Что делает компонент Script?",
    "answer": "Компонент Script управляет загрузкой сторонних и пользовательских скриптов, позволяя контролировать стратегию их выполнения, такую как beforeInteractive, afterInteractive или lazyOnload, для оптимизации производительности."
  },
  {
    "id": "next-042",
    "topic": "nextjs",
    "question": "Как работает code splitting в Next.js?",
    "answer": "Code splitting в Next.js работает автоматически на уровне маршрутов и компонентов, загружая только необходимый JavaScript для текущей страницы и динамически подгружая остальной код при навигации или по требованию."
  },
  {
    "id": "next-043",
    "topic": "nextjs",
    "question": "Что такое prefetch?",
    "answer": "Prefetch — это механизм предварительной загрузки ресурсов следующего маршрута в фоне, который Next.js использует для ускорения навигации, подгружая код и данные до фактического перехода пользователя."
  },
  {
    "id": "next-044",
    "topic": "nextjs",
    "question": "Какие способы стилизации поддерживает Next.js?",
    "answer": "Next.js поддерживает глобальные CSS-файлы, CSS Modules, SCSS и Sass Modules, CSS-in-JS библиотеки, такие как styled-components и emotion, а также Tailwind CSS и inline-стили."
  },
  {
    "id": "next-045",
    "topic": "nextjs",
    "question": "Как работают CSS Modules в Next.js?",
    "answer": "CSS Modules в Next.js изолируют стили на уровне компонента, автоматически генерируя уникальные имена классов, что предотвращает конфликты стилей и позволяет безопасно использовать одинаковые имена классов в разных файлах."
  },
  {
    "id": "next-046",
    "topic": "nextjs",
    "question": "Можно ли использовать SCSS?",
    "answer": "Да, Next.js поддерживает SCSS и Sass из коробки, включая глобальные SCSS-файлы и SCSS Modules, без дополнительной настройки сборщика."
  },
  {
    "id": "next-047",
    "topic": "nextjs",
    "question": "Как стили работают в Server Components?",
    "answer": "В Server Components стили применяются во время серверного рендера и передаются в HTML, при этом поддерживаются CSS Modules и глобальные стили, а сами стили не увеличивают клиентский JavaScript-бандл."
  },
  {
    "id": "next-048",
    "topic": "nextjs",
    "question": "Что такое Middleware в Next.js?",
    "answer": "Middleware в Next.js — это функция, которая выполняется до обработки запроса страницей или API и позволяет перехватывать запросы, изменять ответы или выполнять логику до рендера."
  },
  {
    "id": "next-049",
    "topic": "nextjs",
    "question": "Где выполняется Middleware?",
    "answer": "Middleware выполняется на сервере в Edge Runtime максимально близко к пользователю, что позволяет быстро обрабатывать запросы без полного Node.js окружения."
  },
  {
    "id": "next-050",
    "topic": "nextjs",
    "question": "Какие задачи решает Middleware?",
    "answer": "Middleware используется для аутентификации и авторизации, редиректов, A/B тестирования, локализации, логирования, защиты маршрутов и модификации заголовков запросов и ответов."
  },
  {
    "id": "next-051",
    "topic": "nextjs",
    "question": "Как защитить страницу от неавторизованного доступа?",
    "answer": "Страницу в Next.js можно защитить с помощью проверки авторизации на сервере через Middleware, Server Components или Route Handlers, выполняя редирект или возвращая ошибку до рендера контента."
  },
  {
    "id": "next-052",
    "topic": "nextjs",
    "question": "Как реализовать авторизацию в Next.js?",
    "answer": "Авторизация в Next.js обычно реализуется с помощью cookies или токенов, проверяемых на сервере, часто с использованием библиотек вроде NextAuth, Middleware для защиты маршрутов и Server Components для получения данных пользователя."
  },
  {
    "id": "next-053",
    "topic": "nextjs",
    "question": "Как обрабатывать ошибки?",
    "answer": "Ошибки в Next.js обрабатываются с помощью error.tsx для runtime-ошибок, try/catch в Server Components и Route Handlers, а также через глобальные обработчики ошибок и fallback UI."
  },
  {
    "id": "next-054",
    "topic": "nextjs",
    "question": "Что такое error.tsx?",
    "answer": "error.tsx — это специальный файл в App Router, который используется как Error Boundary и отображается при возникновении ошибки во время рендера или загрузки данных в соответствующем сегменте маршрута."
  },
  {
    "id": "next-055",
    "topic": "nextjs",
    "question": "Что такое not-found.tsx?",
    "answer": "not-found.tsx — это файл, который определяет интерфейс страницы 404 и отображается, когда маршрут или данные не найдены, либо когда явно вызывается функция notFound()."
  },
  {
    "id": "next-056",
    "topic": "nextjs",
    "question": "Как работает loading.tsx?",
    "answer": "loading.tsx отображается автоматически во время загрузки данных или ленивой инициализации сегмента маршрута и используется для реализации skeleton UI и улучшения пользовательского опыта."
  },
  {
    "id": "next-057",
    "topic": "nextjs",
    "question": "Как деплоится Next.js-приложение?",
    "answer": "Next.js-приложение деплоится либо на Vercel с автоматической поддержкой SSR, Edge и ISR, либо на любой сервер или платформу, поддерживающую Node.js, с помощью сборки и запуска production-сервера."
  },
  {
    "id": "next-058",
    "topic": "nextjs",
    "question": "Какие проблемы могут быть при использовании SSR?",
    "answer": "При использовании SSR возможны повышенная нагрузка на сервер, более медленные ответы при большом трафике, сложности с кешированием и ошибки, связанные с использованием браузерных API на сервере."
  },
  {
    "id": "next-059",
    "topic": "nextjs",
    "question": "Какие частые ошибки допускают в Next.js?",
    "answer": "Частые ошибки в Next.js включают чрезмерное использование Client Components, отсутствие кеширования, неправильное использование SSR вместо SSG, обращение к window на сервере и игнорирование оптимизаций изображений."
  },
  {
    "id": "next-060",
    "topic": "nextjs",
    "question": "Когда Next.js использовать не стоит?",
    "answer": "Next.js не стоит использовать для простых SPA без требований к SEO и серверному рендерингу, небольших виджетов или приложений, где избыточная инфраструктура усложнит разработку без явных преимуществ."
  },
  {
    "id": "fundamentals-001",
    "topic": "fundamentals",
    "question": "Как браузер рендерит страницу?",
    "answer": "Браузер загружает HTML, парсит его в DOM, параллельно загружает и парсит CSS в CSSOM, объединяет DOM и CSSOM в render tree, рассчитывает стили и геометрию элементов (layout), а затем отрисовывает пиксели на экране (paint), после чего может выполнять JavaScript и повторять части процесса при изменениях."
  }
]
