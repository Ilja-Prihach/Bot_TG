[
  {
    "id": "ts-001",
    "topic": "typescript",
    "question": "Зачем нужны дженерики в TypeScript?",
    "answer": "Чтобы описывать универсальные функции и структуры данных с сохранением типов. Это улучшает безопасность и автодополнение."
  },
  {
    "id": "ts-002",
    "topic": "typescript",
    "question": "Что такое TypeScript и зачем он нужен?",
    "answer": "TypeScript — это надстройка над JavaScript, которая добавляет статическую типизацию и современные возможности языка. Он позволяет описывать типы переменных, параметров функций и возвращаемых значений, что помогает находить ошибки ещё на этапе разработки. TypeScript улучшает читаемость и поддерживаемость кода, особенно в больших проектах и командах. Кроме того, он даёт более точное автодополнение и подсказки в IDE, что ускоряет разработку и снижает количество багов."
  },
  {
    "id": "ts-003",
    "topic": "typescript",
    "question": "В чём отличие TypeScript от JavaScript?",
    "answer": "Основное отличие TypeScript от JavaScript — наличие статической типизации. В JavaScript типы проверяются во время выполнения, из-за чего многие ошибки проявляются только в рантайме. TypeScript проверяет типы на этапе компиляции и предупреждает о потенциальных проблемах заранее. Также TypeScript добавляет интерфейсы, enum, дженерики и строгие проверки, при этом итоговый код всегда компилируется в обычный JavaScript."
  },
  {
    "id": "ts-004",
    "topic": "typescript",
    "question": "Какие преимущества даёт статическая типизация?",
    "answer": "Статическая типизация позволяет находить ошибки до запуска приложения, ещё во время разработки. Она делает код более понятным, так как типы служат своего рода документацией. Типизация улучшает автодополнение, навигацию по коду и безопасность рефакторинга. Особенно заметна польза в больших проектах и командах, где важно понимать контракт между разными частями приложения."
  },
  {
    "id": "ts-005",
    "topic": "typescript",
    "question": "Что происходит с TypeScript-кодом перед выполнением в браузере?",
    "answer": "Перед выполнением TypeScript-код компилируется в JavaScript с помощью компилятора TypeScript. В процессе компиляции происходит проверка типов и применение настроек из tsconfig.json. Все типы полностью удаляются, так как браузеры не поддерживают TypeScript напрямую. В результате получается чистый JavaScript-код, который и выполняется в браузере или в Node.js."
  },
  {
    "id": "ts-006",
    "topic": "typescript",
    "question": "Что такое tsconfig.json и зачем он нужен?",
    "answer": "tsconfig.json — это конфигурационный файл TypeScript-проекта. Он определяет, какие файлы входят в проект и какие правила компиляции применять. В нём настраиваются строгая типизация, целевая версия JavaScript, работа с модулями и алиасы путей. Этот файл позволяет использовать единые настройки для всего проекта и упрощает поддержку кода."
  },
  {
    "id": "ts-007",
    "topic": "typescript",
    "question": "Что делает флаг strict?",
    "answer": "Флаг strict включает набор самых строгих проверок типов в TypeScript. Он активирует такие опции, как запрет неявного any и строгую работу с null и undefined. Это заставляет разработчика явно описывать типы и учитывать потенциально опасные места в коде. Использование strict повышает надёжность приложения, хотя и требует более внимательной работы с типами."
  },
  {
    "id": "ts-008",
    "topic": "typescript",
    "question": "Разница между any, unknown и never",
    "answer": "Тип any полностью отключает проверку типов и позволяет выполнять любые операции, что может приводить к ошибкам. unknown является более безопасной альтернативой any, так как требует явной проверки типа перед использованием значения. Тип never используется для ситуаций, когда значение никогда не возникает, например, функция всегда выбрасывает ошибку или не завершается. Эти типы решают разные задачи и должны использоваться осознанно."
  },
  {
    "id": "ts-009",
    "topic": "typescript",
    "question": "Что такое void?",
    "answer": "Тип void используется для функций, которые не возвращают осмысленного значения. Обычно такие функции выполняют побочные эффекты, например, логирование или изменение состояния. Хотя технически функция с void может вернуть undefined, это значение не предполагается к использованию. void помогает явно показать намерение разработчика."
  },
  {
    "id": "ts-010",
    "topic": "typescript",
    "question": "Чем null отличается от undefined?",
    "answer": "undefined означает, что значение не было задано или ещё не определено. null используется как явное указание на отсутствие значения. В TypeScript при включённом strictNullChecks эти значения считаются разными типами и требуют отдельной обработки. Такое разделение делает модель данных более точной и уменьшает количество ошибок."
  },
  {
    "id": "ts-011",
    "topic": "typescript",
    "question": "Что такое enum и когда его стоит использовать?",
    "answer": "enum — это тип в TypeScript, который позволяет определить набор именованных констант. Он удобен для описания фиксированных наборов значений, таких как статусы или роли. enum повышает читаемость кода и защищает от опечаток. Однако в современных проектах часто предпочитают union-типы строк, так как они проще и не добавляют лишнего кода в итоговый JavaScript."
  },
  {
    "id": "ts-012",
    "topic": "typescript",
    "question": "В чём разница между type и interface?",
    "answer": "type и interface используются для описания типов, но имеют разные возможности и сценарии применения. interface в первую очередь предназначен для описания структуры объектов и может быть расширен с помощью extends, а также автоматически объединяется при повторном объявлении. type является более универсальным инструментом, так как позволяет описывать не только объекты, но и union, intersection, примитивы и сложные композиции типов. В целом interface лучше подходит для описания публичных контрактов, а type — для сложных типовых конструкций."
  },
  {
    "id": "ts-013",
    "topic": "typescript",
    "question": "Когда лучше использовать interface, а когда type?",
    "answer": "interface стоит использовать, когда нужно описать форму объекта или контракт, который может расширяться или реализовываться классами. Он хорошо подходит для API, библиотек и объектов с чёткой структурой. type лучше применять, когда требуется объединять типы, использовать union или intersection, либо описывать сложные типовые выражения. На практике часто используют оба подхода, выбирая инструмент в зависимости от задачи."
  },
  {
    "id": "ts-014",
    "topic": "typescript",
    "question": "Что такое union (|) и intersection (&) типы?",
    "answer": "Union-типы позволяют задать несколько возможных типов значения с помощью оператора |. Это означает, что переменная может быть одним из перечисленных типов. Intersection-типы используют оператор & и объединяют несколько типов в один, требуя наличия всех их свойств одновременно. Union используется для вариативных данных, а intersection — для комбинирования нескольких контрактов в один."
  },
  {
    "id": "ts-015",
    "topic": "typescript",
    "question": "Что такое literal types?",
    "answer": "Literal types позволяют ограничить значение конкретными литералами, такими как определённые строки, числа или булевы значения. Например, переменная может принимать только значение 'success' или 'error'. Это повышает точность типизации и помогает избежать ошибок, связанных с неверными значениями. Literal types часто используются вместе с union-типами для описания строгих наборов допустимых значений."
  },
  {
    "id": "ts-016",
    "topic": "typescript",
    "question": "Что такое optional properties (?)?",
    "answer": "Optional properties — это свойства объекта, которые могут присутствовать или отсутствовать. Они обозначаются знаком вопроса после имени свойства. Такие свойства полезны при описании конфигураций, частичных данных или объектов, которые формируются постепенно. TypeScript при этом учитывает, что значение может быть undefined, и требует соответствующей проверки."
  },
  {
    "id": "ts-017",
    "topic": "typescript",
    "question": "Что такое readonly свойства?",
    "answer": "readonly свойства — это свойства, которые нельзя изменить после инициализации объекта. Они помогают защитить данные от случайных изменений и делают код более предсказуемым. readonly особенно полезен для описания неизменяемых структур данных и публичных API. Попытка изменить такое свойство приведёт к ошибке на этапе компиляции."
  },
  {
    "id": "ts-018",
    "topic": "typescript",
    "question": "Как работает Record<K, V>?",
    "answer": "Record<K, V> — это встроенный дженерик-тип TypeScript, который описывает объект с ключами типа K и значениями типа V. Он используется, когда нужно задать структуру словаря или мапы с фиксированным набором ключей. Record упрощает описание однотипных объектов и делает код более читаемым. Часто применяется для конфигураций, статусов или справочников."
  },
  {
    "id": "ts-019",
    "topic": "typescript",
    "question": "Что такое index signature?",
    "answer": "Index signature позволяет описать объект с динамическими ключами, когда заранее неизвестны их имена. Он указывает тип ключа и тип значения, например для объектов-словарей. Такой подход полезен при работе с данными, полученными из API или при создании универсальных структур. Index signature накладывает ограничения на все свойства объекта, что важно учитывать при проектировании типов."
  },
  {
    "id": "ts-020",
    "topic": "typescript",
    "question": "Что такое generics и зачем они нужны?",
    "answer": "Generics (дженерики) — это механизм TypeScript, который позволяет создавать универсальные функции, типы и классы, работающие с разными типами данных, но без потери типовой безопасности. Они позволяют передавать тип как параметр и использовать его внутри определения. Благодаря этому код становится переиспользуемым и при этом строго типизированным. Дженерики особенно полезны, когда логика одинакова, но типы данных могут отличаться."
  },
  {
    "id": "ts-021",
    "topic": "typescript",
    "question": "Как объявить generic-функцию?",
    "answer": "Generic-функция объявляется с использованием параметра типа в угловых скобках. Этот параметр типа затем используется для типизации аргументов и возвращаемого значения. TypeScript может автоматически вывести тип при вызове функции, либо его можно указать явно. Такой подход позволяет функции работать с любыми типами, сохраняя при этом строгую типизацию и корректные подсказки в IDE."
  },
  {
    "id": "ts-022",
    "topic": "typescript",
    "question": "Что такое generic constraints (extends)?",
    "answer": "Generic constraints используются для ограничения допустимых типов в дженериках. С помощью ключевого слова extends можно указать, что параметр типа должен соответствовать определённому интерфейсу или базовому типу. Это позволяет безопасно обращаться к свойствам и методам, которые гарантированно существуют у переданного типа. Constraints делают дженерики более контролируемыми и предсказуемыми."
  },
  {
    "id": "ts-023",
    "topic": "typescript",
    "question": "Пример использования generics в React-компоненте",
    "answer": "В React generics часто используются для типизации пропсов или состояния компонентов, особенно в универсальных компонентах, таких как списки или таблицы. Дженерики позволяют передавать тип данных элемента и использовать его внутри компонента без привязки к конкретной структуре. Это делает компонент переиспользуемым и безопасным с точки зрения типов, а также улучшает автодополнение при его использовании."
  },
  {
    "id": "ts-024",
    "topic": "typescript",
    "question": "В чём польза generics по сравнению с any?",
    "answer": "Использование generics сохраняет строгую типизацию, тогда как any полностью её отключает. С any TypeScript перестаёт проверять корректность операций, что может приводить к ошибкам в рантайме. Generics позволяют работать с разными типами, но при этом точно знать, какой тип используется в каждом конкретном случае. В результате код становится безопаснее, понятнее и удобнее для поддержки."
  },
  {
    "id": "ts-025",
    "topic": "typescript",
    "question": "Что такое Utility Types?",
    "answer": "Utility Types — это встроенные вспомогательные типы TypeScript, которые позволяют преобразовывать и переиспользовать существующие типы без дублирования кода. Они помогают создавать новые типы на основе уже существующих, изменяя их свойства, обязательность или структуру. Utility Types широко используются для работы с DTO, состояниями, конфигурациями и результатами функций. Их основная цель — сделать типизацию более гибкой, лаконичной и удобной для поддержки."
  },
  {
    "id": "ts-026",
    "topic": "typescript",
    "question": "Чем отличаются Partial, Required, Readonly?",
    "answer": "Partial делает все свойства типа необязательными, что удобно при работе с частичными объектами, например при обновлении данных. Required, наоборот, делает все свойства обязательными, даже если в исходном типе они были optional. Readonly помечает все свойства как доступные только для чтения, запрещая их изменение после инициализации. Эти utility types позволяют быстро менять поведение свойств без переписывания типов."
  },
  {
    "id": "ts-027",
    "topic": "typescript",
    "question": "Что делает Pick и Omit?",
    "answer": "Pick создаёт новый тип, выбирая только указанные свойства из существующего типа. Он полезен, когда нужен поднабор полей, например для отображения или передачи в компонент. Omit работает наоборот — он исключает указанные свойства из типа. Оба типа часто применяются при работе с API, формами и слоями приложения, чтобы не дублировать типы и избежать рассинхронизации."
  },
  {
    "id": "ts-028",
    "topic": "typescript",
    "question": "Что такое ReturnType?",
    "answer": "ReturnType — это utility type, который извлекает тип возвращаемого значения функции. Он полезен, когда нужно переиспользовать результат функции в других типах без ручного дублирования. ReturnType помогает поддерживать согласованность типов, особенно если сигнатура функции со временем меняется. Часто используется вместе с фабричными функциями и селекторами."
  },
  {
    "id": "ts-029",
    "topic": "typescript",
    "question": "Что такое Parameters?",
    "answer": "Parameters — это utility type, который извлекает типы аргументов функции в виде tuple. Он позволяет получить информацию о параметрах функции и использовать её повторно в других местах кода. Это особенно полезно при создании обёрток, прокси-функций или хелперов, которые должны принимать те же аргументы. Parameters снижает риск ошибок при изменении сигнатуры функции."
  },
  {
    "id": "ts-030",
    "topic": "typescript",
    "question": "Что делает NonNullable?",
    "answer": "NonNullable удаляет null и undefined из указанного типа. Он используется, когда необходимо гарантировать, что значение существует и не является пустым. Этот utility type особенно полезен при работе с данными из API или опциональными значениями. NonNullable помогает TypeScript точнее проверять типы и уменьшает количество дополнительных проверок в коде."
  },
  {
    "id": "ts-031",
    "topic": "typescript",
    "question": "Что такое type narrowing?",
    "answer": "Type narrowing — это механизм TypeScript, который позволяет сузить общий тип переменной до более конкретного в определённом участке кода. Изначально переменная может иметь union-тип, но после проверки условий TypeScript понимает, с каким именно типом мы работаем. Narrowing происходит автоматически при использовании условий, проверок типов и специальных операторов. Это позволяет безопасно обращаться к свойствам и методам конкретного типа без использования небезопасных приведений."
  },
  {
    "id": "ts-032",
    "topic": "typescript",
    "question": "Что такое type guard?",
    "answer": "Type guard — это проверка, которая помогает TypeScript определить более точный тип значения. В качестве type guard могут выступать конструкции вроде typeof, instanceof, оператор in или пользовательские функции с возвращаемым типом-предикатом. После успешной проверки TypeScript сужает тип внутри соответствующего блока кода. Type guards позволяют писать безопасный код при работе с union-типами и сложными структурами данных."
  },
  {
    "id": "ts-033",
    "topic": "typescript",
    "question": "Как работает оператор in?",
    "answer": "Оператор in используется для проверки наличия свойства в объекте. В TypeScript он также является type guard и помогает сузить тип, если union состоит из объектов с разными наборами свойств. После проверки TypeScript понимает, что объект точно содержит указанное свойство, и разрешает безопасный доступ к нему. Этот оператор особенно полезен при работе с union-типами интерфейсов."
  },
  {
    "id": "ts-034",
    "topic": "typescript",
    "question": "Что делает typeof в TypeScript?",
    "answer": "В TypeScript оператор typeof используется в двух контекстах. Во время выполнения он работает так же, как в JavaScript, возвращая строку с типом значения. На уровне типов typeof позволяет получить тип переменной или функции и использовать его в других типах. В проверках условий typeof также выступает как type guard, помогая сузить тип значения."
  },
  {
    "id": "ts-035",
    "topic": "typescript",
    "question": "Что такое discriminated unions?",
    "answer": "Discriminated unions — это шаблон типизации, при котором union-типы объектов имеют общее поле-дискриминатор с литеральным значением. По значению этого поля TypeScript может точно определить, с каким вариантом типа мы работаем. Такой подход делает код более читаемым и безопасным, особенно при работе с состояниями, событиями и результатами API. Discriminated unions активно используются в Redux, state machines и React-приложениях."
  },
  {
    "id": "ts-036",
    "topic": "typescript",
    "question": "Что такое assertion (as) и когда его не стоит использовать?",
    "answer": "Assertion — это явное приведение типа с помощью ключевого слова as, которое сообщает TypeScript, какому типу следует считать значение. Оно не выполняет никаких проверок в рантайме и полностью основано на доверии к разработчику. Assertion стоит использовать только тогда, когда TypeScript не может корректно вывести тип, но разработчик точно знает структуру данных. Не рекомендуется злоупотреблять as, так как это может скрывать реальные ошибки и снижать типовую безопасность."
  },
  {
    "id": "ts-037",
    "topic": "typescript",
    "question": "Почему unknown безопаснее, чем any?",
    "answer": "unknown безопаснее, чем any, потому что он не позволяет выполнять операции над значением без предварительной проверки типа. Если переменная имеет тип any, TypeScript полностью отключает проверку типов и разрешает доступ к любым свойствам и методам, что может привести к ошибкам в рантайме. unknown, наоборот, заставляет разработчика явно сузить тип с помощью type guards или проверок, прежде чем использовать значение. Это сохраняет контроль над типами и снижает риск скрытых ошибок."
  },
  {
    "id": "ts-038",
    "topic": "typescript",
    "question": "Почему interface можно расширять, а type — нет?",
    "answer": "interface поддерживает механизм декларативного расширения, включая extends и автоматическое слияние объявлений. Это позволяет добавлять новые свойства к уже существующему интерфейсу, что удобно для расширяемых контрактов и публичных API. type является алиасом типа и не поддерживает повторное объявление с объединением, так как он предназначен для создания конкретных типовых выражений. Такое различие сделано осознанно, чтобы interface был более гибким для объектных контрактов, а type — более строгим и универсальным."
  },
  {
    "id": "ts-039",
    "topic": "typescript",
    "question": "Почему злоупотребление as — плохая практика?",
    "answer": "Злоупотребление as опасно тем, что оно принудительно сообщает TypeScript доверять разработчику, игнорируя реальные проверки типов. Assertion не выполняет никакой валидации в рантайме и может скрыть ошибки в данных или логике. Частое использование as обычно указывает на плохо описанные типы или архитектурные проблемы. В результате код становится менее надёжным и теряется основное преимущество TypeScript — типовая безопасность."
  },
  {
    "id": "ts-040",
    "topic": "typescript",
    "question": "Как TypeScript помогает при рефакторинге?",
    "answer": "TypeScript делает рефакторинг безопаснее за счёт строгой проверки типов и связей между ними. При изменении сигнатуры функции, структуры объекта или типа параметра компилятор сразу указывает все места, где код больше не соответствует новым типам. Это снижает риск пропустить ошибку и сломать функциональность. Благодаря типам IDE может надёжно переименовывать сущности, удалять неиспользуемый код и подсказывать корректные изменения."
  },
  {
    "id": "ts-041",
    "topic": "typescript",
    "question": "Какие ошибки TypeScript не может поймать?",
    "answer": "TypeScript не может поймать ошибки, связанные с логикой выполнения программы, так как типы проверяются только на этапе компиляции. Он не защищает от неправильных условий, бесконечных циклов или ошибок бизнес-логики. Также TypeScript не может гарантировать корректность данных, полученных из внешних источников, таких как API или пользовательский ввод. В рантайме весь код является обычным JavaScript, поэтому ошибки времени выполнения всё равно возможны."
  },
  {
    "id": "ts-042",
    "topic": "typescript",
    "question": "Как типизировать props?",
    "answer": "Props в React типизируются с помощью interface или type, которые описывают структуру передаваемых свойств. Затем этот тип используется в сигнатуре компонента как тип параметра функции. Такой подход позволяет TypeScript проверять корректность передаваемых пропсов, подсказывать их в IDE и предотвращать ошибки при использовании компонента. Типизация props особенно важна для переиспользуемых и публичных компонентов."
  },
  {
    "id": "ts-043",
    "topic": "typescript",
    "question": "Разница между FC<Props> и обычной функцией?",
    "answer": "FC<Props> — это тип React для функциональных компонентов, который автоматически добавляет типизацию children и некоторых статических свойств. Однако он может скрывать реальные требования к props и иногда усложняет типизацию generics. Обычная функция с явной типизацией параметров считается более гибким и явным подходом. В современных проектах чаще предпочитают обычные функции без FC."
  },
  {
    "id": "ts-044",
    "topic": "typescript",
    "question": "Как типизировать children?",
    "answer": "children обычно типизируют как React.ReactNode, так как он покрывает строки, элементы, массивы и null. Это самый универсальный и безопасный вариант. В более строгих случаях можно ограничить children конкретным типом, например только JSX-элементами. Явная типизация children делает контракт компонента более понятным."
  },
  {
    "id": "ts-045",
    "topic": "typescript",
    "question": "Как типизировать useState?",
    "answer": "useState можно типизировать либо через начальное значение, либо явно указав тип состояния. Если начальное значение однозначно определяет тип, TypeScript выведет его автоматически. В случаях с null, undefined или сложными union-типами рекомендуется указывать тип явно. Это помогает избежать неожиданных ошибок при обновлении состояния."
  },
  {
    "id": "ts-046",
    "topic": "typescript",
    "question": "Почему useState(null) — потенциальная проблема?",
    "answer": "При использовании useState(null) TypeScript выводит тип состояния как null, что делает невозможным присваивание других значений без явной типизации. Это часто приводит к необходимости использовать as или any. Правильнее сразу указывать union-тип, например null | SomeType. Такой подход делает состояние безопасным и предсказуемым."
  },
  {
    "id": "ts-047",
    "topic": "typescript",
    "question": "Как типизировать useRef?",
    "answer": "useRef типизируется с помощью дженерика, который указывает тип значения current. Для DOM-элементов обычно используют union с null, так как ref изначально пустой. Корректная типизация useRef позволяет безопасно работать с DOM и избежать лишних проверок или assertion. Это особенно важно при работе с фокусом, размерами и сторонними библиотеками."
  },
  {
    "id": "ts-048",
    "topic": "typescript",
    "question": "Почему any — зло?",
    "answer": "any полностью отключает проверку типов и лишает TypeScript его основной ценности. Использование any позволяет писать потенциально ошибочный код без каких-либо предупреждений компилятора. Это приводит к ошибкам в рантайме и усложняет поддержку и рефакторинг. any допустим только как временная мера, но не как постоянное решение."
  },
  {
    "id": "ts-049",
    "topic": "typescript",
    "question": "Когда unknown лучше?",
    "answer": "unknown лучше использовать, когда тип значения заранее неизвестен, например при работе с данными из API или пользовательским вводом. В отличие от any, unknown требует явной проверки типа перед использованием. Это заставляет писать более безопасный код и предотвращает случайные ошибки. unknown сохраняет контроль над типами и улучшает надёжность."
  },
  {
    "id": "ts-050",
    "topic": "typescript",
    "question": "Как работать с unknown безопасно?",
    "answer": "Для безопасной работы с unknown необходимо использовать type narrowing. Это можно сделать с помощью typeof, instanceof, оператора in или пользовательских type guard-функций. После проверки TypeScript позволяет обращаться к значениям как к конкретному типу. Такой подход делает код безопасным и явно показывает логику обработки данных."
  },
  {
    "id": "ts-051",
    "topic": "typescript",
    "question": "Как сузить unknown?",
    "answer": "unknown сужается с помощью проверок типов и условий. Например, проверка typeof value === 'string' позволяет TypeScript понять, что внутри блока value является строкой. Также можно использовать пользовательские type guards с type predicate. Без такого сужения TypeScript не разрешит использование значения."
  },
  {
    "id": "ts-052",
    "topic": "typescript",
    "question": "Когда TypeScript выводит never?",
    "answer": "Тип never появляется, когда значение не может существовать. Это происходит, например, в функциях, которые всегда выбрасывают ошибку или никогда не завершаются. Также never используется, когда TypeScript понимает, что код недостижим. never помогает выявлять логические ошибки в программе."
  },
  {
    "id": "ts-053",
    "topic": "typescript",
    "question": "Зачем нужен never в switch?",
    "answer": "never в switch используется для проверки того, что обработаны все возможные варианты union-типа. Если добавить проверку с never в default-ветке, TypeScript сообщит об ошибке при появлении нового варианта, который не был обработан. Это делает switch-конструкции безопасными и защищает от пропущенных кейсов."
  },
  {
    "id": "ts-054",
    "topic": "typescript",
    "question": "Как never помогает при exhaustiveness checking?",
    "answer": "Exhaustiveness checking — это приём, который гарантирует, что все варианты union-типа обработаны. Использование never позволяет TypeScript сигнализировать об ошибке, если появляется необработанный вариант. Это особенно полезно при работе с discriminated unions и сложной бизнес-логикой. Такой подход делает код более надёжным и устойчивым к изменениям."
  }
]
